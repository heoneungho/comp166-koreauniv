

# 01. 껍질을 깨고:간단한 소개 #

**48p BeerSong** _문제해결하기, 주석달기_

```

public calss BeerSong {
public static void main (String[] args) {
int beerNum = 99;
String word = "bottles"; // 복수형

while (beerNum > 0) {

System.out.println("beerNum + " " + word + " of beer on the wall");
System.out.println("beerNum + " " + word + " of beer.");
System.out.println("Take one down.");
System.out.println("Pass it around.");
beerNum = beerNum -1;

if (beerNum == 1) {
 word = "bottle"; //단수형(한병인경우)
}

if (beerNum > 0) {
System.out.println("beerNum + " " + word + " of beer on the wall");
}
else {
System.out.println("No more bottles of beer on the wall");
}//else문 끝
}//while순환문 끝
}//main 클래스 끝
}//클래스 끝

```

**50p PhraseOMatic** _wordListOne, wordListTwo, wordListThree를 변경_

```

public class PhraseOMatic{
   public static void main(String[]args){ //세 종류의 단어 목록을 만든다
     String[]wordListOne={"monotonic","corollary "};
     String[]wordListTwo={"jerk","secant"};
     String[]wordListThree={"perimeter","mnemonic"};

     int oneLength=wordListOne.length;
     int twoLength=wordListTwo.length;
     int threeLength=wordListThree.length;//난수 발생

     int rand1=(int) (Math.random()*oneLength);
     int rand2=(int) (Math.random()*twoLength);
     int rand3=(int) (Math.random()*threeLength);
     String phrase=wordListOne[rand1]+""+wordListTwo[rand2]+""+wordListThree[rand3];//구문 출력

System.out.println("What we need is a"+phrase); 
}
}

```

**52p 집중토론** _요약_

  * 자바 가상 머신: 프로그램을 실행시키는 역할을 한다. 또 보안관련 작업을 수행한다
  * 컴파일러: 어떤 프로그램이 실행될 때 절대로 일어나면 안 되는 일을 방지한다.

**55p 컴파일러가 되어봅시다** _구현후 주석달기_

```
A
class Exercise1b {
  public static void main(Strinc [] args) {
   int x = 1;
   while ( x < 10 ) {
    X = X+1;
     if (x > 3) {
       System.out.println("big x");
     }
   }
  }
}

B
Class Foo{
   public static void main(String [] args) {
    int x = 5;
    while ( x > 1){
     x = x -1;
      if(x<3){
        System.ot.println("small x");
      }
    }
   }
}

C

class Exercise1b {
   public static void main(String [] args){

    int x = 5;
    while ( x > 1) {
      x = x - 1;
      if ( x < 3) {
        System.out.println("small x");
      }
    }
   }
}
```


# 02. 객체마을로의 여행:객체에 대해 알아봅시다 #

**68p~ 클래스** _요약_

  * 인스턴스 변수: 객체에서 자신에 대해 아는 것, 객체의 상태(데이터)를 나타낸다.
  * 메소드: 객체에서 자신이 하는 것.
  * 클래스: 객체를 만들기 위한 용도로 사용. 객체를 만들기 위한 청사진.
  * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.



> 68p Television 채워넣기
  * 인스턴스 변수: color, power, channel
  * 메소드: power(), channelUp(), ChannelDown()


**72p GuessGame** _게임에 참여하는 사람 수를 4명으로 변경_

```
/* 사람수를 4명으로 하려면 같은 형식으로 클래스 안에 p4에 해당하는것을 p1 p2 p3와 똑같이 써주고 조건문을 조금 바꾸면 됩니다. */

class GuessGame {

    Player p1;
    Player p2;
    Player p3;
    Player p4; // 4번째 플레이어

public void startGame(){
   p1=new Player();
   p2=new Player();
   p3=new Player();
   p4=new Player();

   int guessp1=0; // 각 객체가 찍은 숫자를 저장하기위한 변수
   int guessp2=0;
   int guessp3=0;
   int guessp4=0;

   boolean p1isRight=false;
   boolean p2isRight=false;
   boolean p3isRight=false;
   boolean p4isRight=false;

   int targetNumber=(int)(Math.random()*10);
   System.out.println("0이상 9이하의 숫자를 맞춰보세요.");

while(true){

   System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");

p1.guess(); // 각 사람이 숫자를 추측합니다.
p2.guess();
p3.guess();
p4.guess();

guessp1=p1.number;
System.out.println("1번 선수가 찍은 숫자:"+guessp1);

guessp2=p2.number; 
System.out.println("2번 선수가 찍은 숫자:"+guessp2);

guessp3=p3.number; 
System.out.println("3번 선수가 찍은 숫자:"+guessp3);

guessp4=p4.number; 
System.out.println("4번 선수가 찍은 숫자:"+guessp4); 

// 각 선수가 찍은 숫자를 알아냅니다.

if(guessp1==targetNumber){ 
   p1isRight=true;
}
if(guessp2==targetNumber){
   p2isRight=true;
}                        
if(guessp3==targetNumber){
   p3isRight=true;
}                        
if(guessp4==targetNumber){  
   p4isRight=true;
}                        

if(p1isRight|p2isRight|p3isRight|p4isRight){
      System.out.println("맞춘 선수가 있습니다.");       
      System.out.println("1번 선수:" + p1isRight);
      System.out.println("2번 선수:" + p2isRight);
      System.out.println("3번 선수:" + p3isRight);
      System.out.println("4번 선수:" + p4isRight);
      System.out.println("게임 끝.");
      break;
}

 else{
   System.out.println("다시 시도해야 합니다."); 
     }
    }
  }
}

class Player{
int number=0;

public void guess(){
number=(int)(Math.random()*10);
System.out.println("찍은 숫자:"+number);
 }
}

public class GameLauncher{

public static void main (String[]args){
GuessGame game=new GuessGame();
game.startGame();
  }
}

```

**76p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A

class TapeDeck{ // TapeDeck 클래스 생성
  boolean canRecord=false; // canRecord를 Boolean값으로 설정
   void playTape(){
    System.out.println("tape playing");
   }
   void recordTape(){
    System.out.println("tape recording");
   }
}
class TapeDeckTestDrive{ // TapeDeckTest 클래스 생성

 public static void main(String[]args){

   TapeDeck t=new TapeDeck(); // 이름이 t인 객체 생성
     t.canRecord=true;
     t.playTape();
   
   if(t.canRecord==true){
     t.recordTape();
   }
 }
}

B

class DVDPlayer{

  boolean canRecord=false; // canRecord를 Boolean값으로 설정

    void recordDVD(){
     System.out.println("DVD recording");
    }

    void playDVD(){ 
      System.out.println("DVD playing");
    }
}

class DVDPlayerTestDrive{

   public static void main(String[]args){
     DVDPlayer d = new DVDPlayer();
     d.canRecord=true;
     d.playDVD();

       if(d.canRecord==true){
        d.recordDVD();
       }
   }
}

```

# 03. 네 변수를알라:원시 변수와 레퍼런스 #

**83p~ 변수** _요약_

  * 원시변수 vs 레퍼런스변수: 변수는 크게 원시변수와 레퍼런스 변수로 나눌 수 있다.
> > 원시 변수에는 정수, 부우르 부동소수점 수와 같은 단순한 비트 패턴으로 나타낼 수 있는 값이 들어간다.
> > 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다

**96p Dog** _수많은 개를 만들어 난장판 만들기_

```
class Dog { 

 String name;

   public static void main(String[]args){ // Dog 객체를 만들고 접근합니다.

    Dog dog1 = new Dog();
    dog1.bark();
    dog1.name="Bart";

//이번에는 Dog 배열을 만듭니다
    Dog[]myDogs=new Dog[5]; // 개 5마리를 집어넣는다
    myDogs[0]=new Dog();
   myDogs[1]=new Dog();
   myDogs[2]=new Dog();
   myDogs[3]=new Dog();
   myDogs[4]= dog1;

   myDogs[0].name="Fred";
   myDogs[1].name="Marge";
   myDogs[2].name="A";
   myDogs[3].name="B"; 

    System.out.print("마지막 개의 이름:");
    System.out.println(myDogs[4].name); 
// 순환문을 써서 배열에 있는 모든 개가 짖게 한다.

   int x=0;
   while(x<myDogs.length){
    myDogs[x].bark();
    x=x+1;
   }
}

public void bark(){
  System.out.println(name + "이(가) 왈!하고 짖습니다.");
}

 public void eat(){
 }
 public void chaseCat(){
 }
}

```

**97p 컴파일러가 되어봅시다** _구현후 주석달기_

```
A

// Books 클래스를 생성합니다.
class Books{
  String title;
String author;
}

class BooksTestDrive {
 public static void main(String[]args){

   Books[]myBooks=new Books[3];
   int x=0;// Books 객체를 생성합니다.

   myBooks[0]=new Books();
   myBooks[1]=new Books();
   myBooks[2]=new Books();// 객체들의 속성을 채워줍니다.
   myBooks[0].title="The Grapes of Java";
   myBooks[1].title="The Java Gatsby";
   myBooks[2].title="The Java Cookbook";
   myBooks[0].author="bob";
   myBooks[1].author="sue";
   myBooks[2].author="ian";

   while(x<3){
     System.out.print(myBooks[x].title);
     System.out.print("by");
     System.out.println(myBooks[x].author);
       x = x+1;
   }
}
}

B

// Hobbits 클래스를 생성합니다.
class Hobbits {

  String name;

  public static void main (String [] args) {

    Hobbits [] h = new Hobbits[3];
    int z = -1; // 변수 수정

while (z<2){// 배열의 인덱스는 0부터 이다
  z = z + 1; 
 h[z] = new Hobbits(); //객체를 생성합니다.
 h[z].name = "bilbo";
 
 if (z == 1) {
   h[z].name = "frodo";
}
 if (z == 2) {
   h[z].name = "sam";
}

 System.out.print(h[z].name + " is a ");
 System.out.println("good hobbit name");
 
}
}}

```

**101p 레퍼런스 도용사건** _요약_

  * 누가 이겼나요?: 밥
  * 문제가 된 부분은 어딘가요?: 켄트는 while문이 돌때마다 새로운 객체를 레퍼런스변수에 대입해서 while문이 돌기 바로 직전 객체는 사라진다

# 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향 #

**105p~ 객체** _요약_

  * 캡슐화:객체의 자료와 행위를 하나로 묶고 실제 구현 내용을 외부에 감추는 것.
  * 게터와 세터: 게터는 단지 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 쓰인다. 세터는 그 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다
  * 인스턴스 변수 vs 지역 변수:

> 인스턴스 변수는 클래스 내에서 선언된다. 지역변수는 메소드 내에서 선언되고 기본값이 없으며, 사용 전에 반드시 초기화 해야 한다.

**107p Dog** _실행_

```
class Dog {
   int size;
   String name;
     void bark() {
       if (size >60) {
         System.out.println("Wooof!");
       }else if (size > 14) {
         System.out.println("Yip!");
       }else {
         System.out.println("Ruff!");
       }
     }
}

Public class DogTestDrive {

   public static void main (String [] args) {
     Dog one = new Dog();
     one.size = 70;
     Dog two = new Dog();
     two.size = 8;
     Dog three = new Dog();
     three.size = 35;
     one.bark();
     two.bark();
     three.bark();
}}

```

**122p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A

public class XCopy {
   public static void main(String[] args) {
    int orig=42;

    XCopy x=new XCopy(); // XCopy 객체 x를 생성

    int y= x.go(orig); // y를 go함수에 orig(=42)라는 변수를 넣어서 받는다
    System.out.println(orig+""+y); // orig와 y를 출력
    }

    int go(int arg){
       arg=arg*2;
       return arg;
    }
}

B
public class Clock{
   String time;
   void setTime(String t){
     time=t;
   }
   String getTime(){
     return time;
   }
}

public class ClockTestDrive {

   public static void main(String[] args) {
     Clock c= new Clock();
     c.setTime("1245");
     String tod=c.getTime(); //tod에 게터로 설정된 시간을 받는다
     System.out.println("time:"+tod); //출력
   }
}



```


# 05. 메소드를 더 강력하게:흐름 제어, 연산 등 #

**135p XP** _요약_

  * 익스트림 프로그래밍이란?
90년대 말에 등장했고, 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다. 규칙은 다음과 같다.

-조금씩, 하지만 자주 발표한다
-사이클을 반복해서 돌리면서 개발한다
-스펙에 없는 것은 절대 집어넣지 않는다.
-테스트 코드를 먼저 만든다.
-정규 일과 시간에만 작업한다.
-언제 어디서든 코드를 개선한다.
-모든 테스트를 통과하기 전에는 어떤것도 발표 금지
-조금씩 발표하는 것을 기반으로 현실적인 작업계획
-모든 일을 단순하게 처리
-두명씩 팀을 편성하고 모든 사람들이 대부분의 코드를 알 수 있도록 돌아가면서 작업


**137p~ 간단한 닷컴 게임** _구현후 주석달기_

```
public class SimpleDotCom {
   int[] locationCells;//int 형 배열을 선언
   int numOfHits = 0;//numOfHits를 0으로 초기화
    public void setLocationCells(int [] locs){
     locationCells = locs;
   }

  public String checkYourself(String stringGuess){
    int guess = Integer.parseInt(stringGuess);string 타입의 수를 int 형으로 변환
    String result = "miss";//기본값 miss로 선언
    for(int i = 0 ;i < locationCells.length; i++){// 추측값 원소와 비교
      if(guess == locationCells[i]){
         result = "hit";
         numOfHits++;
        break;//반복문을 빠져나옵니다.
      }
    }
    if(numOfHits == locationCells.length){
     result = "kill";
     }
    System.out.println(result);
    return result;
 }
}

public class SimpleDotComGame {
  public static void main(String[] args){

   int numOfGuesses = 0;
   GameHelper helper = new GameHelper();

   SimpleDotCom theDotCom = new SimpleDotCom();
   int randomNum = (int) (Math.random() * 5);

   int[] locations = {randomNum, randomNum + 1,randomNum + 2};
   theDotCom.setLocationCells(locations);
   boolean isAlive = true;

   while(isAlive == true){
     String guess = helper.getUserInput("enter a number");
     String result = theDotCom.checkYourself(guess);
     numOfGuesses++;
     if(result.equals("kill")){
       isAlive = false;
       System.out.println(numOfGuesses + " guesses"); 
     }
    }
   }
}
import java.io.*;//가져오기를 선언해줍니다.System.in을 사용하기 위해서이다
public class GameHelper{

  public String getUserInput(String prompt){
    String inputLine = null;
    System.out.println(prompt + " ");
    try{ // 예외처리를 한다
     BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
     inputLine = is.readLine();
     if(inputLine.length() == 0 )return null;
    }
    catch (IOException e){
     System.out.println("IOException: " + e);
    }
    return inputLine;
  }
}

```

# 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다 #

**162p 닷컴 게임:첫번째 옵션** _구현후 주석달기_

```
 public class SimpleDotCom {
  int[] locationCells;
	
  String[] hitCells;
  int numOfHits = 0;
	
  public void setLocationCells(int[] locs){
  locationCells = locs;
}
	
//checkYourself 함수 선언
 public String checkYourself(String stringGuess){
		
  int guess = Integer.parseInt(stringGuess);
  string result = "miss";
		
  for(int i = 0; i<locationCells.length; i++){
   
   if(hitCells[i] == "true")
   break;
   
   if(guess == locationCells[i]){
   result = "hit";
   hitCells[i] = "true";
   numOfHits++;
   break;
 }
}
		
  if(numofHits == locationCells.length){
  result = "kill";
 }
  System.out.println(result);
  return result;
 }//메소드 끝
}//클래스 끝


```

**163p 닷컴 게임:두번째 옵션** _구현후 주석달기_

```
public class SimpleDotCom {

 int[] locationCells;
 int numOfHits = 0;
		
 public void setLocationCells(int[] locs) {
  locationCells = locs;
 }
		
 public String checkYourself (String stringGuess) {
  int guess = Integer.parseInt(stringGuess);
  String result = "miss";
  for(int i = 0; i < locationCells.length; i++) {
   if (guess == locationCells[i]) {
    result = "hit";
    numOfHits++;
    locationCells[i] = -1; // 값을 -1으로 바꿉니다.
    break;
   }
  } // 순환문 끝
  if (numOfHits == locationCells.length) {
  result = "kill";
 }
 System.out.println(result);
 return result;
} // 메소드 끝
} // 클래스
```

**173p 닷컴 게임:세번째 옵션** _구현후 주석달기_

```
import java.util.ArrayList;

public class DotCom {

private ArrayList<String> locationCells;
		
// int numOfHits = 0;
// (없어도 됩니다)
		
public void setLocationCells(ArrayList<String> loc) {
locationCells = loc;
}
		
public String checkYourself (String userInput) {
	
String result = "miss";
			
int index = locationCells.indexOf(userInput);
			
if (index >= 0) {
locationCells.remove(index);
				
if (locationCells.isEmpty() ) {
result = "kill";
} else {
result = "hit";
} // if문 끝
} // 바깥쪽 if문 끝
	
System.out.println(result);
return result;
} // 메소드 끝
} // 클래스 끝


```

**174p 진짜 닷컴 게임** _구현후 주석달기_

```

```

# 07. 객체마을에서의 더 나은 삶:미래를 준비합시다 #

**199p~ 상속과 다형성** _요약_

  * 상속: 상위클래스로부터 인스턴스 변수와 메소드를 하위클래스에게 넘겨주는 것
  * 다형성: 여러가지 형태를 하나의 그릇으로 나타낼 수 있다. 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다.

**208p 클래스 계층 구조** _클래스로 구현_

```
class Animal {
   String picture;
   Boolean food;
   int hunger;
   float boundaries;
   float location;

   void makeNoise() // 소리내기 메소드{ 
   }
   void eat() // 먹기 메소드{
   }
   void sleep() // 잠자기 메소드{
   }
   void roam() // 깨어있기 메소드{
   }
}

class Feline extends Animal // Feline은 Animal을 상속{
   void roam(){
   }
}

class Lion extends Feline // Lion은 Feline을 상속{  
   void makeNoise(){
   }
   void eat(){
   }
}
class Cat extends Feline// Cat은 Feline을 상속{
   void makeNoise(){
   }
   void eat(){
   }
}
class Tiger extends Feline // Tiger는 Feline을 상속{
   void makeNoise(){
   }
   void eat(){
   }
}

class Hippo extends Animal // Hippo는 Animal을 상속{
   void makeNoise(){
   }
   void eat(){
   }
}
class Canine extends Animal // Canine은 Animal을 상속{
   void roam(){
   }
}
class Dog extends Canine // Dog는 Canine을 상속{
   void makeNoise(){
   }
   void eat(){
   }
}

class Wolf extends Canine // Wolf는 Canine을 상속{
   void makeNoise(){
   }
   void eat(){
   }
}

```

**224p 오버라이드와 오버로딩** _요약_

  * 오버라이드: 부모 메소드를 자식 메소드에서 재정의 하는 것
  * 오버로딩: 하나의 클래스 내에 인수의 개수나 형식이 다른 동일한 이름의 메소드를 여러개 정의하는 것

**227p 컴파일러가 되어봅시다** _구현후 주석달기_

```
public class MonsterTestDrive {
   public static void main(String[] args) {
     Monster [] ma = new Monster[3]; // 배열 생성
      ma[0] = new Vampire();
      ma[1] = new Dragon();
      ma[2] = new Monster();

     for(int x = 0; x < 3; x++) {
      ma[x].frighten(x);
     }
   }
}

class Monster {
   boolean frighten(int d){
     System.out.println("arrrgh");
     return true;
   }
}

class Vampire extends Monster //Monster를 상속받는다 {
    boolean frighten (int x) { //오버라이드
     System.out.println("a bite?");
     return false;
    }
}

class Dragon extends Monster//Monster를 상속받는다 {
    boolean frighten (int degree) {
     System.out.println("breath fire");
     return true;
    }
}

```

# 08. 심각한 다형성:추상 클래스와 인터페이스 #

**231p~ 심각한 다형성** _요약_

  * 인터페이스:
  * 다형성: 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것. 상위클래스를 상속하는 여러가지 클래스들을 하나의 레퍼런스 변수로 가리키게 할 수 있다.
  * 추상 클래스:상속을 위한 클래스다
  * 추상 메소드:추상클래스가 아닌 클래스에 추상 메소드를 집어 넣을 수 없다.
  * 다중 상속:한 클래스가 여러 부모 클래스에서 동시에 상속받는것

# 09. 객체의 삶과 죽음:생성자와 메모리 관리 #

**269p~ 객체의 삶과 죽음** _요약_

  * 힙에서의 변수: 인스턴스변수라고 하는데, 클래스 내에서 선언된 변수이고 메소드 내에서 선언한 것은 인스턴스 변수가 아니다. 인스턴스 변수는 각각의 개별 객체가 가지고 있는 필드를 나타낸다.

  * 스택에서의 변수:지역변수라고 하는데, 지역변수는 메소드 안에서 선언한 것을 뜻한다.지역변수는 임시변수이며, 메소드가 스택에 들어있는동안만 살아있다.

  * 생성자:어떤 클래스 유형에 대해 new 키워드를 사용할 때 실행되는 코드이다. 생성자명은 반드시 클래스명과 같아야 하며 리턴 유형은 없다. 생성자를 이용해 인스턴스변수를 초기화 할 수 있고, 클래스에 생성자가 없으면, 컴파일러에서 기본 생성자를 만든다.

  * 널 레퍼런스: 프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지정된다. 객체에 대한 레퍼런스의 기본값은 null이고 이것을 널 레퍼런스라고 부른다.

**298p 집중토론** _요약_

  * 인스턴스 변수: 인스턴스 변수는 객체를 지원하는 역할을 하고, 상태는 인스턴스 변수에 저장된 값이다. 객체 안에서 살며 객체의 상태를 저장한다. 자신이 속한 객체가 가비지 컬렉터에 의해 처리된다면 인스턴스 변수도 함께 삭제된다.

> 지역 변수: 지역변수는 임시 변수로도 불리고 지역, 스택, 자동, 영역 제한같은 용어를 선호한다. 또 다른 여러 지역 변수와 함께 스택 프레임에 빼곡하게 들어가 있어야 하고 자신의 프레임이 스택 맨 위로 올라갈 때 까지 하는 것이 없다. 프레임이 사라지지 않는 이상 자신이 저장하고 있는 값도 유지된다. 또한 객체를 참조하는 유일한 레퍼런스가 지역 변수에서만있으면 지역 변수가 사라질 때 그 인스턴스 변수도 같이 사라진다.


**302p 5분 미스터리** _구현후 주석달기_

```
import java.util.*;
class V2Radiator{
  V2Radiator(ArrayList<SimUnit> list){ //ArrayList를 전달
   for(int x = 5; x < 5 ; x++){
    list.add(new SimUnit("V2Radiator")); // V2Radiator 객체를 추가한다
}
}
}
class V3Radiator{
  V3Radiator(ArrayList<SimUnit> lglist){//super(lglist)삭제
   for(int g = 0; g < 10 ; g++){
    lglist.add(new SimUnit("V3Radiator"));//V3Radiator 객체를 추가한다
}
}
}

class RetentionBot{
  RetentionBot(ArrayList<SimUnit> rlist){
   rlist.add(new SimUnit("Rention")); // Rention 객체 추가한다.
}
}

public class TestLifeSupportSim{
  public static void main(String[] args){
   ArrayList<SimUnit> aList = new ArrayList<SimUnit>();
   V2Radiator v2 = new V2Radiator(aList);
   V3Radiator v3 = new V3Radiator(aList);
   for(int z = 0 ; z < 20 ; z++){
     RetentionBot ret = new RetentionBot(aList);
}
}
}

class SimUnit {
  String botType;
  SimUnit(String type){
   botType = type;
}

  int powerUse(){
   if("Retention".equals(botType)){
     return 2;
} else {
     return 4;
}
}
}

```

# 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계 #

**307p~ 숫자** _요약_

  * 정적 메소드: 클래스의 인스턴스 없이 메소드를 실행 할 수 있도록 한 메소드
  * 정적 메소드를 선언하는 방법: 메소드 앞에 static을 붙인다
  * static final: static final로 선언된 변수는 상수이다.
  * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스이다.
  * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능이다
  * 정적 임포트: 타이핑을 전부 할 필요 없이 코드를 짧게 작성할 수 있도록 도와주는 기능. 정적 클래스나 정적변수 등을 사용할 때 활용한다.

**339p Calendar** _구현후 주석달기_

```
import java.util.*;
public class Calendarrrr {
  public static void main(String args[]){
   Calendar c=Calendar.getInstance();
   
     c.set(2011, 11,10, 00, 40); // 시작을 2011년 12월 10일 00:40으로 설정
      long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴
     day1 += 1000*60*60;
     c.setTimeInMillis(day1); // 한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신
     System.out.println("new hour"+c.get(Calendar.HOUR_OF_DAY));
     c.add(Calendar.DATE, 35); // 35일을 더합니다.
     System.out.println("add 35 days"+c.getTime());
     c.roll(Calendar.DATE, 35); // 35일 뒤로 넘깁니다. 달은 바뀌지 않습니다.
     System.out.println("roll 35 days"+c.getTime());
     c.set(Calendar.DATE,1); // 날짜를 1로 설정합니다. 
     System.out.println("set to 1"+c.getTime());       
}}

```

**342p 집중토론** _요약_

  * 인스턴스 변수: 정적 변수는 객체지향적이기 보다 프로시저 위주의 프로그래밍에서 사용한 비효율적인 변수다. 전역변수랑 비슷하다.
  * 정적 변수: API에 정적변수가 많다. 객체의 자연적인 상태의 한 부분이다. 시스템에서 필수적인 것도 있다. 필수적이라고 할 수 없는 것들도 분명히 유용하게 쓰인다.

**344p 컴파일러가 되어봅시다** _구현후 주석달기_

```
class StaticSuper {
   static { // 초기화
     System.out.println("super static block");
}
   StaticSuper() { // 생성자 메소드에 ()를 붙여준다
     System.out.println("super constructor");
}
}

public class StaticTests extends StaticSuper { 
   static int rand;
   static { // 초기화
     rand = (int) (Math.random() * 6);
     System.out.println("static block " + rand);
}

StaticTests() {
   System.out.println("constructor");
}

public static void main(String[] args) {
   System.out.println("in main");
   StaticTests st = new StaticTests();
}
}

```

# 11. 위험한 행동:예외처리 #

**357p try/catch** _구현후 주석달기_

```

public class Test {
  public static void main(String[] args) {	
    public void takeRisk() throws BadException {
     if (abandonAllHope) {
      throw new BadException();
     }
   }
		
    public void crossFingers() {
     try {
          anObject.takeRisk(); // 오류의 가능성이 있는 행동
      } catch (BadException ex) {
       System.out.println("Aaargh!");//예외 상황을 발생시키고 출력      ex.printStackTrance();
     }
    }
  }
}

```

**376p~ 첫번째 사운드 애플리케이션** _구현후 주석달기_

```
import javax.sound.midi.*;

public class MiniMiniMusicApp {
public static void main(String[] args) {
MiniMiniMusicApp mini = new MiniMiniMusicApp();
mini.play();
} // main 메소드 끝
		
public void play() {
try {
Sequencer player = MidiSystem.getSequencer(); // 시퀀서를 받아서 엽니다.
player.open();
Sequence seq = new Sequence(Sequence.PPQ, 4);
Track track = seq.createTrack(); // 시퀀서에 트랙을 요청
				
ShortMessage a = new ShortMessage(); 
a.setMessage(144, 1, 44, 100);
MidiEvent noteOn = new MidiEvent(a, 1);
track.add(noteOn);
				
ShortMessage b = new ShortMessage();
b.setMessage(128, 1, 44, 100);
MidiEvent noteOff = new MidiEvent(b, 16);
track.add(noteOff);
				
player.setSequence(seq); // 시퀀서에 시퀀스를 보냅니다.
				
player.start(); 
}catch (Exception ex) {ex.printStackTrace();}

		} // play 메소드 끝
} // 클래스 

```

**380p~ 두번째 사운드 애플리케이션** _구현후 주석달기_

```
import javax.sound.midi.*;

public class MiniMusicCmdLine {

public static void main(String[] args) {
MiniMusicCmdLine mini = new MiniMusicCmdLine
if (args.length < 2) {
System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
} else {
int instrument = Integer.parseInt(args[0]); // 악기선택
int note = Integer.parseInt(args[1]); // 음 높이선택
mini.play(instrument, note); // 실행
}
} // main 끝
		
public void play(int instrument, int note) {
			
try {
sequencer player = MidiSystem.getSequencer(); // 시퀀서를 받아서 엽니다.
player.open();
Sequence seq = new Sequence(Sequence.PPQ, 4);
Track track = seq.createTrack(); // 시퀀서에 트랙을 요청
MidiEvent event = null; // 무엇을 할지,  언제 할지 결정함.
				
ShortMessage first = new ShortMessage();
first.setMessage(192, 1, instrument, 0);
MidiEvent changeInstrument = new MidiEvent(first,1);
track.add(changeInstrument);
				
// 트랙에 미디이벤트를 집어넣습니다.
ShortMessage a = new ShortMessage(); 
a.setMessage(144, 1, 44, 100);
MidiEvent noteOn = new MidiEvent(a, 1);
track.add(noteOn);
				
ShortMessage b = new ShortMessage();
b.setMessage(128, 1, 44, 100);
MidiEvent noteOff = new MidiEvent(b, 16);
track.add(noteOff);
player.setSequence(seq); // 시퀀서에 시퀀스를 보냅니다.
player.start(); // CD의 재생 버튼을 누르는 것과 비슷!
			
} catch (Exception ex) {ex.printStackTrace();}

} // play 메소드 끝
} // 클래스
```

# 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개 #

```

import javax.swing.*;

public class SimpleGui1{
        public static void main(String []args){
                JFrame frame = new JFrame(); // JFrame 생성
                JButton button = new JButton("click me");  //JButton 생성

                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // X버튼을 누르면 창이 종료된다.
                frame.getContentPane().add(button); // 버튼을 추가

                frame.setSize(300,300); // 프레임의 크기설정

                frame.setVisible(true); // 프레임이 보이게된다.
        }
}


```

**394p~ ActionEvent** _구현후 주석달기_

```

import javax.swing.*;
import java.awt.event.*; // Actionlistener와 이벤트가 들어있는 패키지를 사용

public class SimpleGui1B implements ActionListener {
        JButton button; // 버튼을 생성합니다. 

        public static void main(String []args){
                SimpleGui1B gui=new SimpleGui1B();
                gui.go();

        }

        public void go(){
                JFrame frame= new JFrame();//JFrame생성
                button=new JButton("cliick me"); // JButton생성

                button.addActionListener(this); // 버튼에 ActionListener추가

                frame.getContentPane().add(button);//프레임에 버튼추가
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);// x누르면 꺼지게 함
                frame.setSize(300,300);//프레임크기설정
                frame.setVisible(true);//프레임이 보이게함
        }
        public void actionPerformed(ActionEvent event){ // 버튼에 action이 실행될때 실행되는 메소드
                button.setText("I've been clicked!");
        }
}


```

**405p 버튼과 원의색** _구현후 주석달기_

```


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {
        
        JFrame frame;
        
        public static void main(String[] args) {
                SimpleGui3C gui = new SimpleGui3C();
                gui.go();//go 메소드 호출
        }

        public void go() {
                frame = new JFrame();//JFrame 생성
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//X버튼 누르면 종료
                
                JButton button = new JButton("Change colors");//JButton 생성
                button.addActionListener(this);//버튼에 ActionListener를 추가
                
                MyDrawPanel drawPanel = new MyDrawPanel();//JPanel 생성
                
                frame.getContentPane().add(BorderLayout.SOUTH,button);//버튼을 추가
                frame.getContentPane().add(BorderLayout.CENTER,drawPanel);//프레임에 패널을 추가
                frame.setSize(300,300);//프레임 크기 설정
                frame.setVisible(true);//프레임이 보이게함
        }
        public void actionPerformed(ActionEvent event) {// 액션이 일어나면 실행되는코드
                frame.repaint();
        }
}

class MyDrawPanel extends JPanel
{
        public void paintComponent(Graphics g)
        {
                Graphics2D g2d = (Graphics2D) g;
                
                int red = (int) (Math.random() * 256);
                int green = (int) (Math.random() * 256);
                int blue = (int) (Math.random() * 256);
                //RGB값 설정
                
                Color startColor = new Color(red,green,blue);//시작 컬러설정
                
                red = (int) (Math.random() * 256);
                green = (int) (Math.random() * 256);
                blue = (int) (Math.random() * 256);
                //RGB값 설정
                
                Color endColor = new Color(red,green,blue);//마지막 컬러
                
                GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
                g2d.setPaint(gradient);
                g2d.fillOval(70,70,100,100);
        }
}


```

**413p 두개의 버튼과 원의색** _구현후 주석달기_

```


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButtons {

        JFrame frame; 
        JLabel label; 

        public static void main(String args[]){
                TwoButtons gui = new TwoButtons();
                gui.go();
        }

        public void go(){
                frame=new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);


                JButton labelButton = new JButton ("Change Label");//JButton생성
         
                labelButton.addActionListener(new LabelListener());//버튼에 ActionListener추가

                JButton colorButton = new JButton ("Change Circle");//JButton생성
              
                colorButton.addActionListener(new ColorListener());//버튼에 ActionListener추가

                label = new JLabel("I'm a lebel");//JLabel생성
                MyDrawPanel drawPanel = new MyDrawPanel();

                // 프레임에 버튼,패널,레이블을 추가
                frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
                frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
                frame.getContentPane().add(BorderLayout.EAST, labelButton);
                frame.getContentPane().add(BorderLayout.WEST, label);

                frame.setSize(300,300);//프레임크기설정
                frame.setVisible(true);//프레임이 보이게함
        }

        class LabelListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        label.setText("Ouch!"); 
                }
        } 

        class ColorListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        frame.repaint(); 
                }
        } 
}


```

**418p 간단한 애니메이션** _구현후 주석달기_

```

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation 
{

        int x=70;
        int y=70;    
        public static void main(String args[]){
                SimpleAnimation gui=new SimpleAnimation();
                gui.go();
        }
        
        public void go()
        {
                JFrame frame=new JFrame();//JFrame생성
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//x를 누르면 꺼짐

                MyDrawPanel drawPanel = new MyDrawPanel();

                frame.getContentPane().add(drawPanel);//프레임에 패널추가
                frame.setSize(300,300);//프레임크기설정
                frame.setVisible(true);//프레임이보이게함

                for(int i=0;i<300;i++){ // 반복

                        x++;
                        y++;
                        
                        drawPanel.repaint(); 

                        try{
                                Thread.sleep(50); 
                        }catch(Exception ex)
                         {

                          }
                }

        } 

       
         class MyDrawPanel extends JPanel
        {
                public void paintComponent(Graphics g)
                {
                        g.setColor(Color.white);
                        g.fillRect(0,0,this.getWidth(),this.getHeight());//하얀색으로 색칠함

                        g.setColor(Color.green);
                        g.fillOval(x, y, 40, 40); //초록색으로 색칠

                }
        } 
} 


```

**420p 뮤직 비디오** _구현후 주석달기_

```


import javax.sound.midi.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 
{

        static JFrame f = new JFrame("My First Music Video");//JFrame 생성
        static MyDrawPanel m1;

        public static void main(String [] args)
        {
                MiniMusicPlayer3 mini = new MiniMusicPlayer3();
                mini.go();
        }

        public void setUpGui()
        {
                m1 = new MyDrawPanel();//패널 생성
                f.setContentPane(m1);//프레임에 패널추가
                f.setBounds(30, 30, 300, 300);//프레임 크기설정
                f.setVisible(true);//프레임이 보이게한다
        }

        public void go()
        {
                setUpGui();//gui기본설정
          
                try{//음악틀기

                        Sequencer sequencer = MidiSystem.getSequencer();
                        sequencer.open();
                        sequencer.addControllerEventListener(m1, new int[] {127});
                        Sequence seq = new Sequence(Sequence.PPQ, 4);
                        Track track = seq.createTrack();

                        int r = 0; 
                        for(int i = 0; i < 60 ; i+=4)
                        {

                                r=(int)((Math.random()*50)+1);
                                track.add(makeEvent(144,1,r,100,i));
                                track.add(makeEvent(176,1,127,0,i));
                                track.add(makeEvent(128,1,r,100,i+2));
                        }

                        sequencer.setSequence(seq);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                } 
                
                catch(Exception ex) 
                {
                        ex.printStackTrace();
                }
        }

        public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick)
        {
                MidiEvent event = null;
               
                try{
                        ShortMessage a = new ShortMessage();
                        a. setMessage(comd,chan,one,two);
                        event = new MidiEvent(a, tick);
                }
                catch(Exception e)
                {
                        
                }
                
                return event;

        }

    
        class MyDrawPanel extends JPanel implements ControllerEventListener
        {
                boolean msg = false;

                public void controlChange(ShortMessage event)
                {
                        msg = true;
                        repaint();//색 설정
                }

                public void paintComponent(Graphics g)
                {
                        if(msg)
                        {

                                @SuppressWarnings("unused")
                                                                Graphics2D g2= (Graphics2D)g;

                                int r = (int) (Math.random()*250);
                                int gr=(int) (Math.random()*250);
                                int b= (int ) (Math.random()*250);

                                g.setColor(new Color(r,gr,b));

                                int ht=(int) ((Math.random()*120)+10);
                                int width=(int) ((Math.random()*120)+10);

                                int x=(int) ((Math.random()*40)+10);
                                int y=(int) ((Math.random()*40)+10);

                                g.fillRect(x, y, ht, width);
                                msg = false;
                        }
                }
        }
}

```

# 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소 #

**452p 비트박스 프로그램** _구현후 주석달기_

```
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox{
 JPanel mainPanel;
 ArrayList<JCheckBox> checkboxList;// 체크상자를 ArrayList에 저장합니다.
 Sequencer sequencer;
 Sequence sequence;
 Track track;
 JFrame theFrame;//GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
 String[] instrumentNames ={"Bass Drum","Closed Hi-Hat","Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap","High Tom","Hi Bongo","Maracas","Whistle","Low Conga","Cowbell","Vibraslap","Low-mid Tom","High Agogo","Open Hi Conga"};// 실제 드럼 '건반'을 나타냅니다. 드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다.
// 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다.
 int[] instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
 public static void main(String[] args){
 new BeatBox().buildGUI();
}
 public void buildGUI(){
  theFrame =new JFrame("Cyber BeatBox");
  theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  BorderLayout layout =newBorderLayout();
  JPanel background =newJPanel(layout);// 비어있는 경계선(empty border)을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈공간을 만들 수 있습니다.
  background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  
  checkboxList =new ArrayList<JCheckBox>();
  Box buttonBox =new Box(BoxLayout.Y_AXIS);
  
  JButton start =newJButton("Start");
  start.addActionListener(newMyStartListener());
  buttonBox.add(start);

  JButton stop =newJButton("Stop");
  stop.addActionListener (newMyStopListener());
  buttonBox.add(stop);

  JButton upTempo =newJButton("upTempo");
  upTempo.addActionListener(newMyUpTempoListener());
  buttonBox.add(upTempo,"upTempo");

  JButton downTempo =newJButton("Tempo Down");
  downTempo.addActionListener(newMyDownTempoListener());
  buttonBox.add(downTempo,"downTempo");

  Box nameBox =newBox(BoxLayout.Y_AXIS);
  for(int i=0; i<16; i++){
    nameBox.add(newLabel(instrumentNames[i]));
  }

  background.add(BorderLayout.EAST, buttonBox);
  background.add(BorderLayout.WEST, nameBox);

  theFrame.getContentPane().add(background);

  GridLayout grid =new GridLayout(16,16);//그리드레이아웃을 생성합니다.
  grid.setVgap(1);
  grid.setHgap(2);
  mainPanel =new JPanel(grid);
  background.add(BorderLayout.CENTER,mainPanel);

  for(int i=0;i<256;i++){
    JCheckBox c =newJCheckBox();
    c.setSelected(false);
    checkboxList.add(c);
    mainPanel.add(c);
  }//순환문 끝

   setUpMidi();

   theFrame.setBounds(50,50,300,300);
   theFrame.pack();
   theFrame.setVisible(true);
}// buildGUI 메소드 끝
// 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드

public void setUpMidi(){
  try{
    sequencer=MidiSystem. getSequencer();
    sequencer.open();
    sequence =newSequence(Sequence.PPQ,4);
    track = sequence.createTrack();
    sequencer.setTempoInBPM(120);
  } catch(Exception e){e.printStackTrace();}
}//setUpMidi 메소드 끝 
// 체크상자의 상태를 MIDI이벤트로 바꾼 다음 이벤트를 트랙에 추가합니다.

public void buildTrackAndStart(){
   int[] trackList =null;// 각 악기의 열여섯 박자에 대한 값을 원소가 16개인
// 배열에 저장합니다. 어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를 넣습니다. 반대로 연주되어야 하지 않는다면 0을 집어넣습니다.
   sequence.deleteTrack(track); // 기존 트랙을 제거하고 트랙을 새로 만듭니다.
   track = sequence.createTrack();

//열 16개 모두에 대해 같은 작업을 처리합니다.
   for(int i =0; i<16; i++){
     trackList =newint[16];

     int key = instruments[i];// 어떤 악기인지 정하는 번호를 설정합니다.
     
     for(int j =0; j<16; j ++)// 모든 박자에 대해 같은 작업을 반복합니다.{
        JCheckBox jc = checkboxList.get(j +(16*i));
        if(jc.isSelected()){
           trackList[j]= key;
        }else{
          trackList[j]=0;
        }
     }//안쪽 for문 끝


       makeTracks(trackList);
      track.add(makeEvent(176,1,127,0,16));
}// 바깥쪽 for문 끝

track.add(makeEvent(192,9,1,0,15));
try{

   sequencer.setSequence(sequence);
    sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
    sequencer.start();
    sequencer.setTempoInBPM(120);
} catch(Exception e){e.printStackTrace();}
}// buildTrackAndStart 메소드 끝        

public class MyStartListener implements ActionListener{
 public void actionPerformed(ActionEvent a){
   buildTrackAndStart();
 }
}// 내부 클래스 끝

public class MyStopListener implements ActionListener{
 publicvoid actionPerformed(ActionEvent a){
   sequencer.stop();
 }
}// 내부 클래스 끝 

public class MyUpTempoListener implements ActionListener{
 publicvoid actionPerformed(ActionEvent a){
  float tempoFactor = sequencer.getTempoFactor();
  sequencer.setTempoFactor((float)(tempoFactor * 1.03));
 }
}// 내부 클래스 끝

public class MyDownTempoListener implements ActionListener{
 public void actionPerformed(ActionEvent a){
  float tempoFactor = sequencer.getTempoFactor();
  sequencer.setTempoFactor((float)(tempoFactor*.97));
 }
}// 내부 클래스 끝

public void makeTracks(int[] list){ //한 악기의 16박자 전체에 대해 이벤트를 만듭니다. int[]배열에는 그 악기에 해당하는 건반 번호 또는 0이 들어갑니다. 0이 들어있다면 그 박자에서는 해당 악기가 연주되지 않아야 합니다. 0이 아닌 값이 들어 있다면 이벤트를 만들어서 트랙에 추가합니다.
  for(int i=0;i<16;i++){
    int key = list[i];
    
    if(key!=0){
// Note on과 note off 이벤트를 만들고 트랙에 추가합니다.
      track.add(makeEvent(144,9,key,100,i));
      track.add(makeEvent(128,9,key,100,i+1));
    }
   }
}

public MidiEvent makeEvent(int comd,int chan ,int one,int two,int tick){
   MidiEventevent=null;
   try{
      ShortMessage a =newShortMessage();
      a.setMessage(comd,chan,one,two);
      event = newMidiEvent( a, tick);
   } catch(Exception e){e.printStackTrace();}
   returnevent;
   }
}//클래스 끝

```

# 14. 객체 저장:직렬화와 입출력 #

**496p 비트박스 프로그램** _구현후 주석달기_

```
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;


public class BeatBox{
 JPanel mainPanel;
 ArrayList<JCheckBox> checkboxList;// 체크상자를 ArrayList에 저장합니다.
 Sequencer sequencer;
 Sequence sequence;
 Track track;
 JFrame theFrame;//GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
 String[] instrumentNames ={"Bass Drum","Closed Hi-Hat","Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap","High Tom","Hi Bongo","Maracas","Whistle","Low Conga","Cowbell","Vibraslap","Low-mid Tom","High Agogo","Open Hi Conga"};// 실제 드럼 '건반'을 나타냅니다. 드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다.
// 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다.
 int[] instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
 public static void main(String[] args){
 new BeatBox().buildGUI();
}
 public void buildGUI(){
  theFrame =new JFrame("Cyber BeatBox");
  theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  BorderLayout layout =newBorderLayout();
  JPanel background =newJPanel(layout);// 비어있는 경계선(empty border)을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈공간을 만들 수 있습니다.
  background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  
  checkboxList =new ArrayList<JCheckBox>();
  Box buttonBox =new Box(BoxLayout.Y_AXIS);
  
  JButton start =newJButton("Start");
  start.addActionListener(newMyStartListener());
  buttonBox.add(start);

  JButton stop =newJButton("Stop");
  stop.addActionListener (newMyStopListener());
  buttonBox.add(stop);

  JButton upTempo =newJButton("upTempo");
  upTempo.addActionListener(newMyUpTempoListener());
  buttonBox.add(upTempo,"upTempo");

  JButton downTempo =newJButton("Tempo Down");
  downTempo.addActionListener(newMyDownTempoListener());
  buttonBox.add(downTempo,"downTempo");

  Box nameBox =newBox(BoxLayout.Y_AXIS);
  for(int i=0; i<16; i++){
    nameBox.add(newLabel(instrumentNames[i]));
  }

  background.add(BorderLayout.EAST, buttonBox);
  background.add(BorderLayout.WEST, nameBox);

  theFrame.getContentPane().add(background);

  GridLayout grid =new GridLayout(16,16);//그리드레이아웃을 생성합니다.
  grid.setVgap(1);
  grid.setHgap(2);
  mainPanel =new JPanel(grid);
  background.add(BorderLayout.CENTER,mainPanel);

  for(int i=0;i<256;i++){
    JCheckBox c =newJCheckBox();
    c.setSelected(false);
    checkboxList.add(c);
    mainPanel.add(c);
  }//순환문 끝

   setUpMidi();

   theFrame.setBounds(50,50,300,300);
   theFrame.pack();
   theFrame.setVisible(true);
}// buildGUI 메소드 끝
// 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드

public void setUpMidi(){
  try{
    sequencer=MidiSystem. getSequencer();
    sequencer.open();
    sequence =newSequence(Sequence.PPQ,4);
    track = sequence.createTrack();
    sequencer.setTempoInBPM(120);
  } catch(Exception e){e.printStackTrace();}
}//setUpMidi 메소드 끝 
// 체크상자의 상태를 MIDI이벤트로 바꾼 다음 이벤트를 트랙에 추가합니다.

public void buildTrackAndStart(){
   int[] trackList =null;// 각 악기의 열여섯 박자에 대한 값을 원소가 16개인
// 배열에 저장합니다. 어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를 넣습니다. 반대로 연주되어야 하지 않는다면 0을 집어넣습니다.
   sequence.deleteTrack(track); // 기존 트랙을 제거하고 트랙을 새로 만듭니다.
   track = sequence.createTrack();

//열 16개 모두에 대해 같은 작업을 처리합니다.
   for(int i =0; i<16; i++){
     trackList =newint[16];

     int key = instruments[i];// 어떤 악기인지 정하는 번호를 설정합니다.
     
     for(int j =0; j<16; j ++)// 모든 박자에 대해 같은 작업을 반복합니다.{
        JCheckBox jc = checkboxList.get(j +(16*i));
        if(jc.isSelected()){
           trackList[j]= key;
        }else{
          trackList[j]=0;
        }
     }//안쪽 for문 끝


       makeTracks(trackList);
      track.add(makeEvent(176,1,127,0,16));
}// 바깥쪽 for문 끝

track.add(makeEvent(192,9,1,0,15));
try{

   sequencer.setSequence(sequence);
    sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
    sequencer.start();
    sequencer.setTempoInBPM(120);
} catch(Exception e){e.printStackTrace();}
}// buildTrackAndStart 메소드 끝        

public class MyStartListener implements ActionListener{
 public void actionPerformed(ActionEvent a){
   buildTrackAndStart();
 }
}// 내부 클래스 끝

public class MyStopListener implements ActionListener{
 publicvoid actionPerformed(ActionEvent a){
   sequencer.stop();
 }
}// 내부 클래스 끝 

public class MyUpTempoListener implements ActionListener{
 publicvoid actionPerformed(ActionEvent a){
  float tempoFactor = sequencer.getTempoFactor();
  sequencer.setTempoFactor((float)(tempoFactor * 1.03));
 }
}// 내부 클래스 끝

public class MyDownTempoListener implements ActionListener{
 public void actionPerformed(ActionEvent a){
  float tempoFactor = sequencer.getTempoFactor();
  sequencer.setTempoFactor((float)(tempoFactor*.97));
 }
}// 내부 클래스 끝

public class MySendListener implements ActionListener {
 public void actionPerformed(ActionEvent a) { // 사용자가 버튼을 클릭해서 ActionEvent가 발생된 경우에 실행.  
  boolean[] checkboxState = new boolean[256]; // 체크박스
     for (int i = 0; i < 256; i++) {
       JCheckBox check = (JCheckBox) checkboxList.get(i); // chechboclist를 훑어보면서 체크박스의 상태 확인후 그 결과를 부울 배열에 추가               
       if (check.isSelected()) {
         checkboxState[i] = true;
       }
    }
     try{
         FileOutputStream fileStream = new FileOutputStream(new File("Checkbox.ser"));
         ObjectOutputStream os = new ObjectOutputStream(fileStream);
         os.writeObject(checkboxState);
         } catch(Exception ex) {
              ex.printStackTrace();
         }

       } // 메소드 끝
       } // 내부 클래스 끝

public class MyReadInListener implements ActionListener { 
 public void actionPerformed(ActionEvent a) {
  boolean[] checkboxState = null;
  try {
       FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
       ObjectInputStream is = new ObjectInputStream(fileIn);
       checkboxState = (boolean[]) is.readObject(); // 파일에서 객체 하나를 읽은 다음 부울 배열로 다시 캐스트
       } catch(Exception ex) {ex.printStackTrace();}
           for (int i = 0; i < 256; i++) {
             JCheckBox check = (JCheckBox) checkboxList.get(i);
             if (checkboxState[i]) {
                 check.setSelected(true);
               } else {
                 check.setSelected(false);
               }
           } 
          sequencer.stop(); 
          buildTrackAndStart();
       } // 메소드 끝
    } // 클래스 끝

public void makeTracks(int[] list){ //한 악기의 16박자 전체에 대해 이벤트를 만듭니다. int[]배열에는 그 악기에 해당하는 건반 번호 또는 0이 들어갑니다. 0이 들어있다면 그 박자에서는 해당 악기가 연주되지 않아야 합니다. 0이 아닌 값이 들어 있다면 이벤트를 만들어서 트랙에 추가합니다.
  for(int i=0;i<16;i++){
    int key = list[i];
    
    if(key!=0){
// Note on과 note off 이벤트를 만들고 트랙에 추가합니다.
      track.add(makeEvent(144,9,key,100,i));
      track.add(makeEvent(128,9,key,100,i+1));
    }
   }
}

public MidiEvent makeEvent(int comd,int chan ,int one,int two,int tick){
   MidiEventevent=null;
   try{
      ShortMessage a =newShortMessage();
      a.setMessage(comd,chan,one,two);
      event = newMidiEvent( a, tick);
   } catch(Exception e){e.printStackTrace();}
   returnevent;
   }
}//클래스 끝

```