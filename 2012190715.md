

# 01. 껍질을 깨고:간단한 소개 #

**48p BeerSong** _문제해결하기, 주석달기_
```
public class BeerSong {
public static void main (String args) {
int beerNum = 99; String word = "bottles"; //복수형

while (beerNum > 0) {

if (beerNum == 1) { word = "bottle"; //단수형 (한 병인 경우) }

System.out.println(beerNum + " " + word + " of beer on the wall"); System.out.println(beerNum + " " + word + " of beer.");
System.out.println("Take one down.");
System.out.println("Pass it around.");
beerNum = beerNum - 1;

if(beerNum > 0) {
System.out.println(beerNum + " " + word + " of beer on the wall"); }
else { System.out.println("No more bottles of beer on the wall"); } 
//else 문 끝 
} //while 순환문 끝
 } //main 클래스 끝
 } //클래스 끝
```

**50p PhraseOMatic** _wordListOne, wordListTwo, wordListThree를 변경_
```
public class PhraseOMatic {
public static void main (String[] args) {

// 세 종류의 단어 목록을 만든다. 
String [] wordListOne = {"4/21","young-tigers","20,000 people"};
String [] wordListTwo = {"strong","focus-on","sharing"};
String [] wordListThree = {"tip-toe","firefighter","cold-war"};

//각 단어 목록에 단어가 몇 개씩 들어있는지 확인한다.
int oneLength = wordListOne.length;
int twoLength = wordListTwo.length;
int threeLength = wordListThree.length;

//난수 세개 발생시킨다
int rand1 = (int) (Math.random()*oneLength);
int rand2 = (int) (Math.random()*twoLength);
int rand3 = (int) (Math.random()*threeLength);

//구문 만들기
String phrase = wordListOne[rand1] + " " +
wordListTwo[rand2] + " " + wordListThree[rand3];

//구문을 출력한다
System.out.println("What we need is a " + phrase);
}

```

**52p 집중토론** _요약_

  * 자바 가상 머신: 컴파일러가 파일을 주면 자바 가상머신이 그 프로그램을 실행시켜준다.
  * 컴파일러: 자바에서 바이트코드 컴파일러를 사용하여 파일을 자바 가상머신에게 준다.

**55p 컴파일러가 되어봅시다** _구현후 주석달기_
```
A. 
class Exercise1b {
public static void main(String [] args) {
int x = 1;
while (x<10){
x=x+1; // x=x+1 처럼 한 행을 추가하지 않으면 while순환문이 끊임없이 계속 돌아가는 무한 순환문이 된다.
if(x>3) {
System.out.println("big x");
}
}
}
}

B.
class HJ{ // 클래스를 정의해주어야 컴파일 가능하다. 또한 클래스의 시작과 끝을 나타내는 중괄호도 잊지 말아야 한다.
public static void main(String [] args){
int x = 5;
while (x>1) {
x = x-1;
if(x<3) {
System.out.println("small x");
}
}
}
}

C.
class Exercise1b{
public static void main(String [] args) { // while순환문 코드는 반드시 클래스 안의 메소드 안에 있어야 한다. 클래스만 있어도 안되고 반드시 그 안에 메소드가 있어야 한다.
int x = 5;
while (x>1) {
x = x-1;
if(x<3) {
System.out.println("small x");
}
}
}
}

```
# 02. 객체마을로의 여행:객체에 대해 알아봅시다 #

**68p~ 클래스** _요약_

  * 인스턴스 변수: 객체의 상태(데이터)를 나타낸다. 객체에서 자신에 대해 "아는 것"
  * 메소드:객체에서 할 수 있는 일, 객체에서 자신이 하는 것 "행동"
  * 클래스:클래스는 객체가 아니다. 객체를 만들기 위한 용도, 청사진! 이다. 가상 머신에 그 유형의 객체를 만드는 방법을 알려주는 역할을 한다.
  * 테스트용 클래스:클래스에는 진짜 클래스(실제로 사용할 객체의 유형을 나타내는 클래스)고 <클래스명>TestDrive와 같은 식으로 이름이 붙는 테스트용 클래스가 있다. 테스트용클래스에서 객체를 만들고 그 객체의 변수와 메소드에 접근한다.


**68p Television** _채워넣기_

  * 인스턴스 변수:modelname, inch
  * 메소드:channel(),volume()


**72p GuessGame** _게임에 참여하는 사람 수를 4명으로 변경_
```
> GuessGame.java

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
//GuessGame 에는 Player 객체 네개를 저장하기 위한 인스턴트 변수 네개있다.

	public void startGame() {
	p1 = new Player();
	p2 = new Player();
	p3 = new Player();
	p4 = new Player();

	int guessp1 = 0;
	int guessp2 = 0;
	int guessp3 = 0;
	int guessp4 = 0;

	boolean p1isRight = false;
	boolean p2isRight = false;
	boolean p3isRight = false;
	boolean p4isRight = false;

	int targetNumber = (int) (Math.random()*10);
	System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
	
	while(true) {
	 System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

	p1.guess();
	p2.guess();
	p3.guess();
	p4.guess();

	guessp1 = p1.number;
	System.out.println("1번 선수가 찍은 숫자: " + guessp1);

	guessp2 = p2.number;
	System.out.println("2번 선수가 찍은 숫자: " + guessp2);

	guessp3 = p3.number;
	System.out.println("3번 선수가 찍은 숫자: " + guessp3);

	guessp4 = p4.number;
	System.out.println("4번 선수가 찍은 숫자: " + guessp4);

	if(guessp1 == targetNumber) {
	 p1isRight = true;
	}

	if(guessp2 == targetNumber) {
	 p2isRight = true;
	}

	if(guessp3 == targetNumber) {
	 p3isRight = true;
	}

	if(guessp4 == targetNumber) {
	 p4isRight = true;
	}

	if(p1isRight || p2isRight || p3isRight || p4isRight) {

	 System.out.println("맞춘 선수가 있습니다.");
	 System.out.println("1번 선수: " + p1isRight);
	 System.out.println("2번 선수: " + p2isRight);
	 System.out.println("3번 선수: " + p3isRight);
	 System.out.println("4번 선수: " + p4isRight);
	 System.out.println("게임 끝.");
	 break; //게임이 끝났으므로 break문으로 순환문 빠져나간다.

	} else {
	//아직 아무도 못 맞췄기 떼문에 계속해야 합니다.
	System.out.println("다시 시도해야 합니다.");
	}
      }
   }
}  

> Player.java

	public class Player {
	 int number = 0;

	public void guess() {
	 number = (int) (Math.random() * 10);
	 System.out.println("찍은 숫자: " + number);
	}
      }

>GameLauncher.java
	public class GameLauncher {
	 public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
     } 

```
**76p 컴파일러가 되어봅시다** _구현후 주석달기_
```
A :
public class TapeDeck 
{

        boolean canRecord = false; //canRecord = false로 세팅
        
        void playTape()//playTape 메소드 생성
        {
                System.out.println("tape playing");             
        }
        
        void recordTape()//recordTape 메소드 생성
        {
                System.out.println("tape recording");
                
        }       

}

public class TapeDeckTestDrive 
{
        public static void main(String[] args) 
        {
                TapeDeck t = new TapeDeck();
                //TapeDeck 타입의 변수 객체t를 만들어줍니다
                t.canRecord = true;//t의 canRecord를 true로
                t.playTape();//t의 playTape메소드 실행
                
                if(t.canRecord == true)
                {
                        t.recordTape();
                }
        }
}

B:

public class DVDPlayer
{
        boolean canRecord = false;//canRecord = false로 세팅
        
        void recordDVD()//recordDVD메소드 생성
        {
                System.out.println("DVD recording");
                
        }
        void playDVD()//playDVD메소드 생성
        {
                System.out.println("DVD Playing");
        }
        //playDVD method 를 만들가
}

public class DVDPlayerTestDrive 
{
        public static void main(String[] args) {
                
                DVDPlayer d = new DVDPlayer();//DVDPlayer형의 새로운 객체 생성
                d.canRecord = true;//d의 canRecord에 true를 넣기
                d.playDVD();
                
                if(d.canRecord == true)
                {
                        d.recordDVD();
                }
        }
}
```

# 03. 네 변수를알라:원시 변수와 레퍼런스 #

**83p~ 변수** _요약_

  * 원시변수 vs 레퍼런스변수:
변수는 크게 원시변수(primitive variable)와 레퍼런스(objectreference)로 나눌 수 있다.
> 원시변수에는 정수,부울,부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이 들어간다.
그리고 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.

**96p Dog** _수많은 개를 만들어 난장판 만들기_

```
class Dog {
	String name;
	public static void main (String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[3];
		//그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		// 배열 레퍼런스를 써서 Dog객체에 접근합니다.
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";
		// myDogs[2]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[2].name);
		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
	
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat() {}
	public void chaseCat() {}
}
```

**97p 컴파일러가 되어봅시다** _구현후 주석달기_

```
A. 
class Books {
	String title;
	String author;
}

class BooksTestDrive {
	public static void main(String [] args) {
		
		Books [] myBooks = new Books[3];
		int x = 0;
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); // myBooks 의 객체를 만든다
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook"; // 책의 제목
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian"; // 책의 저자
		while(x<3) { // x가 3이 될때까지 책 세권의  제목과 저자를 나타내준다.
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}

B.
class Hobbits {
	String name;
	public static void main(String [] args) {
		Hobbits [] h = new Hobbits[3];
			int z = -1; // 배열의 인덱스는 0에서 시작해야한다.
			while (z<2) {
				z = z + 1; // z가 0부터 시작한다.
				h[z] = new Hobbits();
				h[z].name = "bilbo";
				if(z==1) { // z = 1 일때의 이름
						h[z].name = "frodo";
				}
				if (z==2) { // z = 2 일때의 이름 그리고 out
					h[z].name = "sam";
				}
				System.out.print(h[z].name + " is a ");
				System.out.println("good Hobbit name"); //출력
			}
	}
}



```

**101p 레퍼런스 도용사건** _요약_

  * 누가 이겼나요?: 밥이 이겼다.
  * 문제가 된 부분은 어딘가요?:
켄트의 메소드에서 사용한 레퍼런스 변수의 개수는 밥의 메소드에 비해 작았지만,
그의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수 없다는 문제가 있었다.
순환문을 한 바퀴 돌 때마다 그는 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버림받게 된것이다.
즉, 그 객체는 다시는 사용할 수 없었다.
따라서 기껏 객체 10개를 만들고는 하나에만 접근 할 수 있는 켄트의 메소드는 아무 쓸모가 없었다. 그래서 밥이 밥을 먹게 되었다.

# 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향 #

**105p~ 객체** _요약_
  * 캡슐화: 캡슐화(Encapsulation) 는 매우 중요하다. 캡슐화를 해놓지 않으면 아무나 데이터에 접근할 수 있다. 예를들어 레퍼런스 변수를 통해 접근 할 수 있다. 따라서 모든 인스턴스 변수에 대해 세터 메소드를 만들어야 한다.
```

--> 캡슐화 p.116 GoodDog 클래스 캡슐화 예제문제
class GoodDog {

	private int size;
	
	public int getSize() {
		return size;
	}
	
	public void setSize(int s) {
		size = s;
		}
	
	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size >14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class GoodDogTestDrive {
	
	public static void main(String[] args) {
		GoodDog one = new GoodDog();
		one.setSize(70);
		GoodDog two = new GoodDog();
		two.setSize(8);
		System.out.println("Dog one:" + one.getSize());
		System.out.println("Dog two:" + two.getSize());
		one.bark();
		two.bark();
	}
}

결과>
Dog one:70
Dog two:8
Wooof! Wooof!
Yip! Yip!

```

  * 게터와 세터: 게터(getter)와 세터(setter)의 정식 명칭은 액세서(accessor)와 뮤테이터(mutator)이다. 게터와 세터는 각각 어떤 것을 가져오고(get) 설정하는(get) 역할을 한다. 보통 인스턴스 변수의 값에 대해 그런 작업을 한다. 게터는 단지 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 쓰인다. 세터는 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
  * 인스턴스 변수 vs 지역 변수:
인스턴스 변수는 클래스 내에서 선언된다.(메소드 내에서 선언되는 것이 아니다.)
지역변수(local variable)는 메소드 내에서 선언된다. 또한 지역변수는 사용하기 전에 반드시 초기화해야한다.


**107p Dog** _실행_

```
class Dog {
	int size;
	String name;
	
	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {
	
	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
```

**122p 컴파일러가 되어봅시다** _구현후 주석달기_

```
A.
class XCopy {
	public static void main(String [] args) {
	int orig = 42; // orig 에 42 대입
	XCopy x = new XCopy(); 
	int y = x.go(orig); // y에 x.go(orig) 대입, 이때 orig 값은 42
	System.out.println(orig + " " + y); // 42 84 출력
}

int go(int arg) {
	arg = arg * 2; // 기존 orig 값인 42를 두배 하여 84 값으로 반환해준다.
	return arg;
 }
}

결과>
42 84

B.
class Clock {
	String time;
	void setTime(String t) {
		time = t;
		}

	String getTime() { // return 이 time 이므로 void 가 아닌 String이어야 한다.
		return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {
		
		Clock c = new Clock();
		
		c.setTime("1235"); // 초기 setTime 의 time t에 "1235"대입된다.
		String tod = c.getTime(); // tod 형태로 getTime 함수에서 return 되는 time을 받는다.
		System.out.println("time:"+tod);
	}
}

결과>
time:1235

```


# 05. 메소드를 더 강력하게:흐름 제어, 연산 등 #

**135p XP** _요약_
익스트림 프로그래밍(XP,eXtreme Programming)방법 중 하나인
테스트 코드를 먼저 만들어 놓는 방법은 쉽고 빠르게 코드를 만드는데 도움이 된다.

  * 익스트림 프로그래밍이란?
XP의 가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을
고객이 원하는 기한에 맞춰서 제공할 수 있다는 점이다.
이때 XP는 서로 조화롭게 쓸 수 있도록 계획된 일련의 규칙이 있다.
- 조금씩, 하지만 자주 발표한다.
- 사이클을 반복해서 돌리면서 개발한다,
- 스펙에 없는 것은 절대 집어넣지 않는다.(아무리 그 기능이 나중에
쓰일 것 같은 느낌이 들어도 그러지 않는 것이 좋다.)
- 테스트 코드를 먼저 만든다.
- 야근은 하지 마라, 항상 정규 일과 시간에만 작업한다.
- 기회가 생기는 족족 언제 어디서든 코드를 개선한다.
- 모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다.
- 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만든다.
- 모든 일을 단순하게 처리한다.
- 두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록
돌아가면서 작업한다.


**137p~ 간단한 닷컴 게임** _구현후 주석달기_

```

// SimpleDotComTestDrive.java
public class SimpleDotComTestDrive {
	
	public static void main(String[] args) {
		
		int numOfGuesses = 0; // 사용자가 추측한 횟수를 추적하기 위한 변수를 만든다.
		GameHelper helper = new GameHelper(); // 사용자로부터 입력을 받기 위한 메소드가
		// 들어있는 특별한 클래스가 있다고 생각한다.
		
		SimpleDotCom theDotCom = new SimpleDotCom(); // 닷컴객체를 만든다.
		int randomNum = (int) (Math.random() * 5); // 첫번째 셀 위치를 정하기 위한
		// 난수를 만들고 그 값을 써서 셀 위치 배열을 만든다.
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations); // 닷컴의 위치를 지정한다.(배열 사용)
		boolean isAlive = true; // 닷컴이 살아있는지 추적하기 위한 부울 변수를
		// 만들고 아직 살아있으면 계속 반복해준다.
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number"); //사용자가 입력한 String받아옴
			String result = theDotCom.checkYourself(guess); // 닷컴객체를 통해 추측한 값이 맞는지 확인.
			// 리턴된 결과는 String 에 저장한다.
			numOfGuesses++; // 추측 횟수를 증가시킨다.
			if(result.equals("kill")) { // "kill"이면 isAlive를 false로 설정한다.
				isAlive = false;
				System.out.println(numOfGuesses + "guesses");
								}
		}
	
	}
}

// GameHelper.java

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(
			new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()== 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: "+e);
		}
		return inputLine;
	}
}

//SimpleDotCom.java
public class SimpleDotCom {

	int[] locationCells; // locationCells의 배열을 만들어준다,
	int numOfHits = 0; // numOfHits의 값을 초기화 해준다.
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss"; // 예상값이 다를때  "miss" 출력
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) { 
				result = "hit"; // 예상값이 맞을때  "hit" 출력
				numOfHits++; // hit 수를 센다.
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill"; // 모든 수를 clear 했을때 kill 출력
		}
		System.out.println(result);
		return result;
		}
}


```

# 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다 #

**162p 닷컴 게임:첫번째 옵션** _구현후 주석달기_

```
기존 SimpleDotCom 클래스에서 수정해야 할 부분.
if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;

-> 수정 후
if(guess == locationCells[i]&&hitCells[i]!=true){
                                result = "hit"; // 이미 맞춘 셀이 중복되지 않게 따로 저장해 놓습니다.
                                numOfHits++;
                                hitCells[i] = true; 
                                break;

```

**163p 닷컴 게임:두번째 옵션** _구현후 주석달기_

```
기존 SimpleDotCom 클래스에서 수정해야 할 부분.
if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;

-> 수정 후
 for(int i = 0; i < locationCells.length; i++){
	 if(guess == locationCells[i]&&locationCells[i]!=-1)
	 result = "hit";
	 numOfHits++;
	 locationCells[i]=-1; // 원래 배열을 그냥 사용하면서 맞춘 셀의 값은 모두 -1로 바꿉니다.
	 break;
}
```

**173p 닷컴 게임:세번째 옵션** _구현후 주석달기_

```

import java.util.ArrayList;

public class DotCom {

	private ArrayList<String> locationCells; // 배열 대신 string이 들어가는 ArrayList를 사용합니다.
	// private int numOfHits;
	// (없어도 됩니다)
	public void setLocationCells(ArrayList<String> loc) {
		locationCells = loc;
	}
	
	public String checkYourSelf(String userInput) { // 새로 바뀐 인자명입니다.
		String result = "miss";
		
		int index = locationCells.indexOf(userInput); // 사용자가 추측한 위치가 ArrayList에
		// 들어있는지 확인합니다. 들어있으면 인덱스 번호가, 그렇지 않으면 -1이 리턴됩니다.
		
		if(index >= 0) { // 인덱스가 0 이상이면 사용자가 추측한 위치가 목록에 들어있는 것이므로 제거합니다.
			
			locationCells.remove(index);
			
			if(locationCells.isEmpty()) { // 목록이 비어있다면 그 닷컴이 죽었다는 것을 알 수 있습니다.
				result = "kill";
			} else {
				result = "hit";
			}
		}
	
	return result;
}
}


```

**174p 진짜 닷컴 게임** _구현후 주석달기_

```
기존 오류가 있던 DotCom ( SimpleDotCom )
public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
		}
}

새로 바꾼 오류 없는 DotCom 클래스
import java.util.ArrayList;

public class DotCom {

	private ArrayList<String> locationCells;
	
	public void setLocationCells(ArrayList<String> loc) {
		locationCells = loc;
	}
	
	public String checkYourSelf(String userInput) {
		String result = "miss";
		
		int index = locationCells.indexOf(userInput);
		
		if(index >= 0) {
			
			locationCells.remove(index);
			
			if(locationCells.isEmpty()) {
				result = "kill";
			} else {
				result = "hit";
				}
		}
	return result;
}
}
```

# 07. 객체마을에서의 더 나은 삶:미래를 준비합시다 #

**199p~ 상속과 다형성** _요약_

  * 상속(inheritance) : 상속을 이용하여 설계할 때는 공통적인 코드를 어떤 클래스에 넣은 다음, 다른 더 구체적인 클래스에 공통적인(더 추상적인) 클래스가 상위클래스라는 것을 알려주면 된다. 한 클래스가 다른 클래스를 상속하는 것을 **하위클래스가 상위클래스로부터 상속받는다고 말한다.**
  * 다형성(polymorphism) : 다형성을 활용하면 레퍼런스와 객체가 다른 유형이어도 된다. 하나의 변수,메소드가 다양한 의미로 사용된다는 의미. 또한 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있다.
cf) 오버라이드

**208p 클래스 계층 구조** _클래스로 구현_

```
class Animal {
        String picture;
        boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise(){
        }
        void eat(boolean food){
        }
        void sleep(){
        }
        void roam(){
        }
}

class Feline extends Animal{
        void roam(){
        }
}

class Lion extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Tiger extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Cat extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}


class Hippo extends Animal{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Canine extends Animal{
        void roam(){
        }
}

class Wolf extends Canine{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Dog extends Canine{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

```

**224p 오버라이드와 오버로딩** _요약_

  * 오버라이드 : 상위클래스의 메소드를 오버라이드할 때 규칙!
**1. 인자는 똑같아야 하고, 리턴 유형은 호환가능해야 한다.**
-> 상위클래스에서 어떤 인자를 받아들이든 오버라이드 하는 메소드에서는 똑같은 인자를 사용해야 한다. 그리고 상위클래스에서 어떤 리턴 유형을 선언하던지 오버라이드하는 메소드에서는 똑같은 유형, 또는 하위클래스 유형을 리턴하는 것으로 선언해야 한다. <br>
<b>2. 메소드를 더 접근하기 어렵게 만들면 안된다.</b>
-> 상위클래스의 계약서에서는 다른 코드에서 어떻게 메소드를 사용할 수 있는지를 정의한다. 즉, 접근 단계는 그대로 유지하거나 완화시켜야 한다.</li></ul>

<ul><li>오버로딩: 메소드 오버로딩(overloading)은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것이다. 오버로딩을 활용하면 호출하는 쪽의 편의를 위해 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있다.</li></ul>

<b>227p 컴파일러가 되어봅시다</b> <i>구현후 주석달기</i>

<pre><code>public class MonsterTestDrive {<br>
	public static void main(String [] args) { <br>
		Monster [] ma = new Monster[3]; // Vampire,Dragon,Monster이라는 세개의 클래스를 생성한다.<br>
		ma[0] = new Vampire();<br>
		ma[1] = new Dragon();<br>
		ma[2] = new Monster();<br>
		for(int x = 0; x&lt;3; x++) { // int 형태의 입력값 0,1,2 넣어준다.<br>
			ma[x].frighten(x);<br>
		}<br>
	}<br>
}<br>
<br>
==========================================<br>
<br>
public class Monster {<br>
		boolean frighten(int d) { //int 형식으로 받아서 bool형식으로 출력<br>
			System.out.println("arrrgh");<br>
			return true;<br>
		}<br>
}<br>
<br>
==========================================<br>
<br>
public class Vampire extends Monster {<br>
		boolean frighten(int x) {  //int 형식으로 받아서 bool형식으로 출력<br>
			System.out.println("a bite?");<br>
			return false;<br>
		}<br>
	}<br>
<br>
==========================================<br>
<br>
public class Dragon extends Monster{<br>
	boolean frighten(int degree) {<br>
		System.out.println("breath fire");<br>
		return true;<br>
	}<br>
}<br>
<br>
==========================================<br>
<br>
결과값 : <br>
a bite?<br>
breath fire<br>
arrrgh<br>
<br>
</code></pre>

<h1>08. 심각한 다형성:추상 클래스와 인터페이스 #

**231p~ 심각한 다형성** _요약_

  * 인터페이스: 100% 추상 클래스로 구성되어 있다.
  * 다형성: 다형성을 활용하면 레퍼런스와 객체가 다른 유형이어도 된다. 하나의 변수,메소드가 다양한 의미로 사용된다는 의미. 또한 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있다.
  * 추상 클래스: 인스턴스를 만들 수 없는 클래스이다. 또한 추상 클래스는 반드시 확장해야 하는 클래스를 의미한다.
  * 추상 메소드: 클래스뿐만 아니라 메소드 또한 추상(abstract)으로 지정 할 수 있다. 또한 반드시 오버라이드해야하는 메소드를 의미한다.
  * 다중 상속: 상위클래스를 두 개 사용하는 접근법으로, '다중상속(multiple inheritance)라고 부른다. --> 자바에서는 다중 상속을 쓸 수 없다. '죽음의 다이아몬드(The Deadly Diamond of Death)'라고 알려져 있는 문제가 있기 때문.
이때, 자바의 인터페이스가 해결책을 제공한다. (interface라는 자바 키워드)
자바의 인터페이스는 죽음의 다이아몬드 때문에 생기는 부작용없이 다중 상속의 다형적인 장점을 대부분 누릴 수 있게 해 줌으로써 다중 상속 문제를 해결해준다.

```
// p.266 수영장퍼즐 문제
interface Nose {
	public int iMethod();
}
abstract class Picasso implements Nose {
	public int iMethod(){
		return 7;
	}
}
public class Clowns extends Picasso { }
public class Acts extends Picasso {
	public int iMethod() {
		return 5;
	}
}
public class Of76 extends Clowns {
	public static void main(String [] args){
		Nose []i= new Nose[3];
		i[0] = new Acts();
		i[1] = new Clowns();
		i[2] = new Of76();
		for(int x = 0; x < 3; x++) {
			System.out.println(i[x].iMethod()+ ""+i[x].getClass());
		}
		}
}


결과값 : 
5class Acts
7class Clowns
7class Of76

```
# 09. 객체의 삶과 죽음:생성자와 메모리 관리 #

**269p~ 객체의 삶과 죽음** _요약_

  * 힙에서의 변수:  힙(heap)은 객체가 사는 곳이다. ==> 인스턴스 변수(의미 : 클래스 내에서 선언한 것, 이때 메소드 내에서 선언한 것은 인스턴스 변수에 포함되지 않는다.)
```
예 )
public class Duck {
	int size; // 모든 Duck에는 "size" 인스턴스 변수가 들어있다.
}
```
  * 스택에서의 변수: 스택(stack)은 지역 변수가 살아가는 곳이다. ==> 지역 변수(의미 : 메소드 안에서 선언한 것, 이때 메소드 매개변수도 지역 변수에 포함된다.)
```
예)
public void foo(int x) {
	int i = x + 3;
	boolean b = true; // 매개변수 x와 변수 i,b는 모두 지역 변수이다.
}
```
  * 생성자: 생성자에는 객체를 생성할때 실행되는 코드가 들어있다. 즉, 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있다. 우리가 만드는 모든 클래스에는 직접 만들지 않아도 생성자가 있다.

  * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 즉, 리모컨은 있으나 그 리모컨으로 조종할 TV가 없는 셈이다.
널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다.

**298p 집중토론** _요약_

  * 오늘의 주제 : 인스턴스 변수와 지역 변수의 삶과 죽음
  * 인스턴스 변수: **객체를 지원하는 역할을 하며 보통 객체가 살아있는 동안 항상 객체와 함께 한다. 상태란 인스턴스 변수에 저장된 값이다. 인스턴스 변수는 힙 안에서 객체 안에서 산다.
  * 지역 변수:**'행동' 파트를 맡는다. 즉, 메소드에 들어있는 알고리즘을 작동시키려면 메소드에 반드시 지역 변수가 있어야만 한다. '임시 변수'라는 말보다 '지역','스택','자동','영역 제한' 같은 용어를 선호한다. "스택에서 프레임을 제거한다"의 의미는 지역 변수의 수명이 다한다는 의미나 마찬가지.

**302p 5분 미스터리** _구현후 주석달기_

```

import java.util.ArrayList;

class V2Radiator {
	V2Radiator(ArrayList list) {
		for(int x=0; x<5; x++) {
			list.add(new SimUnit("V2Radiator"));
		}
	}
}

class V3Radiator extends V2Radiator {
	V3Radiator(ArrayList lglist) {
		super(lglist);
		for(int g=0; g<10; g++) {
			lglist.add(new SimUnit("V3Radiator"));
		}
	}
}
class RetentionBot {
	RetentionBot(ArrayList rlist) {
		rlist.add(new SimUnit("Retention"));
		}
}

public class TestLifeSupportSim {
	public static void main(String [] args) {
		ArrayList aList = new ArrayList();
		V2Radiator v2 = new V2Radiator(aList);
		V3Radiator v3 = new V3Radiator(aList);
		for(int z=0; z<20; z++) {
			RetentionBot ret = new RetentionBot(aList);
			}
	}
}

class SimUnit {
	String botType;
	SimUnit(String type) {
		botType = type;
	}
	int powerUse() {
		if("Retention".equals(botType)) {
			return 2;
			} else {
				return 4;
			}
	}
}


```

# 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계 #

**307p~ 숫자** _요약_

  * 정적 메소드:  정적(static) 메소드는 '인스턴트 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않습니다. 클래스만 있어도 됩니다.'를 의미한다.
  * 정적 메소드를 선언하는 방법: 정적 메소드를 호출할 때는 클래스명을 사용한다. 그리고 정적 메소드에서는 정적 변수가 아닌 변수(인스턴스 변수)를 쓸 수 없다.
  * static final: static final로 선언된 변수는 상수이다.  final 로 지정한 변수는 절대 그 값을 바꿀 수 없다. static final로 선언한 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지한다.
  * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것이다. 널 레퍼런스에는 '널'상태를 나타내는 비트들이 들어있다.
  * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능이다.(자바 5.0 부터 도입)
  * 정적 임포트: 포매팅은 크게 1. 지시사항, 2. 대상 인자라는 두 부분으로 나눠져있다.

**339p Calendar** _구현후 주석달기_

```
import java.util.*;

public class Calender {
        public static void main(String[] args) {
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40); // 현재 시각 설정하기
                long day1 = c.getTimeInMillis(); // 밀리초 단위로 시간 표현
                day1 += 1000*60*60;
                
                c.setTimeInMillis(day1); 
                System.out.println("new hour " + c.get(c.HOUR_OF_DAY));
                
                c.add(c.DATE, 35); // 35일 add
                System.out.println("add 35 days " + c.getTime());
                
                c.roll(c.DATE, 35); 
                System.out.println("roll 35 days " + c.getTime());
                
                c.set(c.DATE, 1); // 1로 날짜 설정
                System.out.println("set to 1 " + c.getTime());
        }
}
```

**342p 집중토론** _요약_

  * 인스턴스 변수:
객체지향적이다.
객체가 객체지향적인 설계 과정에 있어서 가장 중요하다.
정적 메소드는 그 객체의 인스턴스 변수를 사용할수 없다.
정적 변수를 써서 클래스의 인스턴스의 개수를 셀 수 있다.

  * 지역 변수:
상수에 불과하다.
그러나 상수만 들어있는 클래스도 있다. (eg. SwingConstans 같은 클래스)
인스턴스마다 하나씩 있는게 아니고 클래스마다 하나씩 있기때문에 메모리가 많이 절약된다.
전역변수와 비슷하게 객체지향적이지 않다.


**344p 컴파일러가 되어봅시다** _구현후 주석달기_

```
class StaticSuper
{
        static//static 메소드
        {
                System.out.println("super static blokc");
        }
        
        StaticSuper()//생성자
        {
                System.out.println("super constructor");
        }
}

public class StaticTests extends StaticSuper//StaticTests 는 StaticSuper을 확장
{
        static int rand;//static 변수
        
        static//static 메소드        {
                rand = (int) (Math.random() * 6);
                System.out.println("static block " + rand);
        }
        
        StaticTests()//생성자
        {
                System.out.println("in main");
                StaticTests st = new StaticTests();//StaticTests 객체 생성
        }
}

<결과 화면>
super static block
static block0
in main
super constructor
constructor

```

# 11. 위험한 행동:예외처리 #

**357p try/catch** _구현후 주석달기_

```
public void takeRisk() throws BadException { 
     if (abandonAllHope){
           throw new BadEXception(); 
    }
}

public void crossFingers(){
     try{
               anObject.takeRisk();
     } catch (BadException ex){
        System.out.println("Aaargh!");
        ex.printStackTrace();
     }
}
```

**376p~ 첫번째 사운드 애플리케이션** _구현후 주석달기_

```
import javax.sound.midi.*;

public class MiniMiniMusicApp {
	public static void main(String[] args){
		MiniMiniMusicApp mini = new MiniMiniMusicApp();
		mini.play();
	}
	public void play() {
		try{
			Sequencer player = MidiSystem.getSequencer();
			player.open();
			Sequence seq = new Sequence(Sequence.PPQ,4);
			Track track = seq.createTrack();
			
			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,44,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,44,100);
			MidiEvent noteOff = new MidiEvent(b,16);
			track.add(noteOff);
			
			player.setSequence(seq);
			player.start();
			 } catch (Exception ex) {
				 			ex.printStackTrace();
				 }
	}
}
```

**380p~ 두번째 사운드 애플리케이션** _구현후 주석달기_

```
import javax.sound.midi.*;


public class MiniMusicCmdLine
{
        public static void main(String[] args)
        {
                MiniMusicCmdLine mini = new MiniMusicCmdLine();//객체 생성
                
                if(args.length < 2 )
                        System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
                else
                {
                        int instrument = Integer.parseInt(args[0]);//악기 설정
                        int note = Integer.parseInt(args[1]);//노트 설정
                        mini.play(instrument,note);//play 메소드 실행하면서 인자로 넘겨줌
                        
                }
        }
        
        public void play(int instrument, int note)
        {
                try
                {
                        Sequencer player = MidiSystem.getSequencer();//시퀀서를 생성
                        player.open();
                        Sequence seq = new Sequence(Sequence.PPQ,4);
                        Track track = seq.createTrack();//track 을 생성
                        
                        MidiEvent event = null;//event 생성
                        
                        ShortMessage first = new ShortMessage();
            first.setMessage(192,1,instrument,0);
            MidiEvent changeInstrument = new MidiEvent(first, 1);
            track.add(changeInstrument);

            ShortMessage a = new ShortMessage();
            a.setMessage(144,1,note,100);
            MidiEvent noteOn = new MidiEvent(a,1);
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            a.setMessage(128,1,note,100);
            MidiEvent noteOff = new MidiEvent(b,16);
            track.add(noteOff);
            player.setSequence(seq);
            player.start();
                }
                
                catch(Exception ex)
                {
                        ex.printStackTrace();
                }
        }
}
```

# 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개 #

**389p~ 첫번째 GUI:버튼** _구현후 주석달기_

```
import javax.swing.*;

public class SimpleGui1 {
	public static void main(String[] args) {
		
		JFrame frame = new JFrame();
		JButton button = new JButton("click me");
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		frame.getContentPane().add(button);
		
		frame.setSize(300,300);
		
		frame.setVisible(true);
	}
}
```

**394p~ ActionEvent** _구현후 주석달기_

```
import javax.swing.*;

public class SimpleGui1{
        public static void main(String []args){
                JFrame frame = new JFrame(); // 프레임을 생성
                JButton button = new JButton("click me");  // 버튼을 생성
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 버튼 누를 때 창이 종료되도록 설정
                frame.getContentPane().add(button); // 프레임에 버튼을 추가
                frame.setSize(300,300); // 프레임의 크기를 픽셀단위로 지정
                frame.setVisible(true); // 화면에 표시되도록 설정
        }
}
```

**405p 버튼과 원의색** _구현후 주석달기_

```
import javax.swing.*;
import java.awt.event.*;

public class SimpleGui1B implements ActionListener
{
        JButton button;
        
        public static void main(String[] args)
        {
                SimpleGui1B gui = new SimpleGui1B();//객체 생성
                gui.go();//go 메소드 실행
        }
        
        public void go()
        {
                JFrame frame = new JFrame();//프레임 생성
                button = new JButton("Click me");//버튼을 생성하고 Click me라고 메시지를 전달
                
                button.addActionListener(this);//버튼에 액션 리스너를 집어넣기
                
                frame.getContentPane().add(button);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(300, 300);
                frame.setVisible(true);
                
        }
        
        public void actionPerformed(ActionEvent event)//ActionListener 메소드 구현
        {
                button.setText("I've been clicked!");
        }
}
```

**413p 두개의 버튼과 원의색** _구현후 주석달기_

```
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class TwoButtons
{
        JFrame frame;
        JLabel label;
        
        public static void main(String[] args)
        {
                TwoButtons gui = new TwoButtons();
                gui.go();
                
        }
        
        public void go()
        {
                frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        JButton labelButton = new JButton("Change Label");
        labelButton.addActionListener(new LabelListener());//내부클래스 객체 전달
        
        JButton colorButton = new JButton("Change Circle");
        colorButton.addActionListener(new ColorListener());//내부클래스 객체 전달
        
        label = new JLabel("I'm a label");
        MyDrawPanel drawPanel = new MyDrawPanel();
        
        frame.getContentPane().add(BorderLayout.SOUTH,colorButton);
        frame.getContentPane().add(BorderLayout.CENTER,drawPanel);
        frame.getContentPane().add(BorderLayout.EAST,labelButton);
        frame.getContentPane().add(BorderLayout.WEST,label);
        
        frame.setSize(300,300);
        frame.setVisible(true);
        }
        
        class LabelListener implements ActionListener
        {

                @Override
                public void actionPerformed(ActionEvent event)
                {
                        label.setText("Ouch!");//text 변경
                }
                
        }//inner class end
        
        class ColorListener implements ActionListener
        {

                @Override
                public void actionPerformed(ActionEvent event)
                {
                        frame.repaint();//페인트 색상 변경
                }
                
        }
}
```

**418p 간단한 애니메이션** _구현후 주석달기_

```
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation 
{

        int x=70;
        int y=70;
        //원의 x, y좌표를 설정
        
        public static void main(String args[]){
                SimpleAnimation gui=new SimpleAnimation();
                gui.go();
        }
        
        public void go()
        {
                JFrame frame=new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                MyDrawPanel drawPanel = new MyDrawPanel();// 위젯을 만들고 프레임에 집어 넣기
                frame.getContentPane().add(drawPanel);
                frame.setSize(300,300);
                frame.setVisible(true);

                for(int i=0;i<300;i++){ // 반복

                        x++;
                        y++;
                        //x와 y 좌표를 증가
                        
                        drawPanel.repaint();

                        try{
                                Thread.sleep(50); //속도를 약간 줄임
                        }catch(Exception ex){}
                }

        } 

        @SuppressWarnings("serial")
                class MyDrawPanel extends JPanel
        {
                public void paintComponent(Graphics g)
                {
                        g.setColor(Color.white);
                        g.fillRect(0,0,this.getWidth(),this.getHeight());

                        g.setColor(Color.green);
                        g.fillOval(x, y, 40, 40); //지속적으로 갱신되는 외부클래스의 x, y 좌표를 사용

                }
        }
}

```

**420p 뮤직 비디오** _구현후 주석달기_

```
import javax.sound.midi.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 
{

        static JFrame f = new JFrame("My First Music Video");//프레임 생성
        static MyDrawPanel m1;//패널 생성

        public static void main(String [] args)
        {
                MiniMusicPlayer3 mini = new MiniMusicPlayer3();//객체 생성
                mini.go();
        }

        public void setUpGui()
        {
                m1 = new MyDrawPanel();//패널 만들기
                f.setContentPane(m1);
                f.setBounds(30, 30, 300, 300);//경계설정
                f.setVisible(true);
        }

        public void go()
        {
                setUpGui();

                try{

                        Sequencer sequencer = MidiSystem.getSequencer();
                        sequencer.open();
                        sequencer.addControllerEventListener(m1, new int[] {127});
                        Sequence seq = new Sequence(Sequence.PPQ, 4);
                        Track track = seq.createTrack();

                        int r = 0; 
                        for(int i = 0; i < 60 ; i+=4)
                        {

                                r=(int)((Math.random()*50)+1);
                                track.add(makeEvent(144,1,r,100,i));
                                track.add(makeEvent(176,1,127,0,i));
                                track.add(makeEvent(128,1,r,100,i+2));
                        }//반복적으로 음악을 만들기

                        sequencer.setSequence(seq);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                } 
                
                catch(Exception ex) 
                {
                        ex.printStackTrace();
                }
        }

        public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick)
        {
                MidiEvent event = null;
               
                try{
                        ShortMessage a = new ShortMessage();
                        a. setMessage(comd,chan,one,two);
                        event = new MidiEvent(a, tick);
                }
                catch(Exception e)
                {
                        
                }
                
                return event;

        }

        @SuppressWarnings("serial")
                class MyDrawPanel extends JPanel implements ControllerEventListener
        {
                boolean msg = false;

                public void controlChange(ShortMessage event)
                {
                        msg = true;
                        repaint();//색 설정
                }

                public void paintComponent(Graphics g)
                {
                        if(msg)
                        {

                                @SuppressWarnings("unused")
                                                                Graphics2D g2= (Graphics2D)g;

                                int r = (int) (Math.random()*250);
                                int gr=(int) (Math.random()*250);
                                int b= (int ) (Math.random()*250);

                                g.setColor(new Color(r,gr,b));

                                int ht=(int) ((Math.random()*120)+10);
                                int width=(int) ((Math.random()*120)+10);

                                int x=(int) ((Math.random()*40)+10);
                                int y=(int) ((Math.random()*40)+10);

                                g.fillRect(x, y, ht, width);
                                msg = false;
                        }
                }
        }
}

```

# 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소 #

**452p 비트박스 프로그램** _구현후 주석달기_

```
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox
{

    JPanel mainPanel;
    ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", 
       "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", 
       "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", 
       "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", 
       "Open Hi Conga"}; 
    // GUI 레이블을 만들 때 사용할 악기명 String 배열로 저장
    
    int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};             

    public static void main (String[] args) 
    {
        new BeatBox().buildGUI();
    }
  
    public void buildGUI() 
    {
        theFrame = new JFrame("Cyber BeatBox");
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout);
        background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

        checkboxList = new ArrayList<JCheckBox>();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton("Start");
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);         
          
        JButton stop = new JButton("Stop");
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton("Tempo Up");
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton("Tempo Down");
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        
        for (int i = 0; i < 16; i++) 
        {
           nameBox.add(new Label(instrumentNames[i]));
        }
        
        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);

        theFrame.getContentPane().add(background);
          
        GridLayout grid = new GridLayout(16,16);
        
        grid.setVgap(1);
        grid.setHgap(2);
        
        mainPanel = new JPanel(grid);
        
        background.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i < 256; i++)
        {                    
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);            
        } 
        //체크상자를 만들고 모든 값을 'false'로 설정한 다음 arraylist와 gui패널에 추가
        setUpMidi();

        theFrame.setBounds(50,50,300,300);
        theFrame.pack();
        theFrame.setVisible(true);
        
    }
    public void setUpMidi()
    {
      try 
      {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequence = new Sequence(Sequence.PPQ,4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
        
      } 
      catch(Exception e) 
      {
          e.printStackTrace();
      }
    } 

    public void buildTrackAndStart()
    {
     
        int[] trackList = null; //악기들의 박자에 대한 개별 값을 배열에 저장
        sequence.deleteTrack(track);
        track = sequence.createTrack();

                for (int i = 0; i < 16; i++) { // 열 16개에 대해 모두 같이 처리
                  trackList = new int[16];
         
                  int key = instruments[i];//어떤 악기인지를 나타내는 건반 번호설정
        
                  for (int j = 0; j < 16; j++ ) 
                  {         
                      JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));
                     
                      if ( jc.isSelected()) 
                      { 
                         trackList[j] = key;
                      } 
                      else 
                      { 
                         trackList[j] = 0;
                      }
                      
                   }
                 
                   makeTracks(trackList); 
                   track.add(makeEvent(176,1,127,0,16));  
                   
               } 
        
               track.add(makeEvent(192,9,1,0,15));//16번째 박자에는 반드시 이벤트가 있어야 함
               
               try {
                   sequencer.setSequence(sequence); 
                     sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); //루프 반복 횟수를 지정하기 위한 메소드                 
                   sequencer.start();
                   sequencer.setTempoInBPM(120);
               } 
               catch(Exception e) 
               {
                   e.printStackTrace();
               } 
               // 연주
               
    } 
           
    public class MyStartListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
            buildTrackAndStart();
        }
    } 

    public class MyStopListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
            sequencer.stop();
        }
    } 

    public class MyUpTempoListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
              float tempoFactor = sequencer.getTempoFactor(); 
            sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도를 빠르게증가
        }
     } 

     public class MyDownTempoListener implements ActionListener 
     {
         public void actionPerformed(ActionEvent a)
         {
              float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도를 느리게함
        }
    } 

    public void makeTracks(int[] list)
    {        
       
       for (int i = 0; i < 16; i++) 
       {
          int key = list[i];

          if (key != 0) 
          {
             track.add(makeEvent(144,9,key, 100, i));
             track.add(makeEvent(128,9,key, 100, i+1));
             //NOTE ON과 NOTE OFF 이벤트를 만들고 트랙에 추가
          }
       }
    }
        
    public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick)
    {
        MidiEvent event = null;
        
        try 
        {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);

        } 
        catch(Exception e) 
        {
                e.printStackTrace(); 
        }
        return event;
    }

} 
```

# 14. 객체 저장:직렬화와 입출력 #

**496p 비트박스 프로그램** _구현후 주석달기_

```
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class BeatBox
{

    JPanel mainPanel;
    ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", 
       "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", 
       "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", 
       "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", 
       "Open Hi Conga"}; 
    
    int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};             

    public static void main (String[] args) 
    {
        new BeatBox().buildGUI();
    }
  
    public void buildGUI() 
    {
        theFrame = new JFrame("Cyber BeatBox");
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout);
        background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

        checkboxList = new ArrayList<JCheckBox>();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton("Start");
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);         
          
        JButton stop = new JButton("Stop");
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton("Tempo Up");
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton("Tempo Down");
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);
        
        JButton serial = new JButton("serializelt");
        serial.addActionListener(new MySendListener());
        buttonBox.add(serial);
        
        JButton restore = new JButton("restore");
        restore.addActionListener(new MyReadInListener());
        buttonBox.add(restore);
        
        Box nameBox = new Box(BoxLayout.Y_AXIS);
        
        for (int i = 0; i < 16; i++) 
        {
           nameBox.add(new Label(instrumentNames[i]));
        }
        
        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);

        theFrame.getContentPane().add(background);
          
        GridLayout grid = new GridLayout(16,16);
        
        grid.setVgap(1);
        grid.setHgap(2);
        
        mainPanel = new JPanel(grid);
        
        background.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i < 256; i++)
        {                    
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);            
        } 
    

        setUpMidi();

        theFrame.setBounds(50,50,300,300);
        theFrame.pack();
        theFrame.setVisible(true);
        
    }
   

    public void setUpMidi()
    {
      try 
      {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequence = new Sequence(Sequence.PPQ,4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
        
      } 
      catch(Exception e) 
      {
          e.printStackTrace();
      }
    } 

    public void buildTrackAndStart()
    {
     
        int[] trackList = null; //각 악기의 열여섯 박자에 대한 값을 배열에 저장
    
        sequence.deleteTrack(track);
        track = sequence.createTrack();
        //기존 트랙을 제거하고 트랙을 새로 만듭니다.

                for (int i = 0; i < 16; i++) { // 열 16개에 대해 모두 같은 작업을 처리
                  trackList = new int[16];
         
                  int key = instruments[i];//어떤 악기인지를 나타내는 건반 번호를 설정   
        
                  for (int j = 0; j < 16; j++ ) 
                  {         
                      JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));
                     
                      if ( jc.isSelected()) 
                      { 
                         trackList[j] = key;
                      } 
                      else 
                      { 
                         trackList[j] = 0;
                      }   
                    
                      
                   } 
                 
                   makeTracks(trackList); //이 악기의 16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가
                   track.add(makeEvent(176,1,127,0,16));  
                   
               } // 바깥쪽 for문 끝
        
               track.add(makeEvent(192,9,1,0,15));//16번째 박자에는 반드시 이벤트가 있어야 합니다. 안그러면 그 전에 끝나요   
               
               try {
                   sequencer.setSequence(sequence); 
                   sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); 
                   sequencer.start();
                   sequencer.setTempoInBPM(120);
               } 
               catch(Exception e) 
               {
                   e.printStackTrace();
               } 
               // 연주 시작
               
    } 
    public class MySendListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
                boolean[] checkboxState = new boolean[256];//각 체크상자의 상태를 담아두기 위한 부울 배열을 만들기
                
                for(int i = 0; i < 256; i++)
                {
                        JCheckBox check = (JCheckBox) checkboxList.get(i);
                        if(check.isSelected())
                        {
                                checkboxState[i] = true;
                        }
                }
                
        
                try
                {
                        FileOutputStream fileStream = new FileOutputStream(new File("Checkbox.ser"));
                        ObjectOutputStream os = new ObjectOutputStream(fileStream);
                        os.writeObject(checkboxState);
                
                }
                catch(Exception ex)
                {
                        ex.printStackTrace();
                }

        }
   }

    public class MyReadInListener implements ActionListener
    {

        @Override
        public void actionPerformed(ActionEvent e)
        {
                boolean[] checkboxState = null;
                
                try
                {
                        FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
                        ObjectInputStream is = new ObjectInputStream(fileIn);
                        checkboxState = (boolean[]) is.readObject();
                        
                }
                catch(Exception ex)
                {
                        ex.printStackTrace();
                }
                
                for(int i = 0 ; i < 256; i ++)
                {
                        JCheckBox check = (JCheckBox) checkboxList.get(i);
                        if(checkboxState[i])
                                check.setSelected(true);
                        else
                                check.setSelected(false);
                }
                // 체크상자를 원래대로 복구
                
                sequencer.stop();
                buildTrackAndStart();
                
                
        }
        
    }

            
           
    public class MyStartListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
            buildTrackAndStart();
        }
    }
   
    public class MyStopListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
            sequencer.stop();
        }
    } // 내부 클래스 끝

    public class MyUpTempoListener implements ActionListener 
    {
        public void actionPerformed(ActionEvent a) 
        {
              float tempoFactor = sequencer.getTempoFactor(); 
            sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도 빠르게증가
        }
     } 

     public class MyDownTempoListener implements ActionListener 
     {
         public void actionPerformed(ActionEvent a)
         {
              float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도를 느리게감소시킵니다.
        }
    } 

    public void makeTracks(int[] list)//한 악기의 16박자 전체에 대해 이벤트를 만들기
    {        
       
       for (int i = 0; i < 16; i++) 
       {
          int key = list[i];

          if (key != 0) 
          {
             track.add(makeEvent(144,9,key, 100, i));
             track.add(makeEvent(128,9,key, 100, i+1));
             //NOTE ON과 NOTE OFF 이벤트를 만들고 트랙에 추가합니다.
          }
       }
    }
        
    public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick)
    {
        MidiEvent event = null;
        
        try 
        {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);

        } 
        catch(Exception e) 
        {
                e.printStackTrace(); 
        }
        return event;
    }

} 
```