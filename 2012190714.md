

# 01. 껍질을 깨고:간단한 소개 #

**48p BeerSong** _문제해결하기, 주석달기_

```

/* 컴파일 시 마지막에 
1 bottles of beer on the wall
1 bottle of beer on the wall
1 bottle of beer.
Take one down.
Pass it around.
no more bottles of beer on the wall
이렇게 단, 복수 오류가 뜬다. 책의 코딩을 아래와 같이 고치면 */

public class Beersong {
	public static void main(String[] args) {
		
                int beerNum = 99;
		String word = "bottles"; //복수형
		
		while (beerNum>0){
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum-1;
			
			if (beerNum ==1){
				word = "bottle"; //단수형
			} //위의 네 줄과 순서를 바꾼 상태
			
			if (beerNum > 0){
				System.out.println(beerNum + " " + word + " of beer on the wall");
			}else{
				System.out.println("no more bottles of beer on the wall");
			} //else문 끝
		} //while문 끝

	} //main클래스 끝
} //클래스 끝

/* 고치면 
1 bottle of beer on the wall
1 bottle of beer on the wall
1 bottle of beer.
Take one down.
Pass it around.
no more bottles of beer on the wall
위와 같이 된다.*/
```

**50p PhraseOMatic** _wordListOne, wordListTwo, wordListThree를 변경_

```

//자동구문 생성기 - 내가 사는 곳

public class PhraseOMatic {
	public static void main(String[] args) {
		
                //세 종류의 단어 목록 
		String[] wordListOne = {"small","big","famous","beautiful"};
		String[] wordListTwo = {"town","city","countryside"};
		String[] wordListThree = {"Korea","Japan","China","Thailand","Singapore"};
		
		//각 단어 목록에 들어간 단어 개수
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		//난수 세 개 발생
		int rand1 = (int)(Math.random()*oneLength);
		int rand2 = (int)(Math.random()*twoLength);
		int rand3 = (int)(Math.random()*threeLength);
		
		//구문 만들기
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " in " + wordListThree[rand3];
		
		//구문 출력
		System.out.println("I live in a " + phrase + ".");
	}
}

```

**52p 집중토론** _요약_

  * 자바 가상 머신: 프로그램을 실행, 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 외부의 접근을 확인하는 작업 수행.

  * 컴파일러: 자바 언어를 해석, 동적 바인딩 지원, 실행 시 오류 막아줌, 클래스 및 메소드의 보안 담당.

**55p 컴파일러가 되어봅시다** _구현후 주석달기_

```

//A.
public class Exercise1b {
	public static void main(String[] args) {
		int x = 1;
		
                while(x<10){ 
			x = x+1; //출력값이 나오도록 조건을 추가
			if(x>3){
				System.out.println("big x");
			}
		}
	}
}

//B.
public class Exercise1b { //클래스가 없으므로 추가
	public static void main(String[] args) {
		int x = 5;
		
                while(x>1){ 
			x = x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}

//C.
public class Exercise1b { 
	public static void main(String[] args) { //메인 메소드가 없으므로 추가
		int x = 5;
		
                while(x>1){ 
			x = x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}

```


# 02. 객체마을로의 여행:객체에 대해 알아봅시다 #

**68p~ 클래스** _요약_

  * 인스턴스 변수: 객체에서 대해 아는 것(객체의 데이터 혹은 상태)

  * 메소드: 객체에서 할 수 있는 일

  * 클래스: 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할

  * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어이쓴 메소드와 변수를 테스트하는 역할, main() 메소드를 포함하며 그 main() 메소드에서 테스트할 클래스 유형의 객체를 만들어서 접근


**68p Television** _채워넣기_

  * 인스턴스 변수: volume, channel

  * 메소드: volumeUp(), volumeDown(), channelUp(), channerDown()


**72p GuessGame** _게임에 참여하는 사람 수를 4명으로 변경_

```

package GuessGame;

public class GuessGame {
	
        Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random()*10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp1 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp1 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if(guessp1 == targetNumber){
				p1isRight = true;
			}
			
			if(guessp2 == targetNumber){
				p2isRight = true;
			}
			
			if(guessp3 == targetNumber){
				p3isRight = true;
			}
			
			if(guessp4 == targetNumber){
				p4isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight || p4isRight){
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break;
			
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
			
		}
	}
}

public class Player {
	int number = 0;
	
	public void guess(){
		number = (int) (Math.random()*10);
		System.out.println("찍은 숫자: " + number);
	}

}

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

```

**76p 컴파일러가 되어봅시다** _구현후 주석달기_

```

//A.
public class TapeDeck{
	boolean canRecord = false;
	
	void playTape(){
		System.out.println("tape playing");
	}
	
	void recordTape(){
		System.out.println("tape recording");
	}
}

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		TapeDeck t = new TapeDeck(); // 새로운 객체를 지정해줘야 함
		
		t.canRecord = true;
		t.playTape();
		
		if (t.canRecord == true){
			t.recordTape();
		}
	}
}


//B.
public class DVDPlayer {
	boolean canRecord = false;
	
	void recordDVD(){
		System.out.println("DVD recording");
	}
	
	void playDVD(){
		System.out.println("DVD playing");
	} // playDVD에 대한 메소드 삽입
}

public class DVDPlayerTestDrive {
        public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		
		if(d.canRecord == true){
			d.recordDVD();
		}
	}
}

```


# 03. 네 변수를알라:원시 변수와 레퍼런스 #

**83p~ 변수** _요약_

  * 원시변수 vs 레퍼런스변수:

원시변수: 정수, 부울. 부동소수점 수와 같은 기초적인 값이 들어감

레퍼런스변수: 객체에 대한 레퍼런스, 특정 객체에 접근하는 방법을 나타내는 비트가 변수 값

**96p Dog** _수많은 개를 만들어 난장판 만들기_

```

public class Dog {
	String name;
	
        public static void main(String[] args) { 
		
                // Dog 객체를 만들고 접근
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		
		// Dog 배열 만들기
		Dog[] myDogs = new Dog[5];
		
		// 개 5마리 집어넣기
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = new Dog();
		myDogs[3] = dog1;
		myDogs[4] = new Dog();

		// 배열 레퍼런스를 써서 Dog객체에 접근
		myDogs[0].name = "Fred";
		myDogs[1].name = "Merge";
		myDogs[2].name = "Burkey";
		myDogs[4].name = "Poli";
		
		// 네번째 개 이름?
		System.out.print("네 번째 개의 이름: ");
		System.out.println(myDogs[3].name);
		
		// 순환문을 써서 배열에 들어있는 모든 개가 짖도록
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
	
	public void bark(){
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	
	public void eat(){
	}
	
	public void chaseCat(){
	}
}

```

**97p 컴파일러가 되어봅시다** _구현후 주석달기_

```

//A.
package Books;

public class Books {
	String title;
	String author;
}

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books[] myBooks = new Books[3];
		
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); // 새로운 세 개의 객체 만들어야 함
		
		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		
		while(x<3){
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x+1;
		}

	}
}


//B.
public class Hobbits {
	String name;
	
        public static void main(String[] args) {
		
		Hobbits[] h = new Hobbits[3];
		int z = -1; // 배열은 0부터 시작하므로
		
		while(z<2){
			z = z+1; // z값 0으로 설정
		
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			
			if(z==1){
				h[z].name = "frodo";
			}
			
			if(z==2){
				h[z].name = "sam";
			}
				
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobbit name");
		}

	}
}

```

**101p 레퍼런스 도용사건** _요약_

  * 누가 이겼나요?: 밥
  * 문제가 된 부분은 어딘가요?: 켄트의 방식으로 메소드를 만들면 10개의 객체가 아닌 마지막으로 만든 객체 하나만 사용 가능


# 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향 #

**105p~ 객체** _요약_

  * 캡슐화: 인스턴스 변수를 부적절한 값으로 설정하지 못하게 막기 위해 인스턴스 변수를 private로 지정하고 접근 제어를 위해 게터와 세터를 public으로 지정

  * 게터와 세터: 인스턴스 변수의 값에 대해 가져오기로 되어있는 값을 리턴값 형태로 받아오는 것을 게터, 설정한 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰이는 것이 세터라 함

  * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언되고, 지역 변수는 메소드 내에서 선언됨(지역 변수는 항상 초기화 필요)

**107p Dog** _실행_

```

package Dog;

public class Dog {
	int size;
	String name;
	
	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof");
		}else if(size>14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}
}

public class DogTestDrive {
	public static void main(String[] args) {
		
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();

	}
}

```

**122p 컴파일러가 되어봅시다** _구현후 주석달기_

```

//A.
public class XCopy {
        public static void main(String[] args) {
		int orig = 42;
		XCopy x = new XCopy();
		int y = x.go(orig);
		System.out.println(orig + " " + y); // orig 값은  변하지 않고 y는 인자값의 두배로 리턴됨
	}

	int go(int arg){
		arg = arg*2;
		return arg;
	}
}
// 결과 : 42 84


//B.
package Clock;

public class Clock {
	String time;
	
	void setTime(String t){
		time = t;
	}
	
	String getTime(){ // 게터는 반드시 리턴 유형이 있어야 함
		return time;
	}

}

public class ClockTestDrive {
        public static void main(String[] args) {
		
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time: " + tod);
		
	}
}

```


# 05. 메소드를 더 강력하게:흐름 제어, 연산 등 #

**135p XP** _요약_

  * 익스트림 프로그래밍이란? 소프트웨어 개발 방법으로, 비즈니스의 요구가 시시각각 변동이 심할 경우에 적합. 고객이 원하는 양질의 소프트웨어를 빠른 시간안에 전달하는 것을 목적으로 하며 일련의 규칙들이 있음

**137p~ 간단한 닷컴 게임** _구현후 주석달기_

```

package SimpleDotCom;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0)
				return null;
		}
		
		catch(IOException e){
			System.out.println("IOException: " + e);
		}
		
		return inputLine;
	}
}


public class SimpleDotCom {
	int [] locationCells; 
	int numOfHits = 0; // 맞춘 횟수 초기화
	
	public void setLocationCells(int [] locs){
		locationCells = locs;
	}

	public String checkYourself(String stringGuess){
		int guess = Integer.parseInt(stringGuess); // String 을 int 로 변환
		String result = "miss"; // 기본 값 지정
		
		for(int i=0; i<locationCells.length; i++){ // 맞춘 횟수 확인하는 반복문
			if(guess == locationCells[i]){
				result = "hit";
				numOfHits++;
				break;
			}
		}
		
		if(numOfHits == locationCells.length){ 
			result = "kill";
		}
		
		System.out.println(result);
		
		return result;
	}
}


public class SimpleDotComTestDrive {
	public static void main(String[] args) {
		
		int numOfGuesses = 0; // 사용자 추측 횟수 초기화
		GameHelper helper = new GameHelper(); 
			
		SimpleDotCom theDotCom = new SimpleDotCom(); // 닷컴 객체 생성
		int randomNum = (int)(Math.random()*5); // 난수 써서 셀 위치 배열
			
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations); // 닷컴 위치 지정
		boolean isAlive = true;
			
		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
		
	}
}

```


# 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다 #

**162p 닷컴 게임:첫번째 옵션** _구현후 주석달기_

```

package DotCom1;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0)
				return null;
		}catch(IOException e){
			System.out.println("IOException: " + e);
		}
		
		return inputLine;
	}
}


public class SimpleDotCom1 {
    int[] locationCells;
    boolean[] hitCells; // 새로운 행렬 설정
    int numOfHits = 0;
    
    public void setLocationCells(int[] locs) {
    	locationCells = locs;
    }
    
    public void setHitCells(boolean[] hits) {
    	hitCells = hits;
    }
    
    public String checkYourself (String stringGuess) {
    	int guess = Integer.parseInt(stringGuess);
    	String result = "miss";
    	
    	for(int i = 0; i < locationCells.length; i++) {
    		if ((guess == locationCells[i])) {
    			if (hitCells[i] == true)
    				break; // 맞췄을 때 빠져나오기
            	result = "hit";
            	numOfHits++;
            	hitCells[i] = true; // 맞았으면 true로 바뀜.
            	break;
            }
    	}
    	
    	if (numOfHits == locationCells.length) {
    		result = "kill";
    	}
    	
    	System.out.println(result);
    	
    	return result;
    }
}


public class SimpleDotCom1TestDrive {
	public static void main(String[] args) {
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
			
		SimpleDotCom1 theDotCom1 = new SimpleDotCom1();
		int randomNum = (int)(Math.random()*5);
			
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom1.setLocationCells(locations);
		boolean[] hits = {false, false, false}; // 초기값 설정
		theDotCom1.setHitCells(hits); // 새로운 배열 추가
		boolean isAlive = true;
			
		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom1.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}

```

**163p 닷컴 게임:두번째 옵션** _구현후 주석달기_

```

package DotCom2;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0)
				return null;
		}catch(IOException e){
			System.out.println("IOException: " + e);
		}
		
		return inputLine;
	}
}


public class SimpleDotCom2 {
    int[] locationCells;
    int numOfHits = 0;
    
    public void setLocationCells(int[] locs) {
    	locationCells = locs;
    }
    
    public String checkYourself (String stringGuess) {
    	int guess = Integer.parseInt(stringGuess);
    	String result = "miss";
    	
    	for(int i = 0; i < locationCells.length; i++) {
    		if ((guess == locationCells[i])) {
            	result = "hit";
            	numOfHits++;
            	locationCells[i] = -1; // 값을 -1로 바꿈
            	break;
            }
    	}
    	
    	if (numOfHits == locationCells.length) {
    		result = "kill";
    	}
    	
    	System.out.println(result);
    	
    	return result;
    }
}


public class SimpleDotCom2TestDrive {
	public static void main(String[] args) {
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
			
		SimpleDotCom2 theDotCom2 = new SimpleDotCom2();
		int randomNum = (int)(Math.random()*5);
			
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom2.setLocationCells(locations);
		boolean isAlive = true;
			
		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom2.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}

```

**173p 닷컴 게임:세번째 옵션** _구현후 주석달기_

```

package DotCom3;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0)
				return null;
		}catch(IOException e){
			System.out.println("IOException: " + e);
		}
		
		return inputLine;
	}
}


import java.util.ArrayList;

public class SimpleDotCom3 {
	private ArrayList<String> locationCells;
    
    public void setLocationCells(ArrayList<String> loc) {
            locationCells = loc;
    }
    
    public String checkYourself (String userInput) {
    	String result = "miss";
    	int index = locationCells.indexOf(userInput);
    	
    	if (index >= 0) {
    		locationCells.remove(index);
    		if (locationCells.isEmpty()) {
    			result = "kill";
    		}else{
    			result = "hit";
    		}
    	} 
    	
    	System.out.println(result);
    	return result;
    }
}


import java.util.ArrayList;

public class SimpleDotCom3TestDrive {
	public static void main(String[] args){
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
                
		SimpleDotCom3 theDotCom3 = new SimpleDotCom3();
		int randomNum = (int) (Math.random() * 5);
                
		ArrayList<String> locations = new ArrayList();
		locations.add(String.valueOf(randomNum));
		locations.add(String.valueOf(randomNum+1));
		locations.add(String.valueOf(randomNum+2));
        theDotCom3.setLocationCells(locations);
        boolean isAlive = true;
                
        while(isAlive == true) {
        	String guess = helper.getUserInput("enter a number");
        	String result = theDotCom3.checkYourself(guess);
        	numOfGuesses++;
        	if(result.equals("kill")) {
        		isAlive = false;
        		System.out.println(numOfGuesses + " guesses");
        	}
        }
    }
}

```

**174p 진짜 닷컴 게임** _구현후 주석달기_

```

package DotCom;

import java.io.*;
import java.util.*;

public class GameHelper {
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int[] grid = new int[gridSize];
	private int comCount = 0;
	
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		
		try{
			BufferedReader is = new BufferedReader(
			new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()==0)
				return null;
		}catch(IOException e){
			System.out.println("OException: " + e);
		}
		
		return inputLine.toLowerCase();
	}
	
	public ArrayList<String> placeDotCom(int comSize){
		ArrayList<String> alphaCells = new ArrayList<String>(); // 'f6'과 같은 좌표가 들어감
		String temp = null; // 나중에 연결하기 위한 임시 String 배열
		int[] coords = new int[comSize]; // 현재 후보 좌표
		int attempts = 0; // 시도 횟수를 세기 위한 카운터
		boolean success = false; // 적당한 위치를 찾았는지 표시하기 위한 플래그
		int location = 0; // 현재 시작 위치
		
		comCount++; // n번째 닷컴
		int incr = 1; // 수평 방향으로 증가시킬 값 설정
		if((comCount%2)==1){ // 홀수 번째 닷컴인 경우(수직으로 배치)
			incr = gridLength; // 수직 방향으로 증가시킬 값 설정
		}
		
		while(!success & attempts<200){ // 주 검색 순환문(32)
			location = (int)(Math.random()*gridSize); // 임의 시작 위치를 구함
			int x = 0; // 위치시킬 닷컴의 n번째 위치
			success = true; // 성공할 것으로 가정함
			while(success && x<comSize){ // 닷컴이 들어갈 자리가 비었는지 확인
				if(grid[location]==0){
					coords[x++] = location; // 위치 저장
					location += incr; // 다음 칸 확인
					if(location>=gridSize){ // 경계를 벗어난 경우
						success = false; // 실패
					}
					if(x>0 & (location % gridLength==0)){ // 경계를 벗어난 경우(오른쪽)
						success = false; // 실패
					}
				}else{ // 이미 사용 중인 경우
					success = false; // 실패
				}
			}
		} // while문 끝
		
		int x = 0; // 위치를 알파벳 좌표로 바꿈
		int row = 0;
		int column = 0;
		
		while(x<comSize){
			grid[coords[x]] = 1; // 기본 그리드 좌표를 '사용 중'으로 표시
			row = (int)(coords[x]/gridLength); // 행 값을 구함
			column = coords[x]%gridLength; // 열 값을 구함
			temp = String.valueOf(alphabet.charAt(column)); // 숫자된 열을 알파벳으로 구함
			
			alphaCells.add(temp.concat(Integer.toString(row)));
			x++;
		}
		
		return alphaCells;
	}
}


import java.util.*;

public class DotComBust { // 사용 변수 초기화
	private GameHelper helper = new GameHelper();
	private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>(); // DotCom객체로 이루어진 ArrayList 만들기
	private int numOfGuesses = 0;
	
	private void setUpGame(){ // 닷컴 객체 몇 개를 만들고 위치 지정
		DotCom one = new DotCom();
		one.setName("Pets.com");
		DotCom two = new DotCom();
		two.setName("eToys.com");
		DotCom three = new DotCom();
		three.setName("Go2.com");
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three);

		System.out.println("Your goal is to sink three dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in the fewest number of guesses"); // 게임 방법 설명
		
		for (DotCom dotComToSet : dotComsList){ // 닷컴 반복
			ArrayList<String> newLocation = helper.placeDotCom(3); // 보조 메소드 호출
			dotComToSet.setLocationCells(newLocation); 
		} // for문 끝
	} // setUpGame 메소드 끝
	
	private void startPlaying(){
		while(!dotComsList.isEmpty()){
			String userGuess = helper.getUserInput("Enter a guess");
			checkUserGuess(userGuess);
		} // while문 끝
		
		finishGame();
	} // setUpGame 메소드 끝
	
	private void checkUserGuess(String userGuess){
		numOfGuesses++; // 사용자 추측 횟수 증가
		String result = "miss";
		
		for(DotCom dotComToTest : dotComsList){ // 모든 닷컴 객체에 대해 반복
			result = dotComToTest.checkYourself(userGuess); 
			if(result.equals("hit"))
				break;
			if(result.equals("kill")){
				dotComsList.remove(dotComToTest);
				break;
			}
		} // for문 끝
		
		System.out.println(result);
	} // 메소드 끝
	
	private void finishGame(){
		System.out.println("All Dot Coms are dead! Your stock is now worthless");
		if(numOfGuesses<=18){
			System.out.println("It only took you " + numOfGuesses + " guesses.");
			System.out.println("You got out before your options sank");
		}else{
			System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
			System.out.println("Fish are dancing with your options");
		}
	}
	
	public static void main (String[] args){
		DotComBust game = new DotComBust(); // 게임 객체 만들기
		game.setUpGame();
		game.startPlaying();
	} // 메소드 끝
}


import java.util.*;

public class DotCom {
	private ArrayList<String> locationCells;
	private String name;
	
	public void setLocationCells(ArrayList loc){ // 닷컴 위치 갱신 세터 메소드
		locationCells = loc;
	}
	
	public void setName(String n){ // 세터 메소드
		name = n;
	}
	
	public String checkYourself(String userInput){
		String status = "miss";
		int index = locationCells.indexOf(userInput);
		
		if(index>=0){
			locationCells.remove(index); 
			if(locationCells.isEmpty()){ // 모든 위치를 맞췄는지 확인
				status = "kill";
				System.out.println("Ouch! You sunk " + name + "   :  ("); // 닷컴이 가라앉을 때
			}else{
				status = "hit";
			}
		} // if문
		
		return status;
	} // 메소드 끝
} // 클래스 끝

```


# 07. 객체마을에서의 더 나은 삶:미래를 준비합시다 #

**199p~ 상속과 다형성** _요약_

  * 상속: 공통적인 코드를 어떤 클래스에 넣은 다음, 다른 더 구체적인 클래스에 공통적인 클래스가 상위클래스라는 것을 알려주는 것.

  * 다형성: 상위클래스로 선언된 레퍼런스를 이용하여 하위클래스 객체를 참조하는 것.

**208p 클래스 계층 구조** _클래스로 구현_

```

public class Animal {
        String picture;
        boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise(){
        }
        
        void eat(boolean food){
        }
        
        void sleep(){
        }
        
        void roam(){
        }
}

class Feline extends Animal{
        void roam(){
        }
}

class Lion extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Tiger extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Cat extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Hippo extends Animal{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Canine extends Animal{
        void roam(){
        }
}

class Wolf extends Canine{
        void makeNoise(){
        }

        void eat(boolean food){
        }
}

class Dog extends Canine{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

```

**224p 오버라이드와 오버로딩** _요약_

  * 오버라이드: 상위 클래스의 메소드를 하위 클래스에서 상속받아 재정의하는 것.

  * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것.

**227p 컴파일러가 되어봅시다** _구현후 주석달기_

```

// 정답은 1번.
public class MonsterTestDrive {
	public static void main(String[] args) {
		
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();

		for(int x=0; x<3; x++){
			ma[x].frighten(x);
		}

	}
}

class Monster{
	boolean frighten(int d){
		System.out.println("arrrgh");
		return true;
	}
} // 세 번째 줄 결과가 "arrrgh"출력이고, frighten() 메소드가 오버라이드 된 형태이므로

class Vampire extends Monster{
	boolean frighten(int x){
		System.out.println("a bite?");
		return false;
	}
} // 첫 번째 줄 결과가 "a bite?"출력이고, frighten() 메소드를 오버라이드한 형태

class Dragon extends Monster{
	boolean frighten(int degree){
		System.out.println("breath fire");
		return true;
	}
}

```


# 08. 심각한 다형성:추상 클래스와 인터페이스 #

**231p~ 심각한 다형성** _요약_

  * 인터페이스: 100% 추상 클래스(인스턴스를 만들 수 없는 클래스), 서로 다른 클래스간의 공통 부분을 정의할 때 사용하며 인터페이스를 상속받는 클래스에서 메소드를 세부적으로 구현 가능.

  * 다형성: 상위클래스 유형을 메소드의 인자나 리턴 유형 또는 배열 유형을 쓸 수 있게 만드는 능력 필요. 추상 메소드, 추상 클래스를 통해 이룸.

  * 추상 클래스: 반드시 확장해야하는 클래스, 추상 메소드 혹은 구상 메소드를 가질 수 있음.

  * 추상 메소드: 반드시 오버라이드해야하는 메소드, 하위클래스에서 프로토콜을 정의할 수 있음.

  * 다중 상속: 여러 상위클래스에서 상속받는 것.


# 09. 객체의 삶과 죽음:생성자와 메모리 관리 #

**269p~ 객체의 삶과 죽음** _요약_

  * 힙에서의 변수: 모든 객체 가능.

  * 스택에서의 변수: 지역 변수, 객체 레퍼런스 변수.

  * 생성자: 객체를 생성할 때 실행되는 코드가 들어있음. 즉, 어떤 클래스 유형에 대해 new 키워드를 사용했을 대 실행되는 코드가 들어있음.

  * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException이 생김.

**298p 집중토론** _요약_

  * 인스턴스 변수: 클래스 내에서 선언한 것, 각각의 개별 객체가 가지고 있는 필드를 나타냄.

  * 지역 변수: 스택 변수, 메소드 안에서 선언한 것, 메소드 매개변수도 포함.

**302p 5분 미스터리** _구현후 주석달기_

```

import java.util.*;

class V2Radiator{
	V2Radiator(ArrayList list){
		for(int x=0; x<5; x++){
			list.add(new SimUnit("V2Radiator"));
		}	
	}
}

class V3Radiator{ //불필요한 상속을 제거
	V3Radiator(ArrayList lglist){ //super(lglist) 삭제
		for(int g=0; g<10; g++){
			lglist.add(new SimUnit("V3Radiator"));
		}
	}
}

class RetentionBot{
	RetentionBot(ArrayList rlist){
		rlist.add(new SimUnit("Retention"));
	}
}

public class TestLifeSupportSim {
	public static void main(String[] args) {
		ArrayList aList = new ArrayList();
		V2Radiator v2 = new V2Radiator(aList);
		V3Radiator v3 = new V3Radiator(aList);
		
		for(int z=0; z<20; z++){
			RetentionBot ret = new RetentionBot(aList);
		}
	}
}

class SimUnit{
	String botType;
	
	SimUnit(String type){
		botType = type;
	}
	
	int powerUse(){
		if("Retention".equals(botType)){
			System.out.println("2 energy"); // 에너지 소모량 표현
			return 2;
		} else{
			System.out.println("4 energy");
			return 4;
		}
	}
}

// 상속을 제거해야 사라가 의도한 대로 결과를 얻음

```


# 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계 #

**307p~ 숫자** _요약_

  * 정적 메소드: 인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않은 경우.

  * 정적 메소드를 선언하는 방법: static이라는 키워드 사용.

  * static final: 선언된 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지. 변수를 상수로 지정하는 유일한 방법.

  * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스.

  * 오토 박싱: 자바 5.0부터 도입됨. 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능.

  * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 타이핑을 더 적게 하기 위해 사용.

**339p Calendar** _구현후 주석달기_

```

import java.util.*;

public class Calender {
	public static void main(String[] args) {
		Calendar c = Calendar.getInstance();
		c.set(2004,0,7,15,40); // 시각 설정
		long day1 = c.getTimeInMillis(); // 시간을 밀리초 단위로 표현한 값 리턴
		day1 += 1000*60*60;
		
                c.setTimeInMillis(day1); // 시각 갱신
		System.out.println("new hour " + c.get(c.HOUR_OF_DAY));
		
                c.add(c.DATE, 35); // 35일 뒤
		System.out.println("add 35 days " + c.getTime());
		
                c.roll(c.DATE, 35); // 35일 뒤
		System.out.println("roll 35 days " + c.getTime());
		
                c.set(c.DATE, 1); // 날짜를 1로 설정
		System.out.println("set to 1 " + c.getTime());
	}
}

```

**342p 집중토론** _요약_

  * 인스턴스 변수: 정적 변수가 프로시저 위졸 생각할 때 쓰는 것이므로 좋지 않다.

  * 정적 변수: 상수, API에 다수 존재, Color클래스, System.out클래스 등에 사용됨.

**344p 컴파일러가 되어봅시다** _구현후 주석달기_

```

class StaticSuper{
	static{
		System.out.println("super static block");
	}
	
	StaticSuper(){ // 메소드이므로 "()"표시 필요
		System.out.println("super constructor");
	}
}

public class StaticTests extends StaticSuper{
	static int rand;
	
	static{
		rand = (int)(Math.random()*6);
		System.out.println("static block " + rand);
	}
	
	StaticTests(){
		System.out.println("constructor");
	}
	
	public static void main(String[] args) {
		System.out.println("in main");
		StaticTests st = new StaticTests();
	}
}

```


# 11. 위험한 행동:예외처리 #

**357p try/catch** _구현후 주석달기_

```

public class Exception {
	public static void main(String[] args) {
		// 일련의 과정
		
		public void takeRisk() throws BadException{ // 외부에 BadException 던질 수 있다는 것을 알림
			if(abandonAllHope){
				throw new BadException(); // 새로운 Exception객체 던짐
			}
		}
		
		public void crossFigners(){
			try{
				anObject.takeRisk();
			}catch(BadException ex){
				System.out.println("Aaargh!");
				ex.printStackTrace(); // 예외 상황을 해결할 수 없을 때 스택 트레이스를 출력
			}
		}
	}
}

```

**376p~ 첫번째 사운드 애플리케이션** _구현후 주석달기_

```

import javax.sound.midi.*; // 미디 패키지 불러오기

public class MiniMiniMusicApp {
	public static void main(String[] args) {
		MiniMiniMusicApp mini = new MiniMiniMusicApp();
		mini.play();
	}
	
	public void play(){
		try{
			Sequencer player = MidiSystem.getSequencer(); // Sequencer 받아오기
			player.open();
			
			Sequence seq = new Sequence(Sequence.PPQ, 4); 
			
			Track track = seq.createTrack(); // Sequence에 Track 요청
			
			// Track에 미디 이벤트 집어넣기
			ShortMessage a = new ShortMessage();
			a.setMessage(144, 1, 44, 100);
			MidiEvent noteOn = new MidiEvent(a, 1);
			track.add(noteOn);
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128, 1, 44, 100);
			MidiEvent noteoff = new MidiEvent(b, 16);
			track.add(noteoff); 
			
			player.setSequence(seq); // Sequencer에 Sequence 보내기
			
			player.start(); // Sequencer의 start() 메소드 호출
		} catch(Exception ex){
			ex.printStackTrace();
		}
	}
}

```

**380p~ 두번째 사운드 애플리케이션** _구현후 주석달기_

```

import javax.sound.midi.*;

public class MiniMusicCmdLine {
	public static void main(String[] args) {
		MiniMusicCmdLine mini = new MiniMusicCmdLine();
		
		if(args.length<2){
			System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
		} else{
			int instrument = Integer.parseInt(args[0]); // 악기 설정
			int note = Integer.parseInt(args[1]); // 음 높이 설정
			mini.play(instrument, note);
		}
	}
	
	public void play(int instrument, int note){
		try{
			Sequencer player = MidiSystem.getSequencer(); // Sequencer 받아오기
			player.open();
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack(); // Sequence에 Track 요청
			
			// 무엇, 언제할지 결정
			MidiEvent event = null;
			
			ShortMessage first = new ShortMessage();
			first.setMessage(192, 1, instrument, 0);
			MidiEvent changeInstrument = new MidiEvent(first, 1);
			track.add(changeInstrument);
			
			// Track에 미디 이벤트 집어넣기
			ShortMessage a = new ShortMessage();
			a.setMessage(144, 1, note, 100);
			MidiEvent noteOn = new MidiEvent(a, 1);
			track.add(noteOn);
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128, 1, note, 100);
			MidiEvent noteOff = new MidiEvent(b, 16);
			track.add(noteOff);
			player.setSequence(seq); // Sequencer에 Sequence 보내기
			
			player.start(); // Sequencer의 start() 메소드 호출
		} catch(Exception ex){
			ex.printStackTrace();
		}
	}
}

```


# 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개 #

**389p~ 첫번째 GUI:버튼** _구현후 주석달기_

```

import javax.swing.*; // 스윙 패키지 선언

public class SimpleGui1 {
	public static void main(String[] args) {
		JFrame frame = new JFrame(); // 프레임 버튼 만들기
		JButton button = new JButton("click me");
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 창을 닫았을 때 프로그램 바로 종료
		frame.getContentPane().add(button); // 버튼 추가
		frame.setSize(300, 300); // 프레임 크기 지정
		frame.setVisible(true); // 마지막으로 화면에 표시
	}
}

```

**394p~ ActionEvent** _구현후 주석달기_

```

package SimpleGui1B;
import javax.swing.*;
import java.awt.event.*; // event 패키지 선언

public class SimpleGui1B implements ActionListener { // 인터페이스 구현
	JButton button;
	
	public static void main(String[] args) {
		SimpleGui1B gui = new SimpleGui1B();
		gui.go();
	}
	
	public void go(){
		JFrame frame = new JFrame();
		button = new JButton("click me");
		
		button.addActionListener(this); // 버튼에 등록(인자가 ActionListener를 구현한 클래스의 객체
		
		frame.getContentPane().add(button);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300, 300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event){ // 실제 이벤트 처리 메소드
		button.setText("I've been clicked!"); // 버튼에서는 이 메소드를 호출하여 이벤트가 일어났다는 것을 알려줌
	}
}

```

**405p 버튼과 원의색** _구현후 주석달기_

```

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {
	JFrame frame;
	
	public static void main(String[] args) {
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
	}
	
	public void go(){
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton button = new JButton("Change colors");
		button.addActionListener(this); // 리스너를 버튼에 추가
		
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, button); // 위젯 추가
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.setSize(300, 300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event){
		frame.repaint(); // 버튼을 클릭했을 때 프레임의 repaint() 메소드 호출
	}

}

class MyDrawPanel extends JPanel{ // 그래디언트의 시작과 끝 색을 무작위로 지정
	public void paintComponent(Graphics g){
		Graphics2D g2d = (Graphics2D) g; 
		
		int red = (int)(Math.random()*256);
		int green = (int)(Math.random()*256);
		int blue = (int)(Math.random()*256);
		Color startColor = new Color(red, green, blue);
		
		red = (int)(Math.random()*256);
		green = (int)(Math.random()*256);
		blue = (int)(Math.random()*256);
		Color endColor = new Color(red, green, blue);
		
		GradientPaint gradient = new GradientPaint(70, 70, startColor, 150, 150, endColor);
		g2d.setPaint(gradient); // 그래디언트 지정
		g2d.fillOval(70, 70, 100, 100);
	}
}

```

**413p 두개의 버튼과 원의색** _구현후 주석달기_

```

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButtons { // ActionListener를 구현하지 않음
	JFrame frame; 
	JLabel label; 
	
	public static void main(String args[]){
		TwoButtons gui = new TwoButtons();
		gui.go();
	}
	
	public void go(){
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton labelButton = new JButton ("Change Label"); // 버튼의 리스너 등록 메소드에 내부 클래스로 만든 객체 전달
        labelButton.addActionListener(new LabelListener());

        JButton colorButton = new JButton ("Change Circle"); 
        colorButton.addActionListener(new ColorListener());

        label = new JLabel("I'm a lebel");
        MyDrawPanel drawPanel = new MyDrawPanel();
        
        frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
        frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
        frame.getContentPane().add(BorderLayout.EAST, labelButton);
        frame.getContentPane().add(BorderLayout.WEST, label);

        frame.setSize(300,300);
        frame.setVisible(true);
    }
	
	class LabelListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			label.setText("Ouch!"); // label 변수 사용
		}
	} // 내부 클래스 끝
	
	class ColorListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			frame.repaint(); // 내부 클래스에서는 frame 인스턴스 변수를 사용
		}
	} // 내부 클래스 끝
}

```

**418p 간단한 애니메이션** _구현후 주석달기_

```

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
	int x = 70;
	int y = 70; // 메인 클래스에 원의 좌표 저장 위한 인스턴스 변수 두 개 생성
	
	public static void main(String[] args) {
		SimpleAnimation gui = new SimpleAnimation();
		gui.go();
	}

	public void go(){
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		MyDrawPanel drawPanel = new MyDrawPanel(); 
		
		frame.getContentPane().add(drawPanel);
		frame.setSize(300, 300);
		frame.setVisible(true);
		
		for(int i=0; i<130; i++){ // 130번 반복
			x++;
			y++; // x 와 y 좌표 증가
			
			drawPanel.repaint(); 
			
			try{
				Thread.sleep(50); // 속도를 약간 줄임
			}catch(Exception ex){}
		}
	} // go() 메소드 끝
	
	class MyDrawPanel extends JPanel{
		public void paintComponent(Graphics g){
			g.setColor(Color.green);
			g.fillOval(x, y, 40, 40);
		}
	} // 내부 클래스 끝
} // 외부 클래스 끝

```

**420p 뮤직 비디오** _구현후 주석달기_

```

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {
	static JFrame f = new JFrame("My First Music Video");
	static MyDrawPanel m1;
	
	public static void main(String[] args) {
		MiniMusicPlayer3 mini = new MiniMusicPlayer3();
		mini.go();
	} // 메소드 끝
	
	public void setUpGui(){
		m1 = new MyDrawPanel();
		f.setContentPane(m1);
		f.setBounds(30, 30, 300, 300);
		f.setVisible(true);
	} // 메소드 끝
	
	public void go(){
		setUpGui();
		
		try{ // 음악 재생 코드
			Sequencer sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequencer.addControllerEventListener(m1, new int[] {127});
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack();
			
			int r = 0;
			
			for(int i=0; i<60; i+=4){
				r = (int)((Math.random()*50)+1);
				track.add(makeEvent(144, 1, r, 100, i));
				track.add(makeEvent(176, 1, 127, 0, i));
				track.add(makeEvent(128, 1, r, 100, i+2));
			} // 순환문 끝
			
			sequencer.setSequence(seq);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch(Exception ex){
			ex.printStackTrace();
		}
	} // 메소드 끝
	
	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
		MidiEvent event = null;
		
		try{
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);
		}catch(Exception e){}
		
		return event;
	} // 메소드 끝
	
	class MyDrawPanel extends JPanel implements ControllerEventListener{
		boolean msg = false;
		
		public void controlChange(ShortMessage event){
			msg = true; // 이벤트 받았으므로
			repaint();
		}
		
		public void paintComponent(Graphics g){
			if(msg){ // controlEvent때만 다시 그림
				Graphics2D g2 = (Graphics2D) g;
				
				int r = (int) (Math.random()*250);
				int gr = (int) (Math.random()*250);
				int b = (int) (Math.random()*250);

				g.setColor(new Color(r, gr, b));
				
				int ht = (int)((Math.random()*120)+10);
				int width = (int)((Math.random()*120)+10);
				
				int x = (int)((Math.random()*40)+10);
				int y = (int)((Math.random()*40)+10);

				g.fillRect(x, y, ht, width);
				msg = false;
			} // if문 끝
		} // 메소드 끝
	} // 내부 클래스 끝
} // 외부 클래스 끝

```


# 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소 #

**452p 비트박스 프로그램** _구현후 주석달기_

```

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {
	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;
	
	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", "Open Hi-Hat", "Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", "Open Hi Conga"}; // GUI레이블 만들 때 사용할 악기명 String 배열로 저장
	int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};  // 실제 드럼 '건반'을 나타냄
	
	public static void main(String [] args){
		new BeatBox().buildGUI();
	}
	
	public void buildGUI(){
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간
		
		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);
		
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);
		
		JButton stop = new JButton("Stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);
		
		JButton upTempo = new JButton("upTempo");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo, "upTempo");
		
		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo, "downTempo");
		
		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for(int i=0; i<16; i++){
			nameBox.add(new Label(instrumentNames[i]));
		}
		
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);
		
		theFrame.getContentPane().add(background);
		
		GridLayout grid = new GridLayout(16,16); 
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER,mainPanel);
		
		for(int i=0;i<256;i++){
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		} // 순환문 끝
		
		setUpMidi();
		
		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);      
	} // buildGUI 메소드 끝
	
	public void setUpMidi(){ // 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드
		try{
			sequencer= MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){
			e.printStackTrace();
		}
	} // setUpMidi 메소드 끝
	
	public void buildTrackAndStart(){
		int [] trackList = null; // 각 악기의 열여섯 박자에 대한 값을 원소가 16개인 배열에 저장
		
		sequence.deleteTrack(track); // 기존 트랙을 제거하고 트랙을 새로 만듭니다.
		track = sequence.createTrack();
		
		for(int i = 0; i< 16; i++){ // 열 16개 모두에 대해 같은 작업을 처리
			trackList = new int[16];
			int key = instruments[i]; // 어떤 악기인지 나타내는 건반 번호 설정
			for(int j = 0; j<16 ; j ++){ // 모든 박자에 대해 같은 작업 반복
				JCheckBox jc = checkboxList.get(j + (16*i));
				if(jc.isSelected()){
					trackList[j] = key;
				}else{
					trackList[j] = 0;
				}
			} // 안쪽 for문 끝
			
			makeTracks(trackList);
			track.add(makeEvent(176, 1, 127, 0, 16));
		} // 바깥쪽 for문 끝
		
		track.add(makeEvent(192, 9, 1, 0, 15));
		try{
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){
			e.printStackTrace();
		}
	} // buildTrackAndStart 메소드 끝
	
	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			buildTrackAndStart();
		}
	} // 내부 클래스 끝
	
	public class MyStopListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			sequencer.stop();
		}
	} // 내부 클래스 끝
	
	public class MyUpTempoListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * 1.03));
		}
	} // 내부 클래스 끝
        
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor* .97));
		}
	} // 내부 클래스 끝
	
	public void makeTracks(int [] list){ // 한 악기의 16박자 전체에 대해 이벤트를 생성
		for(int i=0;i<16;i++){
			int key = list[i];
			if(key!=0){
				track.add(makeEvent(144, 9, key, 100, i)); // Note On과 Note Off 이벤트 만들고, 트랙에 추가       
				track.add(makeEvent(128, 9, key, 100, i+1));
			}
		}
	}
	
	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
		MidiEvent event = null;
		try{
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return event;
	}
} // 클래스 끝

```


# 14. 객체 저장:직렬화와 입출력 #

**496p 비트박스 프로그램** _구현후 주석달기_

```

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class BeatBox {
	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;
	
	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", "Open Hi-Hat", "Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", "Open Hi Conga"}; // GUI레이블 만들 때 사용할 악기명 String 배열로 저장
	int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};  // 실제 드럼 '건반'을 나타냄
	
	public static void main(String [] args){
		new BeatBox().buildGUI();
	}
	
	public void buildGUI(){
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간
		
		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);
		
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);
		
		JButton stop = new JButton("Stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);
		
		JButton upTempo = new JButton("upTempo");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo, "upTempo");
		
		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo, "downTempo");
		
		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for(int i=0; i<16; i++){
			nameBox.add(new Label(instrumentNames[i]));
		}
		
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);
		
		theFrame.getContentPane().add(background);
		
		GridLayout grid = new GridLayout(16,16); 
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER,mainPanel);
		
		for(int i=0;i<256;i++){
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		} // 순환문 끝
		
		setUpMidi();
		
		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);      
	}// buildGUI 메소드 끝
	
	public void setUpMidi(){ // 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드
		try{
			sequencer= MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){
			e.printStackTrace();
		}
	} // setUpMidi 메소드 끝
	
	public void buildTrackAndStart(){
		int [] trackList = null; // 각 악기의 열여섯 박자에 대한 값을 원소가 16개인 배열에 저장
		
		sequence.deleteTrack(track); // 기존 트랙을 제거하고 트랙을 새로 만듭니다.
		track = sequence.createTrack();
		
		for(int i = 0; i< 16; i++){ // 열 16개 모두에 대해 같은 작업을 처리
			trackList = new int[16];
			int key = instruments[i]; // 어떤 악기인지 나타내는 건반 번호 설정
			for(int j = 0; j<16 ; j ++){ // 모든 박자에 대해 같은 작업 반복
				JCheckBox jc = checkboxList.get(j + (16*i));
				if(jc.isSelected()){
					trackList[j] = key;
				}else{
					trackList[j] = 0;
				}
			} // 안쪽 for문 끝
			
			makeTracks(trackList);
			track.add(makeEvent(176, 1, 127, 0, 16));
		} // 바깥쪽 for문 끝
		
		track.add(makeEvent(192, 9, 1, 0, 15));
		try{
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){
			e.printStackTrace();
		}
	} // buildTrackAndStart 메소드 끝
	
	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			buildTrackAndStart();
		}
	} // 내부 클래스 끝
	
	public class MyStopListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			sequencer.stop();
		}
	} // 내부 클래스 끝
	
	public class MyUpTempoListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * 1.03));
		}
	} // 내부 클래스 끝
        
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor* .97));
		}
	} // 내부 클래스 끝
	
	public class MySendListener implements ActionListener {
		public void actionPerformed(ActionEvent a) { // 사용자가 버튼을 클릭해서 ActionEvent가 발생된 경우
			boolean[] checkboxState = new boolean[256]; 
			
			for (int i = 0; i < 256; i++){
				JCheckBox check = (JCheckBox) checkboxList.get(i); // 체크박스에 추가
				if (check.isSelected()){
					checkboxState[i] = true;
				}
			}
			
			try{
				FileOutputStream fileStream = new FileOutputStream(
	                  new File("Checkbox.ser"));
				ObjectOutputStream os = new ObjectOutputStream(fileStream);
				os.writeObject(checkboxState);
			}catch(Exception ex){
				ex.printStackTrace();
			}
		} // 메소드 끝
	} // 클래스  끝
	
	public class MyReadInListener implements ActionListener { // 비트박스 프로그램 패턴 복구 구현
		public void actionPerformed(ActionEvent a){
			boolean[] checkboxState = null;
			try{
				FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
				ObjectInputStream is = new ObjectInputStream(fileIn);
				checkboxState = (boolean[])is.readObject();
			}catch(Exception ex){
				ex.printStackTrace();
			}
			
			for(int i = 0; i<256; i++){
				JCheckBox check = (JCheckBox) checkboxList.get(i);
				if(checkboxState[i]){
					check.setSelected(true);
				}else{
					check.setSelected(false);
				}
			}
            
			sequencer.stop();
			buildTrackAndStart(); // 시퀀스 재구성
		} // 메소드 끝
	} // 내부 클래스 끝
	
	public void makeTracks(int [] list){ // 한 악기의 16박자 전체에 대해 이벤트를 생성
		for(int i=0;i<16;i++){
			int key = list[i];
			if(key!=0){
				track.add(makeEvent(144, 9, key, 100, i)); // Note On과 Note Off 이벤트 만들고, 트랙에 추가       
				track.add(makeEvent(128, 9, key, 100, i+1));
			}
		}
	}
	
	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
		MidiEvent event = null;
		try{
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);
		}catch(Exception e){
			e.printStackTrace();
		}
		
		return event;
	}
} // 클래스 끝

```