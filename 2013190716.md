

# 01. 껍질을 깨고:간단한 소개 #

**48p BeerSong** _문제해결하기, 주석달기_

```

public class beer {
        public static void main (String[] args) {
                int beerNum=99;
                String word="bottles"; //복수형

        while (beerNum>0) {

        if(beerNum==1) {
                word="bottle"; //단수형(한 병인 경우)
                        

        System.out.println(beerNum + " " + word + " of beer on the wall");
        System.out.println(beerNum + " " + word + " of beer.");
        System.out.println("Take one down.");
        System.out.println("Pass it around.");
        beerNum = beerNum - 1;

        if (beerNum<=0) {
                System.out.println("No more bottles of beer on the wall");
        } //else문 끝
        } //while순환문 끝
} //main클래스 끝
} //클래스 끝


```

**50p PhraseOMatic** _wordListOne, wordListTwo, wordListThree를 변경_

```

public class PhraseOMatic {
	public static void main (String[] args) {

		String[] wordListOne = {"nice", "awesome", "good", "cool", "gorgeous"};

		String[] wordListTwo = {"Korean", "American", "Chinese", "Spanish", "Japanese", "Taiwan"};
		String[] wordListThree = {"food", "clothes", "culture", "drink"};

		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;

		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);

		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

		System.out.println("I like " + phrase);
	}
}

```

**52p 집중토론** _요약_

  * 자바 가상 머신:프로그램을 실행시킨다./바이트코드 컴파일러를 사용한다./보안 관련 작업을 처리한다.
  * 컴파일러:파일을 준다./여러 문제를 미리 감지하고 프로그램 실행 도중에 문제가 생기는 것을 방지해준다./접근 위반을 방지한다.

**55p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A
class Exercise1b {
	public static void main(String [] args) {
		int x = 1;
		while(x < 10) {
			if(x > 3){
				System.out.println("big x");
			}
		x = x+1; 
		}
	}
}

B
class Exercise1b {
	public static void main(String [] args) {
		int x = 5;
		while(x > 1) {
			x = x-1;
			if(x < 3) {
				System.out.println("small x");
			}
		}
	}
}

C
class Exercise1b {
	public static void main(String [] args) {
		int x = 5;
		while(x > 1) {
			x = x-1;
			if(x < 3) {
				System.out.println("small x");
			}
		}
	}
}

```


# 02. 객체마을로의 여행:객체에 대해 알아봅시다 #

**68p~ 클래스** _요약_

  * 인스턴스 변수:객체에서 자신에 대해 아는 것을 인스턴스 변수라고 한다. 인스턴스 변수는 객체의 상태(데이터)를 나타내며 그 유형에 속하는 각 객체마다 값이 다르다.
  * 메소드:객체에서 할 수 있는 일을 메소드라고 부른다. 객체를 설계할 때는 객체에서 알아야 할 데이터 뿐 아니라 그 데이터에 대해 어떤 일을 처리하는 메소드에 대해서도 생각해봐야 한다.
  * 클래스:클래스는 객체를 만들기 위한 청사진이다. 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할을 한다. 클래스로부터 만들어진 각 개체는 클래스의 인스턴스 변수용으로 쓰기 위한 변수를 가질 수 있다.
  * 테스트용 클래스:새로운 클래스 유형의 객체에 있는 메소드와 변수를 테스트해본다.


**68p Television** _채워넣기_

  * 인스턴스 변수:채널, 음량
  * 메소드:채널 변경, 음량 조절, 전원 on/off


**72p GuessGame** _게임에 참여하는 사람 수를 4명으로 변경_

```
1. GuessGame.java
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
	p1 = new Player();
	p2 = new Player();
	p3 = new Player();
	p4 = new Player();

	int guessp1 = 0;
	int guessp2 = 0;
	int guessp3 = 0;
	int guessp4 = 0;

	boolean p1isRight = false;
	boolean p2isRight = false;
	boolean p3isRight = false;
	boolean p4isRight = false;

	int targetNumber = (int) (Math.random() * 10);
	System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

	while(true) {
	System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

	p1.guess();
	p2.guess();
	p3.guess();
	p4.guess();

	guessp1 = p1.number;
	System.out.println("1번 선수가 찍은 숫자: " + guessp1);

	guessp2 = p2.number;
	System.out.println("2번 선수가 찍은 숫자: " + guessp1);

	guessp1 = p3.number;
	System.out.println("3번 선수가 찍은 숫자: " + guessp1);

	guessp1 = p4.number;
	System.out.println("4번 선수가 찍은 숫자: " + guessp1);

	if (guessp1 == targetNumber) {
	p1isRight = true;
	}

	if (guessp2 == targetNumber) {
	p2isRight = true;
	}

	if (guessp3 == targetNumber) {
	p3isRight = true;
	}

	if (guessp4 == targetNumber) {
	p4isRight = true;
	}

	if (p1isRight || p2isRight || p3isRight || p4isRight) {

	System.out.println("맞춘 선수가 있습니다.");
	System.out.println("1번 선수: " +p1isRight);
	System.out.println("2번 선수: " +p2isRight);
	System.out.println("3번 선수: " +p3isRight);
	System.out.println("4번 선수: " +p4isRight);
	System.out.println("게임 끝.");
	break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.

	} else {
	//아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
	System.out.println("다시 시도해야 합니다.");
	} // if/else 부분 끝
	}//순환문 끝
	}//메소드 끝
}//클래스 끝





2. Player.java
public class Player {
	int number = 0; //찍은 숫자를 저장할 변수

public void guess() {
	number = (int) (Math.random() * 10);
	System.out.println("찍은 숫자: " + number);
	}
}





3. GameLauncher.java
public class GameLauncher {
	public static void main (String[] args) {
	GuessGame game = new GuessGame();
	game.startGame();
	}
}

```

**76p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A-1 TapeDeck
class TapeDeck {
	boolean canRecord = false;

	void playTape() {
	System.out.println("tape playing");
	}

	void recordTape() {
	System.out.println("tape recording");
	}
}


A-2 TapeDeckTestDrive
class TapeDeckTestDrive {
	public static void main(String [] args) {

	t.canRecord = true;
	t.playTape();

	if(t.canRecord== true) {
	t.recordTape();
	}
	}
}


B-1 DVDPlayer
class DVDPlayer {

	boolean canRecord = false;

	void recordDVD() {
	System.out.println("DVD recording");
	}
}


B-2 DVDPlayerTestDrive
class DVDPlayerTestDrive {
	public static void main(String [] args) {

	DVDPlayer d = new DVDPlayer();
	d.canRecord = true;
	d.playDVD();

	if (d.canRecord == true) {
	d.recordDVD();
	}
	}
}


```

# 03. 네 변수를알라:원시 변수와 레퍼런스 #

**83p~ 변수** _요약_

  * 원시변수 vs 레퍼런스변수:

원시변수:원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다.

레퍼런스변수:객체에대한 레퍼런스가 들어간다.

**96p Dog** _수많은 개를 만들어 난장판 만들기_

```

class Dog {
	String name;
	public static void main (String[] args) {
	Dog dog1 = new Dog();
	dog1.bark;
	dog1.name = "Bart";

	Dog[] myDogs = new Dog[3];
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;

	myDogs[0].name = "Fred";
	myDogs[1].name = "Marge";

	System.out.print("Last dog' name: ");
	System.out.println(myDogs[2].name);

	int x = 0;
	while(x < myDogs.length) {
	myDogs[x].bark();
	x = x + 1;
	}
}

	public void bark() {
	System.out.println(name + "barks Wal!");
	}
	public void eat() { }
	public void chaseCat() { }
}


```

**97p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A
class Books {
        String title;
        String author;
}

class BooksTestDrive {
        public static void main(String [] args) {

        Books [] myBooks = new Books[3];

        // Book을 집어 넣어야합니다.
        myBooks[0] = new Books();
        myBooks[1] = new Books();
        myBooks[2] = new Books();

        myBooks[0].title = "The Grapes of Java";
        myBooks[1].title = "The Java Gatsby";
        myBooks[2].title = "The Java Cookbook";
        myBooks[0].author = "bob";
        myBooks[1].author = "sue";
        myBooks[2].author = "ian";

        int x = 0;
        while(x<3) {
                System.out.print(myBooks[x].title);
                System.out.print(" by ");
                System.out.println(myBooks[x].author);
                x=x+1;
                }
        }
}


                 
B
class Hobbits {

        String name;

        public static void main(String [] args) {

                Hobbits [] h = new Hobbits[3];
                int z = 0;

                while (z < 3) { // z=3일 때 while문을 빠져나옵니다.

                h[z] = new Hobbits();
                h[z].name = "bilbo";
                if (z == 1) {
                  h[z].name = "frodo";
                }
                if (z == 2) {
                  h[z].name = "sam";
                }
                System.out.print(h[z].name + " is a ");
                System.out.println("good Hobbit name");

                z = z+1; // while문 끝에서 z의 값이 1씩 증가해야합니다.
                }
        }
}

```

**101p 레퍼런스 도용사건** _요약_

  * 누가 이겼나요?:밥
  * 문제가 된 부분은 어딘가요?:켄트의 메소드에서는 순환문을 돌 때 마다 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버려지는 문제점이 있다.

# 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향 #

**105p~ 객체** _요약_

  * 캡슐화:객체의 인스턴스 변수 주변에 방어막 같은 것을 만들어서 부적절한 방법으로 인스턴스 변수를 초기화 하는 것을 방지해준다.
  * 게터와 세터:게터는 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰이고, 세터는 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
  * 인스턴스 변수 vs 지역 변수:

인스턴스 변수

인스턴스 변수는 초기 값이 모두 o이나 NULL false로 자동으로 초기화된다.

지역 변수

지역 변수는 메소드 내에서 선언된다. 지역 변수에는 기본값이 없어서 지역 변수를 사용하기 전에는 반드시 초기화해야한다.

**107p Dog** _실행_

```

class Dog {
        int size;
        String name;

        void bark(){
                if(size>60){
                        System.out.println("Wooof! Wooof!");
                }else if(size>14){
                        System.out.println("Ruff! Ruff!");
                }else{
                        System.out.println("Yip! Yip!");
                }
        }

}
public class DogTestDrive{

        public static void main(String[]args){

                Dog one=new Dog();
                one.size=70;
                Dog two=new Dog();
                two.size=8;
                Dog three=new Dog();
                three.size=35;
                one.bark();
                two.bark();
                three.bark();

        }
}

```

**122p 컴파일러가 되어봅시다** _구현후 주석달기_

```

A:

class XCopy {

        public static void main(String[] args) {
                int orig=42;
                XCopy x=new XCopy();
                int y= x.go(orig); 
                System.out.println(orig+""+y);
        }

        int go(int arg){
                arg=arg*2;
                return arg;
        }
}


B:

class Clock{
        String time;
        void setTime(String t){
                time=t;
        }
        String getTime(){
                return time;
        }
}

class ClockTestDrive {

        public static void main(String[] args) {
                Clock c= new Clock();
                c.setTime("1245");
                String tod=c.getTime();
                System.out.println("time:"+tod);
        }

}

```


# 05. 메소드를 더 강력하게:흐름 제어, 연산 등 #

**135p XP** _요약_

  * 익스트림 프로그래밍이란?
Before starting method code, make assistance code to test method. Making a test code is one of a ground rule as making the code easier. The pros of this XP is that you can easily change the spec if the client wants to change the code.

**137p~ 간단한 닷컴 게임** _구현후 주석달기_

```

public class SimpleDotCom {

        int[] locationCells;
        int numOfHits = 0 ;
        
        public void setLocationCells (int[] locs){
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess){
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ; i < locationCells.length; i++){
                        if (guess == locationCells[i]) {
                                result = "hit";
                                numOfHits++;
                                break;
                        }
                }
                
                if (numOfHits == locationCells.length){
                        result = "kill";
                }
                System.out.println(result) ;
                        return result ;
        }
}


public class SimpleDotComGame {

        public static void main(String[] args) {
                int numOfGuesses = 0 ; //
                GameHelper helper = new GameHelper(); 
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                
                int randomNum = (int)(Math.random()*5);
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};

                theDotCom.setLocationCells(locations);//using array
                boolean isAlive = true ;
                
                while (isAlive == true){//if it is live, start repetition
                        String guess = helper.getUserInput("enter a number");
                        
                        String result = theDotCom.checkYourself(guess);
                        
                        numOfGuesses++;
                        //guess number increase
                        if (result.equals("kill")){
                                isAlive = false ;
                                
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        }/
}



import java.io.*;
public class GameHelper {
        public String getUserInput(String prompt){
                String inputLine = null ;
                System.out.print(prompt + " ") ;
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length()== 0) return null;
                } catch(IOException e){
                        System.out.println("IOException: " + e);
                }
                return inputLine;
        }
}


```

# 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다 #

**162p 닷컴 게임:첫번째 옵션** _구현후 주석달기_

```

import java.io.*;

class GameHelper {

        public String getUserInput (String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");

                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length() == 0) return null;
                } catch(IOException e){
                        System.out.println("IOException: " + e);
                }

                return inputLine;
        }

}

public class SimpleDotComTestDrive {

        public static void main(String[] args){


                int numOfGuesses=0;

                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5);

                int[] locations = {randomNum, randomNum+1, randomNum+2};

                boolean[] hitCells = new boolean[3];

                theDotCom.sethitCells(hitCells);

                theDotCom.setLocationCells(locations);

                boolean isAlive = true;

                while(isAlive == true){
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;
                        if(result.equals("kill")){
                                isAlive = false;
                                System.out.println(numOfGuesses + "guesses");
                        }

                }
        }

}


class SimpleDotCom {

        int[] locationCells;
        boolean[] hitCells = new boolean[3];

        int numOfHits = 0;

        public void setLocationCells(int[] locs){

                locationCells = locs;
        }

        public void sethitCells(boolean[] check){ 
                hitCells = check;
        }


        public String checkYourself(String stringGuess){

                int guess = Integer.parseInt(stringGuess);

                String result = "miss";

                for(int i = 0; i < locationCells.length; i++){

                        if(guess == locationCells[i] && hitCells[i]!=true){ 
                                result = "hit";
                                numOfHits++;
                                hitCells[i] = true;
                                break;

                        }

                }

                if (numOfHits == locationCells.length){
                        result = "kill";
                }

                System.out.println(result);
                return result;

        }

}

```

**163p 닷컴 게임:두번째 옵션** _구현후 주석달기_

```

import java.io.*;

class GameHelper {

        public String getUserInput (String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");

                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length() == 0) return null;
                } catch(IOException e){
                        System.out.println("IOException: " + e);
                }

                return inputLine;
        }

}

public class SimpleDotComTestDrive { 

        public static void main(String[] args){


                int numOfGuesses=0;

                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5);

                int[] locations = {randomNum, randomNum+1, randomNum+2};

                theDotCom.setLocationCells(locations);

                boolean isAlive = true;

                while(isAlive == true){
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;
                        if(result.equals("kill")){
                                isAlive = false;
                                System.out.println(numOfGuesses + "guesses");
                        }

                }
        }

}


class SimpleDotCom { 

        int[] locationCells;


        int numOfHits = 0;

        public void setLocationCells(int[] locs){

                locationCells = locs;
        }

        public String checkYourself(String stringGuess){

                int guess = Integer.parseInt(stringGuess);

                String result = "miss";

                for(int i = 0; i < locationCells.length; i++){

                        if(guess == locationCells[i] && locationCells[i]!=-1){ 
                                result = "hit";
                                numOfHits++;
                                locationCells[i]=-1;
                                break;

                        }

                }

                if (numOfHits == locationCells.length){
                        result = "kill";
                }

                System.out.println(result);
                return result;

        }

}

```

**173p 닷컴 게임:세번째 옵션** _구현후 주석달기_

```

import java.util.ArrayList;

public class DotCom
{
     private ArrayList<String> locationCells;

     public void setLocationCells(ArrayList<String>loc)
    {
         locationCells = loc;
     }
 
     public String checkYourself(String userInput)
    {
          String result = "miss";
  
          int index = locationCells.indexOf(userInput);
  
          if(index >= 0)
          {
                locationCells.remove(userInput);

              if(locationCells.isEmpty())
             {
                   result = "Kill";
             }
             else
             {
                   result = "hit";
              }
         } 
         return result;
    } 
} 

```

**174p 진짜 닷컴 게임** _구현후 주석달기_

```

import java.io.*;
import java.util.*;

class GameHelper{ // GameHelper 클래스 선언.
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int [] grid = new int[gridSize];
        private int comCount = 0;
        public String getUserInput(String prompt)
                        throws IOException{
                String inputLine = null;
                System.out.print(prompt + " ");
                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length()==0)
                                return null;
                        }catch(IOException e) {
                                System.out.println("OException: " + e);
                                }
                return inputLine.toLowerCase();
                }
        
        public ArrayList<String>placeDotCom(int comSize){
                ArrayList<String> alphaCells = new ArrayList<String>(); 
        String [] alphacoords = new String[comSize];
        String temp = null;                // 나중에 연결하기 위한 임시 String 배열을 생성
        int [] coords = new int[comSize];                // 현재 후보 좌표
        .                int attempts = 0;                // 시도 횟수를 세기위한 카운터
        boolean success = false;                // 적당한 위치를 찾았는지 표시하기 위한 플래그
        int location = 0;                // 현재 시작 위치를 0으로 설정
        comCount++;     
        int incr = 1;  // 수직방향으로 증가시킬 값을 설정
        if ((comCount % 2) == 1)                         // 홀수 번째 닷컴인 경우(수직으로 배치)  
                {
                        incr = gridLength; // 수직 방향으로 증가시킬 값을 설정
                }
        while ( !success & attempts++ < 200)             
        {
                        location = (int) (Math.random() * gridSize);  // 임의의 시작위치를 정한다
                        System.out.print("try" + location);                        int x = 0;                      
                        success = true;                      
                        while (success && x < comSize)                              
                                {
                                if (grid[location] == 0)
                                }
                                {
                                        coords[x++] = location;                                      
                                                {
                                                success = false;
                                                }
                                        if (x>0 & (location % gridLength == 0))                 
                                        {
                                                success = false;
                                                // 실패
                                                }
                                        } else {
                                                System.out.print("used "+location);
                                                success = false;
                                                //실패 
                                                }
                                        } 
        }
        
        int x = 0;                // 위치를 알파벳 좌표로 바꾼다
        int row = 0; 
        int column = 0;        
        System.out.println(" |n");     
        while (x < comSize)       
        {                    
                grid[coords[x]] = 1;                        // 기본 그리드 좌표를 사용
                row = (int) (coords[x] / gridLength);                        // 행 값을 구한다   
                column = coords[x] % gridLength;                        // 열 값을 구함          
                temp = String.valueOf(alphabet.charAt(column));                        // 숫자로 된 열을 알파벳으로 변환
                alphaCells.add(temp.concat         
                                (Integer.toString(row)));   
                x++;              
                System.out.print(" coord " + x + " = " +   
                alphaCells.get(x-1));                        // 닷컴의 위치를 알려주는 코드
                }               
        System.out.println(" d2|n?");      
        return alphaCells;  
        }
}

class DotCom{       
        private ArrayList<String> locationCells;  
        private String name;        // DotCom의 인스턴스 변수 
        // - 셀위치가 들어있는 ArrayList     
        //  - DotCom의 이름    
        public void setLocationCells(ArrayList<String> loc)       
        {       
                locationCells = loc;   
                }        // DotCom의 위치를 갱신하는 세터 메소드
        // placeDotCom()메소드에서 제공하는 무작위로 만든 위치 
        public void setname(String n) 
        {            
                name = n;  
                }        // 기초적인 세터 메소드  
        public String checkYourself(String userInput)    
        {                
                String status = "miss";   
                int index = locationCells.indexOf(userInput);                /* ArrayList의 indexOf()메소드를 쓰고 있습니다. 사용자가 추측한                  위치가 ArrayList에 들어있으면 indexOf()에서 그 항목의 인덱스를 리턴합니다.                 그렇지 않으면 -1을 리턴 */
                if(index >=0)          
                {                    
                        locationCells.remove(index);                        // ArrayList의 remove메소드를  써서 그 항목을 지운다   
                        if (locationCells.isEmpty())                                // isEmpty()메소드를 써서 모든 위치를 맞췄는지 확인  
                    {                          
                                status = "kill";                     
                                System.out.println("Ouch! You sunk" +   name + " : ( ");       
                                // 닷컴이 가라 앉았음을 알려준다        
                                }else {                 
                                        status = "hit"; 
                                        }              
                        } // if문 종료.              
                return status;       
                // 'miss','hit'또는 'kill'을 리턴합니다.
                } // method 종료.} // class 종료
        
        class DotComBust {        // 사용할 변수를 선언하고 초기화    
                private GameHelper helper;  
                private ArrayList<DotCom> dotComsList;   
                private int numOfGuesses;        /* DotCom객체로 이루어진  ArrayList를 만듭니다.   
                     (즉, DotCom[]이 DotCom객체들이 들어있는 배열을 뜻하는 것과         마찬가지로 ArrayList (DotCom)을 DotCom객체들이 들어 있는 ArrayList라고 생각하면 됨) */ 
                public DotComBust()  {
                        helper = new GameHelper();  
                        dotComsList = new ArrayList<DotCom>();   
                        numOfGuesses = 0;  
                        }   
                private void setUpGame()        // 우선 닷컴 객체 몇 개를 만들고 위치 지정   
                {             
                        DotCom one = new DotCom();    
                        one.setname("Pets.com");         
                        DotCom two = new DotCom();   
                        two.setname("eToys.com");        
                        DotCom three = new DotCom();    
                        three.setname("Go2.com");             
                        dotComsList.add(one);          
                        dotComsList.add(two);             
                        dotComsList.add(three);    
                        // DotCom 객체 세개를 만들고, 각각 이름을 부여하고 ArrayList에 저장
                        System.out.println("Your goal is to sink three " +  "dot coms.");   
                        System.out.println("Pets.com, eToys.com, Go2.com");    
                        System.out.println("Try to sink them all in " +  "the fewest number of guesses");  
                        // 사용자에게 간단한 게임 방법 설명          
                        for (DotCom dotComToset : dotComsList)              
                                // 목록에 있는 각 DotCom에 대해 반복        
                                {             
                                ArrayList<String> newLocation = helper.placeDotCom(3);  
                                // DotCom의 위치를 지정하기 위한 보조 메소드 호출합니다.    
                                dotComToset.setLocationCells(newLocation);      
                                // 이 DotCom 객체의 세터메소드를 호출하여 방금 보조 메소드에서 받아온 위치를 지정  
                                } // for문 종료.     
                        } // setUpgame method 종료.    
                private void startPlaying() throws IOException       
                {             
                        while (!dotComsList.isEmpty())                        // DotCom목록이 비어있지 않으면 (1은 부정(NOT)을 의미한다. dotComList.isEmpty() == false와 동일)  
                                {                 
                                String userGuess       
                                = helper.getUserInput("Enter a guess");   
                                // 사용자 입력을 받습니다             
                                checkUserGuess(userGuess);          
                                // checkUserGuess 메소드를 호출     
                                } // while문 종료.             
                        finishGame();             
                        // finishGame() 메소드를 호출
        } // startPlaying method 종료.
                private void checkUserGuess(String userGuess) 
                {
                        numOfGuesses++;        
                        // 사용자가 추측한 횟수 증가        
                        String result = "miss";          
                        // 따로 바꾸지 않으면miss라고 가정
                        for (DotCom dotComToTest : dotComsList) 
                                // 목록에 들어있는모든 DotCom객체에 대해 반복
                                {                   
                                result = dotComToTest.checkYourself(userGuess);  
                                // DotCom 객체에 사용자가 입력한 위치가 맞는지 그 객체가 죽었는지 물어봅니다.      
                                if (result.equals("hit"))                
                                {                       
                                        break;                      
                                        // 순환문에서 일찍빠져나옵니다. 더 이상 확인하지 않아도 됩니다.   
                                        } 
                                if (result.equals("kill")) 
                                {  
                                        dotComsList.remove(dotComToTest); 
                        break;                    
                                }      
                                }             
                        System.out.println(result);           
                        }  
                private void finishGame()     
                {            
                        System.out.println("All Dots are dead! Your " + "stock is now worthless");      
                        if (numOfGuesses<=18)      
                        {                     
                                System.out.println("It only took you" +  numOfGuesses + "Guesses.");   
                                System.out.println("You got out before your  " +  "  options sank");    
                                }else {         
                                        System.out.println("Took you long enough. " +  numOfGuesses + "guess.");     
                                        System.out.println("Fish are dancing with " +  " your options");           
                                        } // 게임결과를 알려주는 메시지 출력  
                        } 
        
        public static void main(String[] args)throws IOException{ // 메인클래스 선언         
                        DotComBust game = new DotComBust();         
                        game.setUpGame();        
                        game.startPlaying();        
                } 

```

# 07. 객체마을에서의 더 나은 삶:미래를 준비합시다 #

**199p~ 상속과 다형성** _요약_

  * 상속:부모 클래스가 자식 클래스에게 멤버필드와 메소드를 물려줌
  * 미다형성:하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것 즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것을 의미

**208p 클래스 계층 구조** _클래스로 구현_

```

public class Animal{
 char picture;
 int food,boudaries,location;
 boolean hunger;
 void makenoise(){
 }
 void eat(){
 }
 void sleep(){
 }
 void roam(){
 }
}

class Feline extends Animal{
 void roam(){
 }
}

class Hippo extends Animal{
 void makeNoise(){
 }
 void eat(){
 }
}

class Lion extends Feline{
 void makeNoise(){
 }
 void eat(){
 }
}

class Tiger extends Feline{
 void makeNoise(){
 }
 void eat(){
 }
}

class Cat extends Feline{
 void makeNoise(){
 }
 void eat(){
 }
}


class Canine extends Animal{
 void roam(){
 }
}
class Wolf extends Canine{
 void makeNoise(){
 }
 void eat(){
 }
}
class Dog extends Canine{
 void makeNoise(){
 }
 void eat(){
 }
}

```

**224p 오버라이드와 오버로딩** _요약_

  * 오버라이드:부모 클래스와 자식 클래스가 상속관계에 있을 경우 부모로부터 물려받은 메소드를 자식 클래스에 맞게 재정의하여 사용하는 것
  * 오버로딩:하나의 클래스 안에서 식별자가 같은 메소드를 만들 수 있는 규칙

**227p 컴파일러가 되어봅시다** _구현후 주석달기_

```

public class MonsterTestDrive {
        public static void main(String [] args) {
                Monster [] ma = new Monster[3];
                ma[0]= new Vampire();
                ma[1]= new Dragon();
                ma[2]= new Monster();
                
                for(int x=0; x<3; x++) {
                        ma[x].frighten(x);
                }
        }
}

class Monster {
        boolean frighten(int d) {
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster {
        boolean frighten(int x) {
                System.out.println("a bite?");
                return false;
        }
}

class Dragon extends Monster {
        boolean frighten(int degree) {
                System.out.println("breath fire");
                return true;
        }
}

```

# 08. 심각한 다형성:추상 클래스와 인터페이스 #

**231p~ 심각한 다형성** _요약_

  * 인터페이스:추상클래스, 즉 인스턴스를 만들 수없는 클래스
  * 다형성:부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다. 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가할 때 코드를 굳이 바꿀 필요가 없다.
  * 추상 클래스:상속 관계에 있는 클래스 중에서 상위 클래스에서는 특별한 구현 없이 사용하고자 하는 메소드만 기술하고 구체적인 구현은 하위 클래스에서 하도록 할 수 있습니다.
  * 추상 메소드:부모클래스에서 메소드명 앞에 abstract(추상)이라고 붙이기만 하고 실제로 메소드 내의 선언문(statement)내용이 없는 것을 추상메소드라고 합니다. 부모클래스(parentclass)를 상속 받은 자식클래스(subclass)에서는 반드시 이 추상메소드에 대해서 메소드를 정의해야 합니다.
  * 다중 상속:두개 이상의 부모클래스에서 상속 받는 것
# 09. 객체의 삶과 죽음:생성자와 메모리 관리 #

**269p~ 객체의 삶과 죽음** _요약_

  * 힙에서의 변수:힙은 모든 객체가 사는 곳으로, 인스턴스 변수는 객체 안에 들어있습니다.
  * 스택에서의 변수:객체 레퍼런스 변수도 지역 변수라면 스택에 저장됩니다. 모든 지역 변수는 스택에 들어있으며 그 변수를 선언한 메소드에 해당하는 프레임 안에 들어있습니다.
  * 생성자:객체 지향 프로그래밍(OOP:objective-oriented programming)에서 쓰이는 객체 초기화 함수. 객체의 생성 시에만 호출되어 메모리 생성과 동시에 객체의 데이터를 초기화하는 역할을 한다.
  * 널 레퍼런스:'아무것도 가리키지 않는다 - 주소값이 없다'는 뜻입니다.

**298p 집중토론** _요약_

  * 인스턴스 변수:객체 지향 프로그래밍(OOP)에서, 어떤 등급의 하나의 인스턴스인 객체에 관련(결합)된 변수. 등급이 어느 변수를 정의하면 그 등급에 속하는 각 인스턴스는 그 변수 자신의 카피를 갖는 것이 된다.
  * 지역 변수: 프로그램 언어에 있어서 변수가 어떤 블록(block) 내에서만 선언되지 않을 때에는 다른 블록에 그것을 사용하는 것은 불가능하며, 프로그램 내 전체에 걸쳐 사용할 수 없다. 이것은 그 변수가 지역적인 것이며, 프로그램 전체에 대하여 정의되어 있지 않기 때문이다. 이러한 변수를 지역 변수라 한다.

**302p 5분 미스터리** _구현후 주석달기_

```

import java.util.*;
class V2Radiator
{
        V2Radiator(ArrayList<SimUnit> list)
        {
                for(int x = 5; x < 5 ; x++)
                {
                        list.add(new SimUnit("V2Radiator"));
                }
        }
}

class V3Radiator //extends V2Radiator
{
        V3Radiator(ArrayList<SimUnit> lglist)
        {
                //super(lglist);
                for(int g = 0; g < 10 ; g++)
                {
                        lglist.add(new SimUnit("V3Radiator"));
                }
        }
}

class RetentionBot
{
        RetentionBot(ArrayList<SimUnit> rlist)
        {
                rlist.add(new SimUnit("Rention"));
        }
}

public class TestLifeSupportSim 
{
        public static void main(String[] args)
        {
                ArrayList<SimUnit> aList = new ArrayList<SimUnit>();
                V2Radiator v2 = new V2Radiator(aList);
                V3Radiator v3 = new V3Radiator(aList);
                for(int z = 0 ; z < 20 ; z++)
                {
                        RetentionBot ret = new RetentionBot(aList);
                }
        }
}

class SimUnit
{
        String botType;
        SimUnit(String type)
        {
                botType = type;
        }
        int powerUse()
        {
                if("Retention".equals(botType))
                {
                        return 2;                       
                }
                else
                {
                        return 4;
                }
        }
}

```

# 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계 #

**307p~ 숫자** _요약_

  * 정적 메소드:정적 메소드는 클래스 종속적인 메소드를 말합니다. 클래스에 선언되어 있지만 인스턴스를 만들때 포함되지 않습니다. 또한 메모리에 로드되는 시점도 비정적 메소드와 달리 프로그램이 실행되어 시작되기 바로전에 모두 메모리에 로드됩니다. 어떤 메소드가 실행이 되려면 메모리에 우선 로드되어야 하는데 위에서 설명한 차이로 인해 정적메소드는 인스턴스 생성을 하지 않고도 클래스명을 사용하여 바로 실행이 가능합니다.
  * 정적 메소드를 선언하는 방법:
  * static final:static-객체 생성을 안하고 사용 가능하다./final-오버라이딩이 되지 않으므로 내용을 바꾸지 못하도록 하는 기능이 있다.
  * 널 레퍼런스:'아무것도 가리키지 않는다-주소값이 없다'는 뜻입니다.
  * 오토 박싱:'기본자료형 -> 래퍼클래스' or '래퍼클래스 -> 기본자료형'
  * 정적 임포트:static import를 사용하면 다른 클래스의 static멤버를 클래스 이름없이 사용할 수 있다.

**339p Calendar** _구현후 주석달기_

```

import java.util.*;
public class Calender{
        public static void main(String[] args){
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40);
                   long day1 = c.getTimeInMillis(); 
                   day1 += 1000*60*60;
                c.setTimeInMillis(day1); 
                System.out.println("new hour " + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35);
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35);
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1);
                   System.out.println("set to 1 " + c.getTime());
}
}

```

**342p 집중토론** _요약_

  * 인스턴스 변수:정적변수는 상수에 불과한 것으로 객체지향적이지 않다. 프로시저 위주의 프로그래밍이다.
  * 지역 변수:클래스당 하나씩 있어서 메모리가 절약된다. 한 클래스에 속하는 모든 인스턴스에 의해 공유된다.

**344p 컴파일러가 되어봅시다** _구현후 주석달기_

```

class StaticSuper{ 
        static{
                System.out.println("super static block");
        }
        StaticSuper(){ 
                System.out.println("super constructor");
        }
}

public class StaticTests extends StaticSuper { 
        static int rand;
        static{
                rand=(int)(Math.random()*6);
                System.out.println("static block"+rand);
        }
        StaticTests(){
                System.out.println("constructor");
        }
        public static void main(String[]args){
                System.out.println("in main");
        }
        StaticTests st=new StaticTests(); 
}

```

# 11. 위험한 행동:예외처리 #

**357p try/catch** _구현후 주석달기_

```

public class Test
{

        public static void main()
        {
                
        
        public void takeRisk() throws BadException
        {
                if(abandonAllHope)
                {
                        throw new BadException();
                }
        }
        
        public void crossFingers()
        {
                try
                {
                        anObject.takeRisk();
                }
                catch(BadException ex)
                {
                        System.out.println("Aaargh!");
                        ex.printStackTrace();
                }
        }
        
        }
}

```

**376p~ 첫번째 사운드 애플리케이션** _구현후 주석달기_

```

import javax.sound.midi.*;

public class MiniMiniMusicApp
{
        public static void main(String[] args)
        {
                MiniMiniMusicApp mini = new MiniMiniMusicApp();
                mini.play();
        }
        
        public void play()
        {
                try
                {
                        Sequencer player = MidiSystem.getSequencer();
                        player.open();
                        
                        Sequence seq = new Sequence(Sequence.PPQ, 4);
                        
                        Track track = seq.createTrack();
                        
                        ShortMessage a = new ShortMessage();
                        a.setMessage(144, 1, 44, 100);
                        MidiEvent noteOn = new MidiEvent(a, 1);
                        track.add(noteOn);
                        
                        ShortMessage b = new ShortMessage();
                        b.setMessage(128, 1, 44, 100);
                        MidiEvent noteOff = new MidiEvent(b, 16);
                        track.add(noteOff);
                        
                        player.setSequence(seq);
                        
                        player.start();
                        
                }
                catch(Exception ex)
                {
                        ex.printStackTrace();
                        
                }
                
        }
}

```

**380p~ 두번째 사운드 애플리케이션** _구현후 주석달기_

```

import javax.sound.midi.*;


public class MiniMusicCmdLine
{
        public static void main(String[] args)
        {
                MiniMusicCmdLine mini = new MiniMusicCmdLine();
                
                if(args.length < 2 )//input숫자의 개수가 2개보다 작으면
                        System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
                else
                {
                        int instrument = Integer.parseInt(args[0]);
                        int note = Integer.parseInt(args[1]);
                        mini.play(instrument,note);
                        
                }
        }
        
        public void play(int instrument, int note)
        {
                try
                {
                        Sequencer player = MidiSystem.getSequencer();
                        player.open();
                        Sequence seq = new Sequence(Sequence.PPQ,4);
                        Track track = seq.createTrack();
                        
                        MidiEvent event = null;
                        
                        ShortMessage first = new ShortMessage();
            first.setMessage(192,1,instrument,0);
            MidiEvent changeInstrument = new MidiEvent(first, 1);
            track.add(changeInstrument);

            ShortMessage a = new ShortMessage();
            a.setMessage(144,1,note,100);
            MidiEvent noteOn = new MidiEvent(a,1);
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            a.setMessage(128,1,note,100);
            MidiEvent noteOff = new MidiEvent(b,16);
            track.add(noteOff);
            player.setSequence(seq);
            player.start();
                }
                
                catch(Exception ex)
                {
                        ex.printStackTrace();
                }
        }
}

```

# 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개 #

**389p~ 첫번째 GUI:버튼** _구현후 주석달기_

```

```

**394p~ ActionEvent** _구현후 주석달기_

```

```

**405p 버튼과 원의색** _구현후 주석달기_

```

```

**413p 두개의 버튼과 원의색** _구현후 주석달기_

```

```

**418p 간단한 애니메이션** _구현후 주석달기_

```

```

**420p 뮤직 비디오** _구현후 주석달기_

```

```

# 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소 #

**452p 비트박스 프로그램** _구현후 주석달기_

```

```

# 14. 객체 저장:직렬화와 입출력 #

**496p 비트박스 프로그램** _구현후 주석달기_

```

```