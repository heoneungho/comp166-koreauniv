#summary 이현정의 실습 페이지입니다.
#labels 2013190727이현정

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong
{
        public static void main (String[] args)
        {
                int beerNum = 99;
                String word = "bottles";	// 복수형
                
                while (beerNum > 0)
                {
                        if (beerNum == 1)
                        {
                                word = "bottle";	// 단수형(한 병인 경우)
                        }
                        
                        System.out.println(beerNum + "" + word + " of beer on the wall");
                        System.out.println(beerNum + "" + word + " of beer.");
                        System.out.println("Take one down.");
                        System.out.println("Pass it around.");
                        beerNum = beerNum - 1;
                        
                        if (beerNum > 1)
                        {
                                System.out.println(beerNum + "" + word + " of beer on the wall");
                        }
                        
                        else if (beerNum == 1)
                        {
                                word = "bottle";
                                System.out.println(beerNum + "" + word + " of beer on the wall");
                        }	// 수정
                        
                        else
                        {
                                System.out.println("No more bottles of beer on the wall");      
                        }       // else 문 끝
                }       // while 순환문 끝
        }       // main 클래스 끝
}       // 클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic
{
	public static void main(String[] args)
	{
		String[] wordListOne = {"HatNim", "DalNim", "ByeolNim", "MoonSun"};
	        String[] wordListTwo = {"I", "Love", "You"};
        	String[] wordListThree = {"We", "live", "happily", "ever", "after"};

	        int oneLength = wordListOne.length;
        	int twoLength = wordListTwo.length;
	        int threeLength = wordListThree.length;

        	int rand1 = (int)(Math.random()*oneLength);
	        int rand2 = (int)(Math.random()*twoLength);
        	int rand3 = (int)(Math.random()*threeLength);

	        String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

        	System.out.println("What we need is a " + phrase);
	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행. 다른 유형의 값이 들어갈 때는 ClassCast Exception을 발생시킴. 보안 관련 작업.
 * 컴파일러: 변수에 이상한 유형의 데이터가 저장된 경우 막아줌. 비공개(private) 메소드를 호출하려고 한다거나 (보안상의 이유로) 절대 바꿔서는 안 되는 메소드를 변경하려는 것과 같은 접근 위반을 방지. 다른 클래스의 핵심적인 내용에 접근하려는 코드를 방지. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 확인. 즉 실행할 대 절대로 일어나면 안되는 일을 방지. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b
{
	public static void main (String[] args)
	{
		int x = 1;
		
		while (x < 10)
		{
			if (x > 3)
			{
				System.out.println("big x");
			}
		x = x+1 ; // 수정
		}
	}
} 

---------------------------------------------------------------------

class Small // 수정
{
	public static void main (String[] args)
	{
		int x = 5;
		
		while (x > 1)
		{
			x = x-1;
			
			if (x < 3)
			{
				System.out.pringln("small x");
			}
		}
	}
}

---------------------------------------------------------------------

class Exercise1b
{
	public static void main (String[] args) // 수정
	{	
		int x = 5;
		
		while (x > 1)
		{
			x = x-1;
			
			if (x<3)
			{
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것. 객체의 상태(데이터)를 나타내며 그 유형에 속하는 각 객체마다 값이 다름.
 * 메소드: 객체에서 자신이 하는 것.
 * 클래스: 객체를 만들기 위한 청사진. 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할을 함.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스. main() 메소드가 들어가며 그곳에서 테스트할 클래스 유형의 객체를 만들어서 접근함. 즉 새로운 클래스 유형의 객체에 들어있느 메소드와 변수를 테스트함.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Brand, Size, Resoultion 
 * 메소드: onPower(), offPower(), upVolumn(), downVolumn(), upChannel(), downChannel(), modeCable, modeVideo


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame
{
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame()
	{
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		Boolean p1isRight = false;
		Boolean p2isRight = false;
		Boolean p3isRight = false;
		Boolean p4isRight = false;
		
		int targetNumber = (int)(Math.randm()*10);
		
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while (true)
		{
			System.out.println("맞춰야 할 숫자는 "+ target Number + "입니다.");
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guess1 = p1.number;
			System.out.pringln("1번 선수가 찍은 숫자 : " + guess1);
			
			guess2 = p2.number;
			System.out.pringln("2번 선수가 찍은 숫자 : " + guess1);
			
			guess3 = p3.number;
			System.out.pringln("3번 선수가 찍은 숫자 : " + guess1);
			
			guess4 = p4.number;
			System.out.pringln("4번 선수가 찍은 숫자 : " + guess1);
			
			if (guessp1 == targetNumber)
				p1isRight = true;
			
			if (guessp2 == targetNumber)
				p2isRight = true;
			
			if (guessp3 == targetNumber)
				p3isRight = true;
			
			if (guessp4 == targetNumber)
				p4isRight = true;
			
			if (p1isRight || p2isRight || p3isRight || p4isRight)
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수 : " + correct1);
				System.out.println("2번 선수 : " + correct2);
				System.out.println("3번 선수 : " + correct3);
				System.out.println("4번 선수 : " + correct4);
				System.out.println("게임 끝.");
				
				break;
		}
		
			else
					System.out.println("다시 시도해야 합니다.");
		}
	}
}

public class Player
{
	int number = 0;

	public void guess()
	{
		number = (int)(Math.random()*10);
		System.out.println("찍은 숫자: " + number);
	}
}

public class GameLauncher
{
	public static void main (String[] args);
	{
		GuessGame game = new GuessGame();
		game.startGame();
	}
}
}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class TapeDeck
{
	boolean canRecord = false;

	void playTape()
	{
		System.out.println("tape playing");
	}

	void recordTape()
	{
		Systemp.out.println("tape recording");
	}
}

class TapeDeckTestDrive
{
	public static void main(String [] args)
	{
		Tapedeck t = new TapeDeck() // 수정

		t.canRecord = true;
		t.playTape();

		if (t.canRecord == true)
		{
			t.recordTape();
		}
	}
}

---------------------------------------------------------------------

class DVDPlayer
{
	boolean canRecord = false;

	void recordDVD()
	{
		System.out.println("DVD recording");
	}

	void playDVD()
	{
		System.out.println("DVD playing");
	} // 수정
}

class DVDPlayerTestDrive
{
	public static void main(String [] args)
	{
		DVDPlyaer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();

		if (d.canRecord == true)
		{
			d.recordDVD();
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이 들어간다. 레퍼런스 변수는 객체 레퍼런스로써 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
public class Dog
{
	String name;
	public static void main (String[] args)
	{
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
	
		
		Dog[] myDogs = new Dog[5];
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = new Dog();
		myDogs[3] = new Dog();
		myDogs[4] = dog1;
	
		
		myDogs[0].name = 'Fred';
		myDogs[1].name = 'Merge';
		myDogs[2].name = 'Orlando';
		myDogs[3].name = 'Miranda';
		myDogs[4].name = 'Fline';
		
		System.out.print("마지막 개의 이름:	");
		System.out.println(myDogs[2].name);
		
		int x = 0;
		while(x < myDogs.length)
		{
			myDogs[x].bark();
			x = x+1
		}
	}
	
	public void bark()
	{
		System.out.println(name+ "이(가) 왈!하고 짖습니다.");
	}
	public void eat() {}
	public void chaseCat() {}
}
	}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Books
{
	String title;
	String author;
}

class BooksTestDrive
{
	public static void main(String [] args)
	{
		Books [] myBooks = new Books[3];

		myBooks[0] = new Books()
		myBooks[1] = new Books()
		myBooks[2] = new Books() // 수정

		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";

		while(x < 3)
		{
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x+1;
		}
	}
]

----------------------------------------------------------------------

class Hobbits
{
	String name		

	public static void main(String [] args)
	{
		Hobbits [] h = new Hobbits[3];
		int z = 0;

		while(z < 4)
		{
			z = z+1;
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if (z == 1)
			{
				h[z].name = "frodo";
			}
			if(z == 2)
			{
				h[z].name = "sam";
			}
		}
		System.out.println(h[z].name + " is a ");
		Sysetm.out.println("good Hobbit name");

		z = z+1; // 수정
		}
	}
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 메소드에서 심각한 결점은 사용한 레퍼런스 변수 개수는 밥의 메소드에 비해 작았지만 그의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수가 없다는 문제가 있었다. 순환문을 한 바퀴 돌 때마다 그는 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버림받게 되었다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 인스턴스 변수를 부적적한 값으로 설정하지 못하게 인스턴스 변수 주변에 방어막 같은 것을 만드는 것. 모든 인스턴스 변수에 대해 세터 메소드를 만들고 다른 코드에서는 그 데이터를 절대 직접 접근할 수 없도록 반드시 세터 메소드를 사용하는 것.
 * 게터와 세터: 정식 명칭은 액세서(accessor)와 뮤테이터(mutator)이다. 게터는 단지 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 가져오고(get) 세터는 그 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하는(set) 역할을 한다.
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언된다. 메소드 내에서 선언되는 것이 아니다. 지역 변수는 메소드 내에서 선언된다. 사용하기 전에 반드시 초기화해야 한다.
 
*107p Dog* _실행_

{{{
class Dog
{
	int size;
	String name;

	void bark()
	{
		if(size > 60)
		{
			System.out.println("Wooof! Wooof!");
		}
		else if (size>14)
		{
			System.out.println("Ruff! Ruff!");
		}
		else
		{
			System.out.println("Yip! Yip!");
		}
	}
}

---------------------------------------------------------------------

class DogTestDrive
{
	public static void main (String [] args)
	{
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;

		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class XCopy
{
	public stati void main(String [] args)
	{
		int orig = 42;

		XCopy x = new XCopy();

		int y = x.go(orig);

		System.out.println(orig + "" + y);
	}

	int go(int arg)
	{
		arg = arg*2

		return arg;
	}
}

---------------------------------------------------------------------

class Clock
{
	String time;

	void setTime(String t)
	{
		time = t;
	}
	
	String getTime() // 수정
	{
		return time;
	}
}

class ClockTestDrive
{
	public static void main(String [] args)
	{
		Clock c = new Clock();

		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time: " + tod);
	}
}
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다. 일련의 규칙에는 1. 조금씩 자주 발표 2. 사이클을 반복해서 돌리면서 개발 3. 스펙에 없는 것은 절대 집어넣지 않음 4. 테스트 코드를 먼저 만듬 5. 정규 일과 시간에만 작업 6. 언제 어디서든 코드를 개선 7. 모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않음 8. 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만듬 9. 모든 일을 단순하게 처리 10. 두 명씩 팀을 편성하고 돌아가면서 작업 등이 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive
{
	public static void main (String [] args)
	{
		SimpleDotCom dot = new SimpleDotCom(); // SimpleDotCom 클래스의 인스턴스를 만듬
		int[] locations = {2, 3, 4}; // 닷컴의 위치를 나타내기 위한 int 배열을 만든다.(0에서 6까지의 숫자 가운데 연속된 정수 세 개)
		dot.setLocationCells(locations); // 닷컴에 대해 세터 메소드를 호출
		String userGuess = "2"; // 사용자가 추측한 위치 역할을 할 가짜 값을 만듬
		String result = dot.checkYourself(userGuess); // 닷컴 객체에 대해 Checkyourself() 메소드를 호출하고 그 메소드에 가짜 값을 전달
	}
}

public class SimpleDotCom
{
	int[] locationCells;
	int numOfHits = 0;

	public void setLocationsCells(int[] locs)
	{
		locationCells = locs;
	}

	public Sring checkYourself(String stringGuess)
	{
		int guess = Integer.parseint(StringGuess); // String을 int로 변환
		String result = "miss" // 리턴할 결과를 저장할 변수를 만듬
		for(int i = 0; i < locationCells.length; i++) // 배열에 들어있는 각 원소에 대해 반복
		{
			if (guess == locationCells[i]) // 사용자가 추측한 값을 배열에 들어있는 원소와 비교
			{
				result = "hit"
				numOfHits++;
				break; // 순환문을 빠져나옴
			}
		}

		if (numOfHits == locationCells.length)
		{
			result = "kill"; // 순환문 밖으로 나와서 그 객체가 죽었는지확인해보고 그 경우에는 result라는 String을 "kill"로 바꿈
		}
		System.out.println(result); // 사용자에게 결과를 보여줌
			return result; // 이 메소드를 호출한 메소드로 결과를 리턴함
		}
	}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive1 { // 배열을 하나 더 만들고 사용자가 위치를 맞출 때마다 그 맞춘 위치를 두 번째 배열에 집어넣음. 사용자가 위치를 맞출 때마다 그 배열을 확인하여 그 셀을 이미 맞췄는지 확인
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0; 
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};
                theDotCom.setLocationCells(locations); 

                boolean[] checks = {false, false, false}; // 배열의 값을 모두 false로 설정
                theDotCom.setcheckCells(checks);  

                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

public class SimpleDotCom1 {
        
        int[] locationCells;
        int numOfHits = 0; 

        boolean[] checkCells; // 체크된 셀을 확인하기 위한 boolean형의 배열 선언
        
        public void setLocationCells (int[] locs) {
                
                locationCells = locs;
        }

        public void setcheckCells (int[] checks) { 
                
                checkCells = checks;
        }

        public String checkYourself (String stringGuess) {
                
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss";

                for(int i = 0 ;i < locationCells.length ; i++) {
                        if(guess == locationCells[i]) {

                                if(checkCells[i] == true)  
                                        break;

                                result = "hit";  
                                numOfHits++;

                                checkCells[i] = true; // 배열의 특정 인덱스에 '참(true)'이 들어있으면 다른 배역(locationCells)의 그 인덱스에 해당하는 셀 위치를 이미 맞췄음을 알 수 있음

                                break;
                                
                        }
                }
                
                if(numOfHits == locationCells.length) { 
                        result = "kill";
                }
                System.out.println(result); 
                return result; 
        }       
}

import java.io.*;
public class GameHelper1 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive2 { // 원래 배열을 그냥 사용하면서 맞춘 셀의 값은 모두 -1로 바꿈. 굳이 배열 두 개를 쓰지 않아도 됨.
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0;  
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};
                theDotCom.setLocationCells(locations); 
                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

public class SimpleDotCom2 {
        
        int[] locationCells;
        int numOfHits = 0; 
        
        public void setLocationCells (int[] locs) {
                
                locationCells = locs;
        }

        public String checkYourself (String stringGuess) {
                
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss";

                for(int i = 0 ;i < locationCells.length ; i++) {
                        if(guess == locationCells[i]) {
                                result = "hit";  
                                
                                locationCells[i] = -1; // 특정 셀 위치에 -1이 들어있으면 그 셀을 이미 맞췄음을 알 수 있음. 따라서 배열에서 음이 아닌 숫자만 찾으면 됨.
                                                       
                                numOfHits++;
                                break;
                
                        }
                }
                
                if(numOfHits == locationCells.length) { 
                        result = "kill";
                }
                System.out.println(result); 
                return result; 
        }
}

import java.io.*;
public class GameHelper2 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

import java.util.ArrayList; 

public class SimpleDotComTestDrive3 { // 맞출 때마다 각 셀 위치를 삭제하고 배열을더 작게 고침. 하지만 배열의 크기를 바꿀 수가 없기 대문에 새로운 배열을 만들고, 이전 배열에 남아있는 셀을 복사하고 새로 만든 작은 배열로 옮김.
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0;  
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                ArrayList<String> locations = new ArrayList();
                location.add(String.valueOf(randomNum)); // ArrayList에 추가된 space에 임의의 숫자값이 삽입됨
                location.add(String.valueOf(randomNum+1));
                location.add(String.valueOf(randomNum+2));                                      

                theDotCom.setLocationCells(locations); 
                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

import java.util.ArrayList;

public class SimpleDotCom3 {
                private ArrayList<String> locationCells;
                
        public void setLocationCells (ArrayList<String> locs) {
                
                locationCells = locs;
        }

        public String checkYourself (String stringGuess) {
                
                int index = locationCells.indexof(stringGuess); // indexOf(Object)하게되면 Object가 들어있는 index의 수를 return
                String result = "miss";
        
                if(index >= 0)
                {
                        locationCells.remove(index);
                        if(locationCells.isEmpty())
                                result = "kill";
                        else
                                result = "hit";
                }

                System.out.println(result); 
                return result; 
        }
}

import java.io.*;
public class GameHelper3 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

import java.io.*;
import java.util.*;

public class GameHelper {
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int[] grid = new int[gridSize];
        private int comCount = 0;
        
        public String getUserInput(String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length()==0)
                                return null;
                }catch(IOException e){
                        System.out.println("OException: " + e);
                }
                
                return inputLine.toLowerCase();
        }
        
        public ArrayList<String> placeDotCom(int comSize){
                ArrayList<String> alphaCells = new ArrayList<String>(); // 배열에 좌표값이 들어감
                String temp = null; // 임시로 String에 null 값을 설정
                int[] coords = new int[comSize]; // 현재 후보 좌표
                int attempts = 0; // 시도 횟수를 세기 위한 카운터
                boolean success = false; // 맞는 위치를 찾았는지 표시
                int location = 0; // 현재 시작 위치
                
                comCount++; // n번째 닷컴
                int incr = 1; // 수평 방향으로 증가시킬 값 설정
                if((comCount%2)==1){ // 홀수 번째 닷컴인 경우 수직으로 배열
                        incr = gridLength; // 수직 방향으로 증가시킬 값 설정
                }
                
                while(!success & attempts<200){ // 주 검색 순환문(32)
                        location = (int)(Math.random()*gridSize); // 임의 시작 위치를 구함
                        int x = 0; // 위치시킬 n번째 닷컴
                        success = true; // 맞을 것으로 가정함
                        while(success && x<comSize){ 
                                if(grid[location]==0){
                                        coords[x++] = location; // 위치 저장
                                        location += incr; // 다음 칸 확인
                                        if(location>=gridSize){ 
                                                success = false; 
                                        }
                                        if(x>0 & (location % gridLength==0)){ 
                                                success = false; 
                                        }
                                }else{ 
                                        success = false; 
                                }
                        }
                }
                
                int x = 0; // 위치를 알파벳 좌표로 설정
                int row = 0;
                int column = 0;
                
                while(x<comSize){
                        grid[coords[x]] = 1; // 기본 그리드 좌표를 '사용 중'으로 표시
                        row = (int)(coords[x]/gridLength); 
                        column = coords[x]%gridLength;
                        temp = String.valueOf(alphabet.charAt(column)); // 숫자된 열을 알파벳으로 나타냄
                        
                        alphaCells.add(temp.concat(Integer.toString(row)));
                        x++;
                }
                
                return alphaCells;
        }
}

import java.util.*;

public class DotComBust { 
        private GameHelper helper = new GameHelper();
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>(); // DotCom객체로 이루어진 ArrayList 만듬
        private int numOfGuesses = 0;
        
        private void setUpGame(){ // 닷컴 객체 몇 개를 만들고 위치 지정
                DotCom one = new DotCom();
                one.setName("Pets.com");
                DotCom two = new DotCom();
                two.setName("eToys.com");
                DotCom three = new DotCom();
                three.setName("Go2.com");
                dotComsList.add(one);
                dotComsList.add(two);
                dotComsList.add(three);

                System.out.println("Your goal is to sink three dot coms.");
                System.out.println("Pets.com, eToys.com, Go2.com");
                System.out.println("Try to sink them all in the fewest number of guesses");
                
                for (DotCom dotComToSet : dotComsList){
                        ArrayList<String> newLocation = helper.placeDotCom(3); 
                        dotComToSet.setLocationCells(newLocation); 
                } 
        } 
        
        private void startPlaying(){
                while(!dotComsList.isEmpty()){
                        String userGuess = helper.getUserInput("Enter a guess");
                        checkUserGuess(userGuess);
                } 
                
                finishGame();
        } 
        
        private void checkUserGuess(String userGuess){
                numOfGuesses++; // 사용자 추측 횟수 증가
                String result = "miss";
                
                for(DotCom dotComToTest : dotComsList){ 
                        result = dotComToTest.checkYourself(userGuess); 
                        if(result.equals("hit"))
                                break;
                        if(result.equals("kill")){
                                dotComsList.remove(dotComToTest);
                                break;
                        }
                }
                
                System.out.println(result);
        }
        
        private void finishGame(){
                System.out.println("All Dot Coms are dead! Your stock is now worthless");
                if(numOfGuesses<=18){
                        System.out.println("It only took you " + numOfGuesses + " guesses.");
                        System.out.println("You got out before your options sank");
                }else{
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
                        System.out.println("Fish are dancing with your options");
                }
        }
        
        public static void main (String[] args){
                DotComBust game = new DotComBust(); // 게임 객체 생성
                game.setUpGame();
                game.startPlaying();
        }
}

import java.util.*;

public class DotCom {
        private ArrayList<String> locationCells;
        private String name;
        
        public void setLocationCells(ArrayList loc){
                locationCells = loc;
        }
        
        public void setName(String n){
                name = n;
        }
        
        public String checkYourself(String userInput){
                String status = "miss";
                int index = locationCells.indexOf(userInput);
                
                if(index>=0){
                        locationCells.remove(index); 
                        if(locationCells.isEmpty()){ // 모든 위치를 맞췄는지 확인
                                status = "kill";
                                System.out.println("Ouch! You sunk " + name + "   :  (");
                        }else{
                                status = "hit";
                        }
                } 
                
                return status;
        } 
} 

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 하위클래스(subclass)의 공통적인 기능을 뽑아서 새로운 클래스인 상위클래스(superclass)를 만든다. 이 때 하위클래스는 상위클래스의 메소드를 상속한다고 말한다. 바꿔 말하자면 상위 클래스에 어떤 기능이 있으면 하위클래스에서도 자동으로 같은 기능을 발휘할 수 있다.
 * 다형성: 상위 클래스가 하위 클래스를 참조할 수 있도록 한 것으로 레퍼런스 유형을 실제 객체 유형의 상위 클래스 유형으로 지정할 수 있다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

class Animal {
        String picture;
        Boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise() { //소리를 낼 때
        }

        void eat() { //먹잇감을 찾았을 때
        }

        void sleep() { //잘 때
        }

        void roam() { //떠돌아다닐 때
        }

}

class Feline extends Animal {
        void roam() { //roam을 override
        }
}

class Canine extends Animal
        void roam() { //roam을 override
        }
}

class Lion extends Feline {
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

class Tiger extends Feline {
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

class Cat extends Feline {
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

class Hiippo extends Animal { 
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

class Wolf extends Canine {
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

class Dog extends Canine { 
        void makeNoise() { //makeNoise를 override
        }

        void eat() { //eat를 override
        }
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 상위클래스의 메소드를 오버라이드할 때는 규칙을 따라야 한다. 즉, 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 한다는 것이다.
 * 오버로딩: 메소드 오버로딩(overloading)은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것이다. 오버로드된 메소드는 다형성과는 전혀 관계가 없다. 오버로딩을 활용하면 호출하는 쪽의 편의를 위해 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있다. 오버로드하는 메소드에서는 상위클래스에서 정의한 다형성 계약을 이행하지 않아도 되기 때문에 메소드 오버로딩은 훨씬 더 융통성이 좋다고 할 수 있다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

1.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return true;
}
}

class Vampire extends Monster {

boolean frighten(int x){
	System.out.println("a bite?");
	return false;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

제대로 작동

결과값 : 
a bite?
breath fire
arrrgh
}}}

{{{

2.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return true;
}
}

class Vampire extends Monster {

int frighten(int x){
	System.out.println("a bite?");
	return 1; // return 유형이 int인데 상위클래스는 boolean이기 때문에 오버로딩 불가
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

}}}

{{{

3.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return false;
}
}

class Vampire extends Monster {

boolean scare(int x){ // 메소드가 frighten이 아닌 scare. 따라서 본 클래스에서 상위클래스의 메소드를 사용하게 됨.
	System.out.println("a bite?");
	return true;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

결과값 : 
arrrgh
breath fire
arrrgh

}}}

{{{

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return false;
}
}

class Vampire extends Monster {

boolean frighten(byte b){ // 상위클래스의 메소드와 매개변수가 다름. 따라서 오버로드 하지 않음
	System.out.println("a bite?");
	return true;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

결과값 : 
arrrgh
breath fire
arrrgh

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100% 순수한 추상 클래스. 인터페이스에서는 추상 메소드만 정의한다. 인터페이스를 만들 때는 class 대신 interface라는 키워드를 사용한다. 인터페이스를 구현할 때는 implements라는 키워드를 쓰면 된다. 클래스를 만들 때 인터페이스를 여러 개 구현할 수 있다. 인터페이스의 모든 메소드는 자동으로 public 메소드, 그리고 abstract 메소드가 되기 때문에 인터페이스를 구현하는 클래스에서는 인터페이스에 들어있는 모든 메소드를 구현해야 한다.
 * 다형성: 상위 클래스가 하위 클래스를 참조할 수 있도록 한 것으로 레퍼런스 유형을 실제 객체 유형의 상위 클래스 유형으로 지정할 수 있다.
 * 추상 클래스: 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스. 확장하지 않으면 거의 쓸모도 없고, 가치도 없고, 목적도 없다. 추상 클래스를 만들었을 대 실제 실행 중에 일을 처리하는 것은 그 추상 클래스의 하위클래스 인스턴스이다. 반드시 확장해야하는 클래스.
 * 추상 메소드: 반드시 오버라이드해야하는 메소드. 추상 메소드를 만들 때는 클래스도 반드시 추상 클래스로 만들어야한다. 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없다. 하지만 추상 클래스 안에 추상 메소드와 추상 메소드가 아닌 메소드를 모두 집어 넣는 것은 괜찮다.
 * 다중 상속: '상위클래스를 두 개 사용하는' 접근법

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객체가 사는 곳이다. 
 * 스택에서의 변수: 스택은 메소드 호출과 지역 변수가 사는 곳이다. 메소드 안에서 선언한 것을 지역 변수라고 부르는데, 메소드 매개변수도 지역 변수에 포함된다. 지역 변수는 임시 변수며 메소드가 스택에 들어있는 동안만 (즉, 메소드 전체를 감싸는 오른쪽 중괄호가 나타나기 전까지만) 살아있다.
 * 생성자: 생성자는 겉으로 보기에는 메소드와 거의 똑같지만 메소드가 아니다. new라는 키워드를 사용했을 때 실행할 코드가 들어있다. 즉, 어떤 클래스 유형의 인스턴스를 만들 때 실행할 코드가 들어있다. 직접 클래스에 대한 생성자를 만들 수도 있지만 생성자를 만들지 않더라도 컴파일러에서 알아서 만들어준다.
 * 널 레퍼런스: 프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지정된다. 원시 유형의 기본값은 0/0.0/false고 객체에 대한 레퍼런스의 기본값은 null이다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체를 지원하는 역할을 하며 보통 객체가 살아있는 동안 항상 객체와 함께 함. 객체와 함께 힙에 있다. 정확하게 말하자면 객체와 함께 있다기 보다는 객체 안에 있다. 그리고 그 객체의 상태를 저장하고 있다.
 * 지역 변수: 알고리즘을 작동시키기위해 메소드에 반드시 있어야 함. 다른 여러 지역 변수와 함께 스택 프레임에 빼곡하게 들어가 있다. 그리고 속해있는 메소드에서 다른 메소드를 호출하면 다른 프레임이 올라오고 그 메소드에서 다른 메소드를 호출하면 새로운 프레임이 올라온다. 심지어 위에 있는 다른 메소드가 끝날 때까지 한참 동안을 아무 것도 안 하고 기다려야 할 때도 있다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

import java.util.*;
class V2Radiator {
        V2Radiator(ArrayList<SimUnit> list) {
                for(int x = 5; x < 5 ; x++) {
                        list.add(new SimUnit("V2Radiator"));// 받아온 List에 5번 SimUnit을 추가하고 V2Radiator를 넘김
                }
        }
}

class V3Radiator extends V2Radiator{ // 불필요한 부분 
        V3Radiator(ArrayList<SimUnit> lglist) {
                super(lglist); // 불필요한 부분. 이부분에서 불필요하게 5개의 SimUnit이 생성.
                for(int g = 0; g < 10 ; g++) {
                        lglist.add(new SimUnit("V3Radiator")); // lglist에 10번 SimUnit을 추가하고 V3Radiator를 넘김.
                }
        }
}

class RetentionBot {
        RetentionBot(ArrayList<SimUnit> rlist) {
                rlist.add(new SimUnit("Rention"));
        }
}

public class TestLifeSupportSim {
        public static void main(String[] args) {
                ArrayList<SimUnit> aList = new ArrayList<SimUnit>(); // aList의 ArrayList생성
                V2Radiator v2 = new V2Radiator(aList); // V2객체 생성
                V3Radiator v3 = new V3Radiator(aList); // V3객체 생성
                for(int z = 0 ; z < 20 ; z++) {
                        RetentionBot ret = new RetentionBot(aList); // 20번 ret객체를 생성
                }
        }
}

class SimUnit{
        String botType;
        SimUnit(String type) {
                botType = type;
        }
        int powerUse() {
                if("Retention".equals(botType)) {
                        return 2;                       
                }
                else {
                        return 4;
                }
        }
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: "인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않고 클래스만 있어도 된다"를 의미
 * 정적 메소드를 선언하는 방법: static이라는 키워드를 사용하면 클래스의 인스턴스없이 메소드를 실행할 수 있다.
 * static final: final로 지정한 변수는 (일단 초기화되고 나면) 절대 그 값을 바꿀 수 없다. 즉, static final로 선언한 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지한다.
 * 널 레퍼런스: 프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지정된다. 원시 유형의 기본값은 0/0.0/false고 객체에 대한 레퍼런스의 기본값은 null이다.
 * 오토 박싱: 자바 5.0부터 도입된 오토박싱(autoboxing)은 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능
 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 정적 임포트를 활용해서 타이핑을 더 적게 해보자는 것으로 자바 5.0에 새로 추가된 기능이다.

*339p Calendar* _구현후 주석달기_

{{{

import java.util.*;
public class Calendar {
        public static void main(String[] args) {
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40); // 시각을 2004년 1월 7일 15:40 으로 설정
                long day1 = c.getTimeInMillis(); // 1970년 1월1일부터 경과한 시간을 밀리초 단위로 표현한 값을 return
                day1 += 1000 * 60 * 60;
                c.setTimeInMillis(day1); // 한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 update
                System.out.println("new hour" + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35); // 35일을 더함
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35); // 35일 뒤로 감. 달은 바뀌지 않음.
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1); // 날짜를 1로 설정
                System.out.println("set to 1 " + c.getTime());
        }
}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 인스턴스 변수에 대한 내용은 별로 없다.
 * 정적 변수: (지역 변수가 아닌 정적 변수에 대한 이야기가 전개된다) 정적 변수는 더 효율적인데 인스턴스마다 하나씩 있는 게 아니고 클래스마다 하나씩 있기 때문에 메모리가 많이 절약된다.즉 한 클래스에 속하는 모든 인스턴스에 의해서 공유된다. 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class StaticSuper {
	static {
		System.out.println("super static block");
	}

	StaticSuper() { //StaticSuper는 생성자이므로 반드시 ()가 있어야 한다. 두 클래스의 정적 초기화 블록은 생성자가 실행되기 전에 실행된다.
		System.out.println("super constructor");
	}
}

public class StaticTests extends StaticSuper {
	static int rand;

	static {
		rand = (int) (Math.random() * 6);
		System.out.println("static block " + rand);
	}

	StaticTest() {
		System.out.println("constructor");
	}
	
	public static void main(String [] args) {
		System.out.println("in main");
		StaticTest st = new StaticTest();
	}
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

public void takeRisk() throws BadException { // 예외를 선언하는 과정을 통해 Badexception을 던질 수 있다는 것을 외부에 알림
	if (abandonAllHope) {
		throw new BadException (); // 새로운 Exception 개체를 만들고 던짐
	}

public void crossFingers() {
	try {
		anObject.takeRisk();
	}

	catch (BadException ex) {
		System.out.println("Aaargh!");
		ex.printStackTrace();
	} // 예외 상황을 해결할 수 없다면 적어도 모든 예외 객체에서 물려받는 printStackTrace() 메소드를 써서 스택 트레이스를 출력
}

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}