#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public calss BeerSong {
public static void main (String[] args) {
int beerNum = 99;
String word = "bottles"; // 복수형

while (beerNum > 0) {

System.out.println("beerNum + " " + word + " of beer on the wall");
System.out.println("beerNum + " " + word + " of beer.");
System.out.println("Take one down.");
System.out.println("Pass it around.");
beerNum = beerNum -1;

if (beerNum == 1) {
 word = "bottle"; //단수형(한병인경우)
}

if (beerNum > 0) {
System.out.println("beerNum + " " + word + " of beer on the wall");
}
else {
System.out.println("No more bottles of beer on the wall");
}//else문 끝
}//while순환문 끝
}//main 클래스 끝
}//클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행시키는 역할을 한다. 또 보안관련 작업을 수행한다
 * 컴파일러: 어떤 프로그램이 실행될 때 절대로 일어나면 안 되는 일을 방지한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{ 
A
class Exercise1b {
public static void main(Strinc [] args) {
int x = 1;
while ( x < 10 ) {
X = X+1;
if (x > 3) {
System.out.println("big x");
}
}
}
}

B
Class Foo{
public static void main(String [] args) {
int x = 5;
while ( x > 1){
x = x -1;
if(x<3){
System.ot.println("small x");
}
}
}
}

C

class Exercise1b {
public static void main(String [] args){

int x = 5;
while ( x > 1) {
x = x - 1;
if ( x < 3) {
System.out.println("small x");
}
}
}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것, 객체의 상태(데이터)를 나타낸다. 
 * 메소드: 객체에서 자신이 하는 것. 
 * 클래스: 객체를 만들기 위한 용도로 사용. 객체를 만들기 위한 청사진. 
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스. 



  68p Television 채워넣기 
 * 인스턴스 변수: color, power, channel 
 * 메소드: power(), channelUp(), ChannelDown() 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
/* 사람수를 4명으로 하려면 같은 형식으로 클래스 안에 p4에 해당하는것을 p1 p2 p3와 똑같이 써주고 조건문을 조금 바꾸면 됩니다. */

class GuessGame {

    Player p1;
    Player p2;
    Player p3;
    Player p4; // 4번째 플레이어

public void startGame(){
   p1=new Player();
   p2=new Player();
   p3=new Player();
   p4=new Player();

   int guessp1=0; // 각 객체가 찍은 숫자를 저장하기위한 변수
   int guessp2=0;
   int guessp3=0;
   int guessp4=0;

   boolean p1isRight=false;
   boolean p2isRight=false;
   boolean p3isRight=false;
   boolean p4isRight=false;

   int targetNumber=(int)(Math.random()*10);
   System.out.println("0이상 9이하의 숫자를 맞춰보세요.");

while(true){

   System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");

p1.guess(); // 각 사람이 숫자를 추측합니다.
p2.guess();
p3.guess();
p4.guess();

guessp1=p1.number;
System.out.println("1번 선수가 찍은 숫자:"+guessp1);

guessp2=p2.number; 
System.out.println("2번 선수가 찍은 숫자:"+guessp2);

guessp3=p3.number; 
System.out.println("3번 선수가 찍은 숫자:"+guessp3);

guessp4=p4.number; 
System.out.println("4번 선수가 찍은 숫자:"+guessp4); 

// 각 선수가 찍은 숫자를 알아냅니다.

if(guessp1==targetNumber){ 
   p1isRight=true;
}
if(guessp2==targetNumber){
   p2isRight=true;
}                        
if(guessp3==targetNumber){
   p3isRight=true;
}                        
if(guessp4==targetNumber){  
   p4isRight=true;
}                        

if(p1isRight|p2isRight|p3isRight|p4isRight){
      System.out.println("맞춘 선수가 있습니다.");       
      System.out.println("1번 선수:" + p1isRight);
      System.out.println("2번 선수:" + p2isRight);
      System.out.println("3번 선수:" + p3isRight);
      System.out.println("4번 선수:" + p4isRight);
      System.out.println("게임 끝.");
     break;
}

else{
System.out.println("다시 시도해야 합니다."); 
     }
    }
  }
}

class Player{
int number=0;

public void guess(){
number=(int)(Math.random()*10);
System.out.println("찍은 숫자:"+number);
 }
}

public class GameLauncher{

public static void main (String[]args){
GuessGame game=new GuessGame();
game.startGame();
  }
}
}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class TapeDeck{ // TapeDeck 클래스 생성
boolean canRecord=false; // canRecord를 Boolean값으로 설정
void playTape(){
System.out.println("tape playing");
}
void recordTape(){
System.out.println("tape recording");
  }
}
class TapeDeckTestDrive{ // TapeDeckTest 클래스 생성

public static void main(String[]args){

   TapeDeck t=new TapeDeck(); // 이름이 t인 객체 생성
     t.canRecord=true;
     t.playTape();
   
   if(t.canRecord==true){
     t.recordTape();
}
}
}

B

class DVDPlayer{

boolean canRecord=false; // canRecord를 Boolean값으로 설정

void recordDVD(){
System.out.println("DVD recording");
}

void playDVD(){ 
System.out.println("DVD playing");
}
}

class DVDPlayerTestDrive{

public static void main(String[]args){
   DVDPlayer d = new DVDPlayer();
   d.canRecord=true;
   d.playDVD();

   if(d.canRecord==true){
    d.recordDVD();
}
}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 변수는 크게 원시변수와 레퍼런스 변수로 나눌 수 있다.
   원시 변수에는 정수, 부우르 부동소수점 수와 같은 단순한 비트 패턴으로 나타낼 수 있는 값이 들어간다.
   객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog { 

String name;

public static void main(String[]args){ // Dog 객체를 만들고 접근합니다.

Dog dog1 = new Dog();
dog1.bark();
dog1.name="Bart";

//이번에는 Dog 배열을 만듭니다
Dog[]myDogs=new Dog[5]; // 개를 5마리를 집어넣었습니다
myDogs[0]=new Dog();
myDogs[1]=new Dog();
myDogs[2]=new Dog();
myDogs[3]=new Dog();
myDogs[4]= dog1;
// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.

myDogs[0].name="Fred";
myDogs[1].name="Marge";
myDogs[2].name="A";
myDogs[3].name="B"; 
myDogs[4].name="C";

System.out.print("마지막 개의 이름:");
System.out.println(myDogs[4].name); 
// 순환문을 써서 배열에 있는 모든 개가 짖게 한다.

int x=0;
while(x<myDogs.length){
myDogs[x].bark();
x=x+1;
  }
}

public void bark(){
  System.out.println(name + "이(가) 왈!하고 짖습니다.");
}

public void eat(){
}
public void chaseCat(){
}
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

// Books 클래스를 생성합니다.
class Books{
  String title;
String author;
}

class BooksTestDrive {
 public static void main(String[]args){

  Books[]myBooks=new Books[3];
  int x=0;// Books 객체를 생성합니다.

  myBooks[0]=new Books();
  myBooks[1]=new Books();
  myBooks[2]=new Books();// 객체들의 속성을 채워줍니다.
  myBooks[0].title="The Grapes of Java";
  myBooks[1].title="The Java Gatsby";
  myBooks[2].title="The Java Cookbook";
  myBooks[0].author="bob";
  myBooks[1].author="sue";
  myBooks[2].author="ian";

while(x<3){
   System.out.print(myBooks[x].title);
   System.out.print("by");
   System.out.println(myBooks[x].author);
   x = x+1;
}
}
}

B

// Hobbits 클래스를 생성합니다.
class Hobbits {

  String name;

  public static void main (String [] args) {

    Hobbits [] h = new Hobbits[3];
    int z = 0; // 

while (z<3){// 배열의 인덱스는 0부터 이므로 z<4가 아니고 z<3으로 바꾸고 z = z+1;의 위치를 바꿔주었다.
 h[z] = new Hobbits(); //객체를 생성합니다.
 h[z].name = "bilbo";
 
 if (z==1) {
   h[z].name = "frodo";
}
 if (z==2) {
   h[z].name = "sam";
}

 System.out.print(h[z].name + " is a ");
 System.out.println("good hobbit name");
 z = z + 1; 
}
}}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트는 while문이 돌때마다 새로운 객체를 레퍼런스변수에 대입해서 while문이 돌기 바로 직전 객체는 사라진다

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:객체의 자료와 행위를 하나로 묶고 실제 구현 내용을 외부에 감추는 것. 
 * 게터와 세터: 게터는 단지 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 쓰인다. 세터는 그 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다
 * 인스턴스 변수 vs 지역 변수:
 인스턴스 변수는 클래스 내에서 선언된다. 지역변수는 메소드 내에서 선언되고 기본값이 없으며, 사용 전에 반드시 초기화 해야 한다. 

*107p Dog* _실행_

{{{

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
90년대 말에 등장했고, 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다. 규칙은 다음과 같다.

-조금씩, 하지만 자주 발표한다
-사이클을 반복해서 돌리면서 개발한다
-스펙에 없는 것은 절대 집어넣지 않는다.
-테스트 코드를 먼저 만든다.
-정규 일과 시간에만 작업한다.
-언제 어디서든 코드를 개선한다.
-모든 테스트를 통과하기 전에는 어떤것도 발표 금지
-조금씩 발표하는 것을 기반으로 현실적인 작업계획
-모든 일을 단순하게 처리
-두명씩 팀을 편성하고 모든 사람들이 대부분의 코드를 알 수 있도록 돌아가면서 작업
 

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상위클래스로부터 인스턴스 변수와 메소드를 하위클래스에게 넘겨주는 것
 * 다형성: 여러가지 형태를 하나의 그릇으로 나타낼 수 있다. 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 부모 메소드를 자식 메소드에서 재정의 하는 것
 * 오버로딩: 하나의 클래스 내에 인수의 개수나 형식이 다른 동일한 이름의 메소드를 여러개 정의하는 것

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 인스턴스변수라고 하는데, 클래스 내에서 선언된 변수이고 메소드 내에서 선언한 것은 인스턴스 변수가 아니다. 인스턴스 변수는 각각의 개별 객체가 가지고 있는 필드를 나타낸다. 

 * 스택에서의 변수:지역변수라고 하는데, 지역변수는 메소드 안에서 선언한 것을 뜻한다.지역변수는 임시변수이며, 메소드가 스택에 들어있는동안만 살아있다.

 * 생성자:어떤 클래스 유형에 대해 new 키워드를 사용할 때 실행되는 코드이다. 생성자명은 반드시 클래스명과 같아야 하며 리턴 유형은 없다. 생성자를 이용해 인스턴스변수를 초기화 할 수 있고, 클래스에 생성자가 없으면, 컴파일러에서 기본 생성자를 만든다.

 * 널 레퍼런스: 프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지정된다. 객체에 대한 레퍼런스의 기본값은 null이고 이것을 널 레퍼런스라고 부른다.

*298p 집중토론* _요약_

 * 인스턴스 변수: 인스턴스 변수는 객체를 지원하는 역할을 하고, 상태는 인스턴스 변수에 저장된 값이다. 객체 안에서 살며 객체의 상태를 저장한다. 자신이 속한 객체가 가비지 컬렉터에 의해 처리된다면 인스턴스 변수도 함께 삭제된다.

    지역 변수: 지역변수는 임시 변수로도 불리고 지역, 스택, 자동, 영역 제한같은 용어를 선호한다. 또 다른 여러 지역 변수와 함께 스택 프레임에 빼곡하게 들어가 있어야 하고 자신의 프레임이 스택 맨 위로 올라갈 때 까지 하는 것이 없다. 프레임이 사라지지 않는 이상 자신이 저장하고 있는 값도 유지된다. 또한 객체를 참조하는 유일한 레퍼런스가 지역 변수에서만있으면 지역 변수가 사라질 때 그 인스턴스 변수도 같이 사라진다. 


*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.*;
class V2Radiator{
  V2Radiator(ArrayList<SimUnit> list){ //ArrayList를 전달
   for(int x = 5; x < 5 ; x++){
    list.add(new SimUnit("V2Radiator")); // V2Radiator 객체를 추가한다
}
}
}
class V3Radiator{
  V3Radiator(ArrayList<SimUnit> lglist){//super(lglist)삭제
   for(int g = 0; g < 10 ; g++){
    lglist.add(new SimUnit("V3Radiator"));//V3Radiator 객체를 추가한다
}
}
}

class RetentionBot{
  RetentionBot(ArrayList<SimUnit> rlist){
   rlist.add(new SimUnit("Rention")); // Rention 객체 추가한다.
}
}

public class TestLifeSupportSim{
  public static void main(String[] args){
   ArrayList<SimUnit> aList = new ArrayList<SimUnit>();
   V2Radiator v2 = new V2Radiator(aList);
   V3Radiator v3 = new V3Radiator(aList);
   for(int z = 0 ; z < 20 ; z++){
     RetentionBot ret = new RetentionBot(aList);
}
}
}

class SimUnit {
  String botType;
  SimUnit(String type){
   botType = type;
}

  int powerUse(){
   if("Retention".equals(botType)){
     return 2;
} else {
     return 4;
}
}
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{