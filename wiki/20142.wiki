 #summary 단이열

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {

    public static void main(String args) {
        int beerNum = 99; 
        String word = "bottles"; // 복수형                                                                                                             
        while (beerNum>0) {
            System.out.println(beerNum + " " + word + " of beer on the wall");
            System.out.println(beerNum + " " + word + " of beer.");
            System.out.println("Take one down.");
            System.out.println("Pass it around");
            beerNum -= beerNum;
            if (beerNum ==1) //change String "word" right after changing "beerNum"                                                                                       
                {
                    word = "bottle"; // 단수형(한 병인 경우)                                                                                                             
                }
            if(beerNum >0) {
                if (beerNum ==1) //change String "word" right after changing "beerNum"                                                                                   
                    {
                        word = "bottle"; // 단수형(한 병인 경우)                                                                                                         
                    }
                System.out.println(beerNum + " " + word + " of beer on the wall\n");
            } else {
                System.out.println("No more bottles of beer on the wall\n");
            } // else 문 끝                                                                                                                                              
        } // while 순환문 끝                                                                                                                                             
    } // main 클래스 끝                                                                                                                                                  
} // 클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
    public static void main (String[] args) {
        String[] wordListOne = {"Dan", "Lee", "Jung", "Hwang", "Ann", "Kim"};
        String[] wordListTwo = {"Tiger", "Lion", "Eagle", "Dog", "Cat", "rat", "Dragon", "Snake"};
        String[] wordListThree = {"Universe", "Nation", "Town", "Land", "Sea"};

        int oneLength = wordListOne.length;
        int twoLength = wordListTwo.length; //String[]은 length라는 인스턴스변수(속성)를 가지고 있는 거 같다                                                             
        int threeLength = wordListThree.length;

        int rand1 = (int) (Math.random() * oneLength); //난수를 발생시켜서 단어목록의 길이와 곱함                              
        int rand2 = (int) (Math.random() * twoLength);
        int rand3 = (int) (Math.random() * threeLength);

        String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

        System.out.println("What we need is a " + phrase);
    }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 컴파일러가 컴파일한 프로그램 파일을 실행시킴, 변수에 다른 유형의 값이 들어갈 때 ClassCastException을 발생시킴, 보안관련 작업을 함, 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 그걸 건드리지 않았는지 확인하는 작업
 * 컴파일러: 틀린 문법을 잡아냄, 변수에 이상한 유형의 데이터를 저장할 수 없게 함, 동적 바인딩 지원, 함부로 보면 안되는 코드를 건드리려는 등의 일을 방지

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b {
    public static void main(String[] args) {
	int x =	1;
	while(x < 10) {                                                                                     
            if (x > 3) {
		System.out.println("big x");
            }
            x =	x + 1;	   // 이 행이 없으면 while문이 영원히 반복되어 버립니다     
	}
    }
}


class Exercise1b {    // 클래스를 나타내주는 행과 중괄호가 있어야합니다                                                                                                
    public static void main(String[] args) {
	int 5;
	while (x > 1) {
            x =	x - 1;
            if (x < 3) {
		System.out.println("small x");
            }
	}
    }
} // 클래스의 마지막을 나타내는 중괄호입니다


class Exercise1b {
    public static void main(String[] args) {  // main()메소드가 필요합니다                                                                                             
	int x =	5;
	while (x > 1) {
            x =	x - 1;
            if (x < 3) {
		System.out.println("small x");
            }
	}
    } // main()메소드의 마지막을 나타내는 중괄호입니다                                                                                                                 
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 아는 것(객체의 성질)
 * 메소드: 객체에서 하는 것(객체의 행동;Act)
 * 클래스: 객체를 만들기 위한 청사진(인스턴스 변수+메소드)
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: 전원, 채널, 음량
 * 메소드: PowerOn(), ChangeChannel(), ChangeSound()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
    Player p1;
    Player p2;
    Player p3;
    Player p4;

    public void startGame() {
	p1 = new Player();
	p2 = new Player();
	p3 = new Player();
	p4 = new Player();

	int guessp1 = 0;
	int guessp2 = 0;
	int guessp3 = 0;
	int guessp4 = 0;

	boolean	p1isRight = false;
	boolean	p2isRight = false;
	boolean	p3isRight = false;
	boolean	p4isRight = false;

	int targetNumber = (int) (Math.random() * 10);
	System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

	while(true) {
            System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

            p1.guess();
            p2.guess();
            p3.guess();
            p4.guess();

            guessp1 = p1.number;
            System.out.println("1번 선수가 찍은 숫자: "	+ guessp1);

            guessp2 = p2.number;
            System.out.println("2번 선수가 찍은 숫자: "	+ guessp2);

            guessp3 = p3.number;
            System.out.println("3번 선수가 찍은 숫자: "	+ guessp3);

            guessp4 = p4.number;
            System.out.println("4번 선수가 찍은 숫자: "	+ guessp4);

            if (guessp1	== targetNumber) {
		p1isRight = true;
	    }   

            if (guessp2	== targetNumber) {
		p2isRight = true;
            }

            if (guessp3	== targetNumber) {
		p3isRight = true;
            }

            if (guessp4	== targetNumber) {
		p4isRight = true;
            }

            if (p1isRight || p2isRight || p3isRight || p4isRight) {

		System.out.println("맞춘 선수가 있습니다.");
		System.out.println("1번 선수: "	+ p1isRight);
		System.out.println("2번 선수: "	+ p2isRight);
		System.out.println("3번 선수: "	+ p3isRight);
		System.out.println("4번 선수: "	+ p4isRight);
		System.out.println("게임 끝.");
                break;	

            } else {
		System.out.println("다시 시도해야 합니다.");
            }
	}
    }   
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class TapeDeck {

    boolean canRecord =	false;

    void playTape() {
	System.out.println("tape playing");
    }

    void recordTape() {
	System.out.println("tape recording");
    }
}

class TapeDeckTestDrive	{
    public static void main(String[] args) {
	
	TapeDeck t = new TapeDeck;  // 실제로 객체를 만듭니다                                                                                                          

	t.canRecord = true;
	t.playTape();

	if (t.canrecord	== true) {
            t.recordTape();
	}
    }
}

###################################################################################

class DVDPlayer	{

    boolean canRecord =	false;

    void playDVD() {
	System.out.println("DVD playing");   // 메소드를 정의해야 합니다                                                                                               
    }
    void recordDVD() {
        System.out.println("DVD recording");
    }
}


class DVDPlayerTestDrive {
    public static void main(String[] args) {

	DVDPlayer d = new DVDPlayer();
	d.canRecord = true;
	d.playDVD();

	if (d.canRecord	== ture) {
            d.recordDVD();
	}
    }
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 변수는 무언가를 담는 컵이다. 그 중에서 원시변수는 문자나 숫자와 같은 기초적인 값을 넣는 컵이고, 레퍼런스변수는 한 객체를 다루기 위한 방법(포인터 같은 것)을 담는 컵이다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
    String name;
    public static void main (String[] args) {
	//Dog 객체를 만들고 접근                                                                                                                                         
	Dog dog1 = new Dog();
	dog1.bark();
	dog1.name = "Bart";

	//이번에는 Dog 배열을 만든다                                                                                                                                     
	Dog[] myDogs = new Dog[10];
	//for문을 이용해 객체 대량 생산                                                                                                                                  
	for(int	i = 0 ; i<10 ; ) {
            myDog[i] = new Dog();
	}

	//name이 String이라서 어쩔 수 없이 하나하나 이름을 넣어야 됨                                                                                                     
	Dog[0].name = "Ony";
	Dog[1].name = "Twy";
	Dog[2].name = "Thry";
	Dog[3].name = "Foury";
	Dog[4].name = "Fivy";
	Dog[5].name = "Sixy";
	Dog[6].name = "Seveny";
	Dog[7].name = "Eighty";
	Dog[8].name = "Niny";
	Dog[9].name = "Teny";

	//myDog[5]의 이름을 알아봄                                                                                                                                       
	System.out.println("What's the name of the fifth dog?: ");
	System.out.println(myDog[5].name);

	//모든 개가 짖도록 하자                                                                                                                                          
	int x =	0;
	while( x < myDogs.length) {
            myDogs[x].bark();
            x =	x + 1;
	}
    }


    public void	bark() {
	System.out.println(name	+ "barks: Woof! Woof!");
    }
    public void	eat(){}
    public void	chaseCat(){}
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Books {
    String title;
    String author;
}

class BooksTestDrive {
    public static void main(String[] args) {

	Books[] myBooks	= new Books[3];
	int x =	0;
	Books[0] = new Books();
	Books[1] = new Books();	// new Books[3]를 했을 때 객체는 만들어지지 않으므로 각 레퍼런스마다 객체를 만들어줘야 한다                                            
	Books[2] = new Books();
	myBooks[0].title = "The Grapes of Java";
	myBooks[1].title = "The Java Gatsby";
	myBooks[2].title = "The Java Cookbook";
	myBooks[0].author = "bob";
	myBooks[1].author = "sue";
	myBooks[2].author = "ian";

	while (	x < 3 ) {
            System.out.print(myBooks[x].title);
            System.out.print(" by ");
            System.out.println(myBooks[x].author);
            x =	x + 1;
	}
    }
}


class Hobbits {

    String name;

    public static void main(String[] args) {
	
	Hobbits[] h = new Hobbits[3];
	
	int z =	-1; // 수를 바꿔줘야 한다                                                                                                                              

	while( Z < 2 ) {
            z =	z + 1;
            h[z] = new Hobbits();
            h[z].name =	"bilbo";
            if ( z == 1	) {
		h[z].name = "frodo";
            }
            if ( z == 2	) {
		h[z].name = "sam";
            }

            System.out.print(h[z].name + " is a ");
            System.out.println("good Hobbit name");
	}
    }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:
 * 문제가 된 부분은 어딘가요?:

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 데이터와 자신이 구현한 코드를 나중에 수정할 권한을 보호하는 것
 * 게터와 세터: 
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_

{{{

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}