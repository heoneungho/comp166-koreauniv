#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{


//클래스 선언
public class BeerSong{ 
	//메인함수 선언
	public static void main(String[] args) { 
		
		//변수 설정
		int beerNum = 99;  
		String word = "bottles"; 
	
		//맥주병이 존재하는 동안에
		while(beerNum >0){
			
			if(beerNum == 1){
				word = "bottle"; //맥주병 하나인 경우
			}
		
			//맥주병이 하나라도 남아있다면
			if(beerNum > 0){
				
				//남은 맥주병들 출력하고 맥주명 하나 소비
				System.out.println(beerNum + " " + word + " " + "of beer on the wall");
				System.out.println(beerNum + " " + word + " " + "of beer.");
				System.out.println("Take one down");
				System.out.println("Pass it around");
				beerNum = beerNum -1 ;
			
				
			}else{
				//맥주병을 모두 먹으면 출력
				System.out.println("No more bottles of beer on the wall");
			}
		}
	}
} 
 
문제점 : if(beerNum>0) 잘못포괄하여 두번출력되었음.

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhaseOmatic {
	
	public static void main(String[] args){
		
		String[] wordListOne = {"24/7", "alg", "korea", "ac", "kr"};
		String[] wordListTwo = {"shool","media","math","music","english"};
		String[] wordListThree = {"android","apple","mobile","samsung","Apple"};
		
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		int rand1 = (int)(Math.random() * oneLength);
		int rand2 = (int)(Math.random() * twoLength);
		int rand3 = (int)(Math.random() * threeLength);
		
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];
		
		System.out.println("What we need is a " + phrase);
		
	}

}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행시키는 도구
 * 컴파일러: 파일을 해석

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A : 컴파일 가능하다.(콘솔창에 출력되기 위해서는 x값이 4이상 9이하여야된다.)
public class Exercise1b {

	public static void main(String[] args){
		
		int x = 5;
		
		while(x<10){
			
			if(x>3){
				System.out.println("big x");
			}
		}
	}
}
B : 클래스 선언해야 컴파일 가능하다.
public class Exercise1b {

	public static void main(String[] args){
		
		int x = 1;
		
		while(x>1){
			x = x - 1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}
C : 메인 함수를 선언해야 컴파일 가능하며 x값이 2일때 출력이 가능하다.

public class Exercise1b {

	public static void main(String[] args){
		
		int x = 5;
		
		while(x>1){
			x = x - 1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의상태
 * 메소드: 객체에서 하는것
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스: 다른 클래스의 객체를 생성하여 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: charnel
 * 메소드: select_charnel()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
//인스턴스 하나 더 생성
public class GuessGame {

	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0이상  9이하의 숫자를 맞춰보세요.");
		
		while(true){
			
			System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자 : " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자 : " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자 : " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자 : " + guessp4);
			
			if(guessp1 == targetNumber){
				p1isRight = true;
			}
			
			if(guessp2 == targetNumber){
				p2isRight = true;
			}
			
			if(guessp3 == targetNumber){
				p1isRight = true;
			}
			if(guessp4 == targetNumber){
				p1isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight || p4isRight){
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수 : " + p1isRight);
				System.out.println("2번 선수 : " + p2isRight);
				System.out.println("3번 선수 : " + p3isRight);
				System.out.println("4번 선수 : " + p4isRight);
				System.out.println("게임 끝.");
				break;
			}else{
				
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{ 
===================================================
A

public class TapeDeck {
	
	//테이프 기록 초기값 false
	boolean canRecord = false;
	
	//테이프 동작 출력
	void playTape(){
		System.out.println("tape playing");
	}
	//테이프 기록 출력
	void recordTape(){
		System.out.println("tape recording");
	}
}

public class TapeDeckTestDrive {
	public static void main(String[] args){
		
		//TapeDeck 객체 하나 생성
		TapeDeck t = new TapeDeck();
		
		//tape 저장하기 위해 
		t.canRecord = true;
		
		//기록되는 환경 출력
		t.playTape();
		
		//테이프가 기록중이라면 출력문 형성
		if(t.canRecord == true){
			
			t.recordTape();
		}
	}
}
=======================================================
B


public class DVDPlayer {
	
	//실행하자마자 기록되지 않도록 초기값 false로
	boolean canRecord = false;
	
	//기록되고 있을때 출력문
	void recordDVD(){
		System.out.println("DVD redording");
	}
	//동작중일때 출력문
	void playDVD(){
		System.out.println("DVD playing");
	}
}

public class DVDPlyaerTestDrive {
	public static void main(String[] args){
		
		//DVD 객체 생성
		DVDPlayer d = new DVDPlayer();
		
		//기록하기 위해 변수값 true로 
		d.canRecord = true;
		d.playDVD();
		
		//기록되고 있다면 해당되는 출력문 보여줌
		if(d.canRecord == true){
			d.recordDVD();
		}
	}
}



}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

원시변수 : 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어감
래퍼런스 변수 : 객체에대한 래퍼런스 값
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
	String name;
	
	public static void main(String[] args){
		Dog dog1 = new Dog();
		
		dog1.bark();
		dog1.name = "Bart";
		
		Dog[] myDogs = new Dog[3];
		
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";
		
		System.out.println("마지막 개의 이름:");
		System.out.println(myDogs[2].name);
		
		int x = 0;
		
		while(x<myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
		
	}
	
	public void bark(){
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat(){}
	public void chaseCat(){}
	
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
===================================================
public class Books {
	String title;
	String author;
}

public class BooksTestDrive {
	public static void main(String[] args){
		
		//Books 클래스 참조할 배열객체 생성
		Books[] myBooks = new Books[3];
		
		//객체개수만큼 루프 돌리기 위한 변수
		int x = 0;
		
		//객체 생성하고 그 객체를 배열 원소에 대입
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books();
		
		//배열객체 마다 해당 출력문 입력
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		
		//객체 출력
		while(x<3){
			
			System.out.println(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x+1;
		}
	}
}
================================================================
B

public class Hobbit {
	String name;
}

public class Hobbits {
	
	
	public static void main(String[] args){
		
		//객체 생성
		Hobbit [] h = new Hobbit[3];
		int z = 0;
		
		//3개 객체 출력
		while(z<3){
			
			//해당객체 배열원소에 대입
			h[z] = new Hobbit();
			//h[0]인경우 출력
			h[z].name = "bilbo";
			//h[1]인경우 출력
			if(z == 1){
				h[z].name = "frodo";
			}
			//h[2]인경우 출력
			if(z == 2){
				h[z].name = "sam";
			}
			System.out.println(h[z].name + "is a ");
			System.out.println("good Hobbit name");
			//다른 객체 출력위해 하나씩 증가 시킴
			z = z+1;
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트는 객체를 만들더라도 래퍼런스 변수가 객체 하나에만 접근할 수 있기 때문에 메모리가 적더라도 쓸모가 없다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 데이터에 대한 접근 제어
 * 게터와 세터: 
게터 = 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도
세터 = 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수:
 인스턴스 변수 = 클래스 내에서 선언됨,
 지역 변수  = 메소드 내에서 선언됨
*107p Dog* _실행_

{{{

Wooof! Wooof!
Yip!Yip
Ruff! Ruff!

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A
=======================================================

public class XCopy {
	
	public static void main(String[] args){
		
		//초기값 저장
		int orig = 42;
		
		//객체 생성
		XCopy x = new XCopy();
		
		//메소드 값 전달하여 2배 된값 리턴 받음
		int y = x.go(orig);
		
		//결과물 출력
		System.out.println(orig+"  "+y);
	}
	
	//초기값 두배해 주는 함수
	int go(int arg){
		arg = arg * 2;
		
		return arg;
	}
}
=============================================================
B


public class Clock {
	String time;
	
	//setTime 함수 호출시 생성자
	void setTime(String t){
		
		time = t;
	}
	//getTime시 String time 리턴
	String getTime(){
		return time;
	}
}


public class ClockTestDrive {
	public static void main(String[] arsg){
		
		//객체 생성
		Clock c = new Clock();
		
		//setTime 1245값 넣어 Clock 클래스에서 time값 리턴받음
		c.setTime("1245");
		
		//time값 넘겨 받아 저장하고 출력
		String tod = c.getTime();
		System.out.println("tiem : " + tod);
	}
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 소프트웨어 개발 방법론이자 규칙이다.
예를들어 싸이클을 반복해서 돌리면서 개발한다. 테스트 코드를 먼저 만든다.
모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다. 두명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업한다 등이 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotCom {
	
	//사용될 배열 및 변수 선언
	int[] locationCells;
	int numofHits = 0;
	
	//setLocation 메소드 초기화
	public void setLocationCells(int[] locs){
		locationCells = locs;
	}
	
	//checkYourself 함수 선언
	public String checkYourself(String stringGuess){
		
		//스트링변수를 int형으로 형 변환
		int guess = Integer.parseInt(stringGuess);
		//결과값 초기 false로
		String result = "miss";
		
		//전달받은 배열 길이 만큼
		for(int i = 0; i<locationCells.length; i++){
			
			//location 위치와 사용자가 추측한 정보가 일치하면 hit
			if(guess == locationCells[i]){
				result = "hit";
				
				//hit수 증가
				numofHits++;
				break;
			}
		}
		
		//모두 hit했다면 kill 출력
		if(numofHits == locationCells.length){
			result = "kill";
		}
		//결과값 출력
		System.out.println(result);
			return result;
	}
}


public class SimpleDotComTestDrive {
	
	public static void main(String[] arsg){
		
		//객체생성
		SimpleDotCom dot = new SimpleDotCom();
		
		//초기 위치값
		int[] locations = {2,3,4};
		
		//초기 위치값 설정
		dot.setLocationCells(locations);
		
		//사용자의 위치 예측값
		String userGuess = "2";
		
		//hit 시켰는지 결과값 출력
		String result  = dot.checkYourself(userGuess);
		
		
	}

}


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{



public class DotCom1 {
	
	//사용될 배열 및 변수 선언
	int[] locationCells;
	
	//배열요소 hit되었는지 확인하기 위해서
	String[] hitCells;
	int numofHits = 0;
	
	//setLocation 메소드 초기화
	public void setLocationCells(int[] locs){
		locationCells = locs;
	}
	
	//checkYourself 함수 선언
	public String checkYourself(String stringGuess){
		
		//스트링변수를 int형으로 형 변환
		int guess = Integer.parseInt(stringGuess);
		//결과값 초기 false로
		String result = "miss";
		
		//전달받은 배열 길이 만큼
		for(int i = 0; i<locationCells.length; i++){
			
			//이전에 맞춘적이 있다면 입력못하도록
			if(hitCells[i] == "true"){
				break;
			}
			
			//location 위치와 사용자가 추측한 정보가 일치하면 hit
			if(guess == locationCells[i]){
				result = "hit";
				hitCells[i] = "true";
				//hit수 증가
				numofHits++;
				break;
			}
		}
		
		//모두 hit했다면 kill 출력
		if(numofHits == locationCells.length){
			result = "kill";
		}
		//결과값 출력
		System.out.println(result);
			return result;
	}
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

public class DotCom2 {
	
	//사용될 배열 및 변수 선언
	int[] locationCells;
	int numofHits = 0;
	
	//setLocation 메소드 초기화
	public void setLocationCells(int[] locs){
		locationCells = locs;
	}
	
	//checkYourself 함수 선언
	public String checkYourself(String stringGuess){
		
		//스트링변수를 int형으로 형 변환
		int guess = Integer.parseInt(stringGuess);
		
		//결과값 초기 false로
		String result = "miss";
		
		//전달받은 배열 길이 만큼
		for(int i = 0; i<locationCells.length; i++){
			
			//이미 맞추었다면
			if(locationCells[i] == -1){
				System.out.println("already hit!!");
				break;
			}
			
			//location 위치와 사용자가 추측한 정보가 일치하면 hit
			if(guess == locationCells[i]){
				result = "hit";
				//맞춘경우 배열요소 -1로 전환
				locationCells[i] = -1;
				//hit수 증가
				numofHits++;
				break;
			}
		}
		
		//모두 hit했다면 kill 출력
		if(numofHits == locationCells.length){
			result = "kill";
		}
		//결과값 출력
		System.out.println(result);
			return result;
	}
}


}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList;

public class DotCom3 {

	private ArrayList<String> locationCells;
	
	//location 위치 초기화
	public void setLocationCells(ArrayList<String> loc){
		locationCells = loc;
	}
	
	public String checkYourself(String userInput){
		
		//초기값 miss로
		String result = "miss";
		
		//user로부터 인덱스값 받고
		int index = locationCells.indexOf(userInput);
		
		//추측한 위치가 맞는지 확인하여 맞다면
		if(index >= 0){
			
			//위치된 인덱스값 지우고
			locationCells.remove(index);
			
			//인덱스가 비웠는지 확인하여
			if(locationCells.isEmpty()){
				//모두 비웠으면 kill
				result = "kill";
			}else{
				//남아있다면 hit
				result = "hit";
			}
		}
		
		//결과값 반환
	return result;
	}
}


}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
==================================================================
import java.util.*;

public class DotComBust {

	//인스턴스 변수 선언
	private GameHelper helper = new GameHelper();
	//닷컴 목록을 저장하기 위한 배열생성
	private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();
	//사용자가 추측한 횟수를 저장하기 위해
	private int numOfGuesses = 0;
	
	
	//닷컴 객체를 초기화 하여 이름과 위치를 지정
	private void setUpGame(){
		
		DotCom one = new DotCom();
		one.setName("Pets.com");
		DotCom two = new DotCom();
		two.setName("eToys.com");
		DotCom three = new DotCom();
		three.setName("Go2.com");
		
		//초기화된 객체 리스트 목록에 추가
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three);
			
		System.out.println("Your goal is to sink three dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in the fewest number of guesses");
		
		//생성된 객체들 위치 지정
		for(DotCom dotComToSet : dotComsList){
			//무작위로 선택된 닷컴의 위치를 구함
			ArrayList<String> newLocation = helper.placeDotCom(3);
			dotComToSet.setLocationCells(newLocation);
		}
	}
	
	//객체가 없어질때까지 사용자로부터 추측한 위치 받아들임
	private void startPlaying(){
		
		while(!dotComsList.isEmpty()){
			//입력받음
			String userGuess = helper.getUserInput("Enter a guess");
			//사용자가 추측한 위치를 평가
			checkUserGuess(userGuess);
		}
		finishGame();
	}
	
	//사용자가 입력한 값이 hit or miss 인지 판단
	private void checkUserGuess(String userGuess){
		
		//추측횟수 증가시키고
		numOfGuesses++;
		String result = "miss";
		
		//객체에 대한 반복
		for(DotCom dotComToTest : dotComsList){
			
			//사용자가 추측한 위치를 평가
			result = dotComToTest.checkYourself(userGuess);
			
			//리턴값에 따라 평가함
			if(result.equals("hit")){
				break;
			}
			//체크해본 결과 kill이라면 리스트에서 제거
			if(result.equals("kill")){
				dotComsList.remove(dotComToTest);
				break;
			}
		}
		System.out.println(result);
	}
	
	//사용자가 추측한 성적에 대한 메시지를 출력하는 함수
	private void finishGame(){
		
		System.out.println("All Dot Coms are dead! your stock is now worthless.");
		
		//추측횟수가 18회 이하이면 축하메세지를
		if(numOfGuesses <= 18){
			System.out.println("It only took you" + numOfGuesses + "guesses.");
			System.out.println("You got out before your options sank.");
		}else{
			System.out.println("Took you long enough." + numOfGuesses + "guesses.");
			System.out.println("Fish are dancing with your options");
		}
	}
	
	public static void main(String[] args){
		
		//게임 객체를 생성
		DotComBust game = new DotComBust();
		//게임객체에 대한 설정
		game.setUpGame();
		//주 게임 진행 순환문을 돌리라는 명령
		game.startPlaying();
	}
}
======================================================================

import java.util.*;

public class DotCom {
		
		//셀 위치가 들어있는 리스트
		private ArrayList<String> locationCells;
		//닷컴의 이름
		private String name;
		
		//닷컴위치를 갱신하는 메소드
		public void setLocationCells(ArrayList loc){
			
			locationCells = loc;
		}
		
		
		public void setName(String n){
			name = n;
		}
		
		
		public String checkYourself(String userInput){
			
			String status = "miss";
			
			//사용자가 추측한 위치가 리스트에 들어있으면 그 항복 인덱스 리턴, 아닐경우 -1리턴
			int index = locationCells.indexOf(userInput);
			
			if(index >= 0){
				
				//remove()메소드를 통해 맞춘 항목을 지움
				locationCells.remove(index);
				
				//isEmpty메소드를 통하여 모든위치를 맞췄는지 확인
				if(locationCells.isEmpty()){
					status = "kill";
					System.out.println("Ouch! you sunk" + name + " : (");
				}else{
					status = "hit";
				}
			}
			
			//결과값을 리턴
			return status;
		}
		
}
===========================================================================
import java.io.*;
import java.util.*;

public class GameHelper {

	private static final String alphabet = "abcdefg";
	//게임판의 가로 사이즈
	private int gridLength = 7;
	//게임의 총 칸수
	private int gridSize = 49;
	private int[] grid = new int[gridSize];
	private int comCount = 0;
	
	
	//사용자로부터 입력을 받아옴
	public String getUserInput(String prompt){
		
		String inputLine = null;
		System.out.println(prompt + " ");
		
		try{
			//인풋스트림을 통해 한줄을 읽어 들임
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) return null;
		}catch(IOException e){
			System.out.println("OException:" + e);
		}
		//사용자가 입력한 결과값 리턴
		return inputLine.toLowerCase();
		
	}
	
	public ArrayList<String> placeDotCom(int comSize){
		
		ArrayList<String> alphaCells = new ArrayList<String>();
		String temp = null; // 나중에 연결하기 위한 임시 배열
		int[] coords = new int[comSize];  //현재 후보 좌표
		int attempts = 0;  //시도횟수
		boolean success = false;  //위치를 찾았는지 나타내기 위해서
		int location = 0;  //현재 시작위치
		

		comCount ++;  //n번째 닷컴
		int incr = 1;  //수평 방향으로 증가시킬 값 설정
		if((comCount%2) == 1){ //홀수번째 닷컴인 경우 수직으로 배치
			incr = gridLength; // 수직으로 증가시킬 값 설정
		}
		
		
		while(!success & attempts++ < 200){
			
			location = (int)(Math.random() * gridSize); //임이의 시작위치를 구함
			int x = 0;
			success = true;  //성공할 것으로 가정함
			
			
			while(success && x < comSize){  //닷컴이 비어있는지 확인
				
				if(grid[location] ==0){  //아직 사용하지 않았다면
					coords[x++] = location; // 위치저장
					location += incr;  // 다음 칸 확인
					if(location >= gridSize){  // 경계를 벗어난 경우
						success = false;
					}
					if(x>0 & (location % gridLength ==0)){  //경계를 벗어난 경우(오른쪽)
						success = false;
					}
				}else{  // 이미 사용중인 경우
						success = false;
				}
			}
		}
		
		int x = 0;  // 위치를 알파벳 좌표로 바꿈
		int row = 0;
		int column = 0;
		
		while(x < comSize){
			grid[coords[x]] = 1;  // 기본 좌표를 사용중으로 표시 
			row = (int)(coords[x]/gridLength); // 행값을 구함
			column = coords[x] % gridLength;  // 열값을 구함
			
			temp = String.valueOf(alphabet.charAt(column));  //숫자된 열을 알파벳으로 변환
			
			alphaCells.add(temp.concat(Integer.toString(row)));
			x++;
		}
		
		return alphaCells;
	}
}

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 한클래스가 다른 클래스를 포함하는 것
 * 다형성: 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Feline extends Animal();
public class Hippo extends Animal();
public class Canine extends Animal();

public class Lion extends Feline();
public class Tiger extends Feline();
public class Cat extends Feline();

public class Wolf extends Canine();
public class Dog extends Canine();
}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:상속받은 메서드의 내용을 변경하는 것을 
 * 오버로딩: 한 클래스 내에서 같은 이름의 메서드를 여러개 정의하는 것을 


*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class MonsterTestDrive {
	public static void main(String [] args){
		
		//객체를 저장할 배열생성
		Monster [] ma  = new Monster[3];
		
		//배열에 해당 객체들 생성하여 삽입
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		
		//배열요소마다 frighten메소드 실행
		for(int x = 0; x<3; x++){
			ma[x].frighten(x);
		}
	}
}

// 몬스터 객체 호출시
class Monster{
	boolean frighten(int d){
		System.out.println("arrrgh");
		//결과값 반환
		return true;
	}
}

//뱀파이어 객체 호실시, 몬스터 객체 상속받음
class Vampire extends Monster{
	//몬스터 객체의 frighten메소드 오버라이딩 됨
	boolean frighten(int x){
		System.out.println("a bite?");
		//결과값 반환
		return false;
	}
}
	
//Dragon객체 호출시, 몬스터 객체 상속받음
class Dragon extends Monster{
	//몬스터 객체의 frighten메소드 오버라이딩 됨
	boolean frighten(int degree){
		System.out.println("Breath fire");
		//결과값 반환
		return true;
	}
}



}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 추상클래스
 * 다형성: 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 형태에 속하는 것이 허가되는 성질
 * 추상 클래스: 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스
 * 추상 메소드: 반드시 오버라이드 해야 하는 메소드를 의미
 * 다중 상속: 어떤 글래스(class)가 하나 이상의 상위 클래스(superclass)로부터 여러 가지 행동(behaviors)이나 특징(features)을 상속받을 수 있다는 것

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 모든 객체
 * 스택에서의 변수: 메소드와 지역변수
 * 생성자: 객체가 실행될때 실행되는 코드 초기화 하기위해서
 * 널 레퍼런스: 해당 레퍼런스가 가리키고 없다는 것을 의미
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체의 변수, 객체가 살아있는 동안 유지됨
 * 지역 변수: 메소드 내의 변수

*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.ArrayList;

import java.util.*;

class V2Radiator{
		
		//V2 생성자 
        V2Radiator(ArrayList list){
                for(int x=0; x<5; x++){
                		//리스트에 인덱스 추가
                        list.add(new SimUnit("V2Radiator"));
                }
        }
}

class V3Radiator extends V2Radiator{
        
		//V3생성자
        V3Radiator(ArrayList lglist){
        		//상속받은 객체 먼저 초기화
                super(lglist);
                for(int x=0; x<5; x++){
                	lglist.add(new SimUnit("V2Radiator"));
                }
        }
}

class RetentionBot{
	
	//RetentionBot 생성자 초기화
	RetentionBot(ArrayList rlist){
		//리스트에 인덱스 추가
		rlist.add(new SimUnit("Retention"));
	}
}

//테스트 클래스 정의
public class TestLifeSupportSim {
        public static void main(String [] args){
        	
        		//배열생성
                ArrayList aList = new ArrayList();
                //객체 생성하고 생성자 초기화 작업함
                V2Radiator v2 = new V2Radiator(aList);
                V3Radiator v3 = new V3Radiator(aList);
                
                //RetentionBot 생성하고 리스트 만듬
                for(int z = 0; z<20; z++){
                        RetentionBot ret = new RetentionBot(aList);
                }
        }
}

class SimUnit{
	String botType;
	//전달받은 인자 비교하기 위해서
	SimUnit(String type){
		botType = type;
	}
	
	int powerUse(){
		//Retention 문자열을 입력받은경우
		if("Retention".equals(botType)){
			return 2;
		}else{
			return 4;
		}
	}
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 클래스의 인스턴스없이 메소드를 실행할 수 있음
 * 정적 메소드를 선언하는 방법: static이라는 키워드 사용
 * static final: 이렇게 선언된 변수는 상수이다.
 * 널 레퍼런스: 해당 레퍼런스가 가리키고 있는것이 없다는 것을 의미
 * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 해줌
 * 정적 임포트: static을 활용하여 임포트 시키는 방법

*339p Calendar* _구현후 주석달기_

{{{
//추후 사용할 클래스에 대한 라이브러이 임포트
import java.util.*;
import static java.lang.System.out;

public class FullMoons {

		//DAY를 상수값으로 고정
		static int DYA_IM = 1000*60*60*24;
		
		public static void main(String[] args){
			//캘린더 클래스로부터 인스턴스 얻음
			Calendar c = Calendar.getInstance();
			
			//c인스턴스에 변수값 설정
			c.set(2004,0,7,15,40);
			
			//경과한 날짜와 시각을 밀리초 단위로 표현
			long day1 = c.getTimeInMillis();
			
			//월단위 체크
			for(int x =0; x<60; x++){
				day1 += (DYA_IM*29.52);
				//밀리단위로 날짜를 day1으로 고정
				c.setTimeInMillis(day1);
				out.println(String.format("full moon on %tc", c));
			}
		}
}


}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 인스턴스마다 하나씩 있는 변수
 * 정적 변수: 클래스마다 하나씩 있는 변수, 클래스 안에서 모든 인스턴스에 의해 공유됨

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}