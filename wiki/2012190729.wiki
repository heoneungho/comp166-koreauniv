#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99;
		String word = "bottles"; //복수형
		
		while (beerNum >0) {
			if(beerNum == 1) {
				word = "bottle";
			}
		
			System.out.println(beerNum + " "+word+" of beer on the wall");
			System.out.println(beerNum + " "+word+" of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum -1;

			if (beerNum > 0) {
				System.out.println(beerNum + " "+word+" of beer on the wall");
			} else {
				System.out.println("No more bottles of beer on the wall");
			} //else 문 끝
		} //while 순환문 끝
	} //main 클래스 끝
} //클래스끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String [] args) {
	//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String [] wordListOne={"24/7", "multi-Tier", "30,000 foot", "B-to-B", "win-win", "front-end", "web-based", "pervasive", "smart", "six-sigma", "critical-path", "dynamic"};
		
		String [] wordListTwo = {"empowered", "sticky", "value-added", "oriented", "centric", "distributed", "clustered", "branded", "outside-the-box", "positioned", "networked", "focused", "leveraged", "aligned", "targeted", "shared", "cooperative", "accelerated"};

		String [] wordListThree = {"process", "tipping-point", "solution", "architecture", "core competency", "strategy", "mindshare", "portal", "space", "vision", "paradigm", "mission"};
		
		// 각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;

		//난수 세개 발생시킵니다.
		int rand1 = (int) (Math.random()*oneLength);
		int rand2 = (int) (Math.random()*twoLength);
		int rand3 = (int) (Math.random()*threeLength);

		//이제 구문을 만듭니다. 
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

		//구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 바이트 코드를 해석해서 실행하는 소프트웨어.
 * 컴파일러: 자바 언어로 기술된 프로그램을 바이트 코드라는 중간 코드로 변환시킨다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_
을
{{{
A. 
class Exercise1b {
	public static void main(String [] args) {
		int x = 1;
		while (x<10){
			x=x+1; //  while이 infite 하게 돌아가지 않게 x를 하나씩 늘려주어야한다.
			if(x>3) {
				System.out.println("big x");
			}
		}
	}
}

B.
class Exercise 1b{ // 클래스를 정의해주어야 컴파일 가능하다.
	public static void main(String [] args){
		int x = 5;
		while (x>1) {
			x = x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}


C.
class Exercise1b{
	public static void main(String [] args) { // 클래스 내 메소드 안에 코드가 있어야한다.
		int x = 5;
		while (x>1) {
			x = x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태를 나타낸다, 객체에서 자신에 대해 아는 것
 * 메소드:  객체의 행동, 객체에서 자신이 하는 것
 * 클래스: 객체, 인스턴스를 만들기 위해 쓰인다, 실제로 사용할 객체의 유형을 나타냄(객체를 만들기 위한 청사진, 가상 머신에 그 유형의 객체를 만드는 방법을 알려ㅅ주는 역할)
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트 해보는 일을 한다. main() 메소드가 들어간다.
 

*68p Television* _채워넣기_스

 * 인스턴스 변수:  volume, channel ,
 * 메소드: setOn ,setVolume, setChannel, setOff


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame{
	Player p1;
   Player p2;
   Player p3;
   Player p4;

   public void startGame() {
   	p1=new Player();
   	p2=new Player();
        p3=new Player();

      int guessp1=0;
      int guessp2=0;
      int guessp3=0;
      int guessp4=0;

      boolean p1isRight =false;
      boolean p2isRight =false;
      boolean p3isRight =false;
      boolean p4isRight =false;

      int targetNumber = (int) (Math.random() *10);
      System.out.println("0 이상 9 이하의 숫자를 맞취보세요.");

      while(true) {
      	System.out.println ("맞취야 하 숫자는" + targetNumber + "입니다.");

         p1. guess ();
         p2. guess ();
         p3. guess ();
         p4. guess ();

         guessp1 = p1.number;
         System.out.println("1번 선수가 찍은 숫자:" + guessp1);

         guessp2 = p2.number;
         System.out.println("2번 선수가 찍은 숫자:" + guessp2);

         guessp3 = p3.number;
         System.out.println("3번 선수가 찍은 숫자:" + guessp3);

         guessp4 = p4.number;
         System.out.println("4번 선수가 찍은 숫자:" + guessp4);

			if (guessp1 == targetNumber) {
				p1isRight =true;
			}

			if(guessp2==targetNumber) {
				p2isRight=true;
			}
			
			if(guessp3==targetNumber) {
				p3isRight=true;
			}

			if(guessp4==targetNumber) {
				p4isRight=true;
			}

			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				System.out.println("맞춘선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			}	//if/else 부분 끝
		}	//순환문 끝
	}	//메소드 끝
}	//클래스 끝


public class Player {
	int number = 0; //찍은 숫자를 저장할 변수

	public void guess() {
		number = (int) (Math.random() *10);
		System.out.println("찍은 숫자: " + number);
	}
}


public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame ();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class TapeDeck{
	boolean canRecord = false;

	void playTape() {
	 System.out.println("tape playing");
	}
}

class TapeDeckTestDrive {
	public static void main (String [] args) {
		t.canRecord = true;
		t.playTape();

		if(t.canRecord == true) {
			t.recordTape();
		}
	}
}

B.
class DVDPlayer {
	boolean canRecord = false;

	void recordDVD () {
		system.out.println("DVD recording");
	}
}
class DVDPlayerTestDrive {
	public static void main (String [] args) {
	
		DVDPlayer d = new DVDPlayer ();
		d.canRecord = true;
		d.playDVD ();

		if(d.canREcord == true) {
			d.recordDVD ();
		}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 원시변수는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다.
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
	String name;
	public static void main (String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";

		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[3];
		//그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;


		// 배열 레퍼런스를 써서 Dog객체에 
		//접근합니다.
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";


		// myDogs[2]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[2].name);


		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
        
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat() {}
	public void chaseCat() {}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
                        
A.
class Books {
	String title;
	String author;
}

class BooksTestDrive {
	public static void main (String [] args) {
	
		Books [] myBooks = new Books [3];
		int x = 0;
		myBooks [0].title = "The Grapes of Java";
		myBooks [1].title = "The Java Gatsby";
		myBooks [2].title = "The Java Cookbook";
		myBooks [0].author = "bob";
		myBooks [1].author = "sue";
		myBooks [2].author = "ian";

		while (x<3) {
			System.out.print(myBooks[x].title);
			System.out.print("by");
			System.out.println(myBooks[x].author);
			x = x+1;
		}
	}
}


B.

class Hobbits {   
	String name;
	
	public static void main (String [] args) {
		Hobbits [] h = new Hobbits [3];
		int z =0;

		while (z<4) {
			z=z+1;
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if (z==1) {
				h[z].name = "frodo";
			}
			if (z==2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + "is a");
			System.out.println("good Hobbit name");
		}
	}
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드에서는 while 순환문으로 연락처 10개를 만들때 refc라는 변수 하나에 10개의 contact들을 다 대입시켰다. 순환문이 돌때마다  refc가 갱신되기 때문에 결국 refc에는 마지막 contact밖에 남아있지 않는다. 켄트의 코드는 객체 10개를 모두 save하지 못한다. 그리하여 밥이 이겼다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 데이터가 모두 노출되지 못하게 즉 다른 코드에서 데이터를 직접 접근할 수 없도록 한다.캡슐화를 하려면 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다.
 * 게터와 세터: 게터는 게터가 가져오기로 되어있는값을 리턴값 형대로 받아오기 위한 용도로만 쓰입니다. 정식 명칭은 액세서(accessor)이다.
세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수:
인스턴스 변수는 힙에 들어가고 지역변수는 스택에 들어가므로 지역변수가 효율적이지만 지역변수는 어떤 블록 내에서만 선언되고 다른 블록에고 그것을 사용하는 것은 불가능하다.
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;

	void bark() {
		if (size >60) {
			System.out.println("Woof! Woof!");
		} else if (size >14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {

	public static void main (String[] args) {
		Dog one= new Dog();
		one.size =70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog ();
		three.size =35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class XCopy {
	public static void main(String [] args) {
	int orig = 42; 
	XCopy x = new XCopy(); 
	int y = x.go(orig); // y에  x.go(orig)= x.go( int 42)=42*2=84 (go 함수 실행)
	System.out.println(orig + " " + y); // 42 84 출력
}
로
	int go(int arg) {
		arg = arg * 2; //  42 실행하면 두배 하여 84 값으로return해준다.
		return arg;
	 }
}

출력결과:42 84

B.
class Clock {
	String time;

	void setTime(String t) {
		time = t;
	}

	String getTime() { // return 타입이  time 이므로 void가 아닌 String으로 지정한다.
		return time;
	}
} // 이함수는 setTime에 변수를 넣으면 그 변수가 리턴되는 꼴이다.

class ClockTestDrive {
	public static void main(String [] args) {
                
		Clock c = new Clock();
                
		c.setTime("1235"); // 초기 setTime 에 time=1235가 리턴되어 세팅된다.
		String tod = c.getTime(); // tod에 getTime 함수에서 return 되는 time값, 즉 1235가 대입된다.
		System.out.println("time:"+tod);
	}
}

출력결과: time 1235
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 90년대 말 등장한 소프트웨어 개발 방법으로서 막판에 고객이 스펙을 바꾸려고 해도 원하는 기한에 맞추어서 바뀐 스펙으로 제공할 수 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
상수와 추상메소드로 구성되어 있으므로 다른 클래슬에서 공통된 메소드들이 구현되었으면 했을 때 인터페이스 내부에서 공통기능을 선언하면된다.
이는 서로 관련없는 클래스들을 묶어줄 수 있으면서 독립적 프로그래밍이 가능하다.
 * 다형성:
말 그대로 형태가 다양하게 여러가지라는 것인데, 이 여러가지를 하나의 그릇에 담게 하는 것이다. 이때의 장점은 새로운 하위클래서가 생겨도 코드를 수정하지 않아도 된다는 점이다.
 * 추상 클래스: 클래스를 abstract로 지정한 것. 추상 메소드를 만들기 위해선 추상 클래스가 필요하다.
 * 추상 메소드: 메소드를 abstract로 지정한 것, 하위 클래스를 위한 프로토콜의 일부 정의를 함
 * 다중 상속: 여러 부모 클래스에서 상속받은 것을 의미

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}