#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99;
		String word = "bottles"; //복수형
		
		while (beerNum >0) {
			if(beerNum == 1) {
				word = "bottle";
			}
		
			System.out.println(beerNum + " "+word+" of beer on the wall");
			System.out.println(beerNum + " "+word+" of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum -1;

			if (beerNum > 0) {
				System.out.println(beerNum + " "+word+" of beer on the wall");
			} else {
				System.out.println("No more bottles of beer on the wall");
			} //else 문 끝
		} //while 순환문 끝
	} //main 클래스 끝
} //클래스끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String [] args) {
	//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String [] wordListOne={"24/7", "multi-Tier", "30,000 foot", "B-to-B", "win-win", "front-end", "web-based", "pervasive", "smart", "six-sigma", "critical-path", "dynamic"};
		
		String [] wordListTwo = {"empowered", "sticky", "value-added", "oriented", "centric", "distributed", "clustered", "branded", "outside-the-box", "positioned", "networked", "focused", "leveraged", "aligned", "targeted", "shared", "cooperative", "accelerated"};

		String [] wordListThree = {"process", "tipping-point", "solution", "architecture", "core competency", "strategy", "mindshare", "portal", "space", "vision", "paradigm", "mission"};
		
		// 각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;

		//난수 세개 발생시킵니다.
		int rand1 = (int) (Math.random()*oneLength);
		int rand2 = (int) (Math.random()*twoLength);
		int rand3 = (int) (Math.random()*threeLength);

		//이제 구문을 만듭니다. 
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

		//구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 바이트 코드를 해석해서 실행하는 소프트웨어.
 * 컴파일러: 자바 언어로 기술된 프로그램을 바이트 코드라는 중간 코드로 변환시킨다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_
을
{{{
A. 
class Exercise1b {
	public static void main(String [] args) {
		int x = 1;
		while (x<10){
			x=x+1; //  while이 infite 하게 돌아가지 않게 x를 하나씩 늘려주어야한다.
			if(x>3) {
				System.out.println("big x");
			}
		}
	}
}

B.
class Exercise 1b{ // 클래스를 정의해주어야 컴파일 가능하다.
	public static void main(String [] args){
		int x = 5;
		while (x>1) {
			x = x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}


C.
class Exercise1b{
	public static void main(String [] args) { // 클래스 내 메소드 안에 코드가 있어야한다.
		int x = 5;
		while (x>1) {
			x = x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태를 나타낸다, 객체에서 자신에 대해 아는 것
 * 메소드:  객체의 행동, 객체에서 자신이 하는 것
 * 클래스: 객체, 인스턴스를 만들기 위해 쓰인다, 실제로 사용할 객체의 유형을 나타냄(객체를 만들기 위한 청사진, 가상 머신에 그 유형의 객체를 만드는 방법을 알려ㅅ주는 역할)
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트 해보는 일을 한다. main() 메소드가 들어간다.
 

*68p Television* _채워넣기_스

 * 인스턴스 변수:  volume, channel ,
 * 메소드: setOn ,setVolume, setChannel, setOff


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame{
	Player p1;
   Player p2;
   Player p3;
   Player p4;

   public void startGame() {
   	p1=new Player();
   	p2=new Player();
        p3=new Player();

      int guessp1=0;
      int guessp2=0;
      int guessp3=0;
      int guessp4=0;

      boolean p1isRight =false;
      boolean p2isRight =false;
      boolean p3isRight =false;
      boolean p4isRight =false;

      int targetNumber = (int) (Math.random() *10);
      System.out.println("0 이상 9 이하의 숫자를 맞취보세요.");

      while(true) {
      	System.out.println ("맞취야 하 숫자는" + targetNumber + "입니다.");

         p1. guess ();
         p2. guess ();
         p3. guess ();
         p4. guess ();

         guessp1 = p1.number;
         System.out.println("1번 선수가 찍은 숫자:" + guessp1);

         guessp2 = p2.number;
         System.out.println("2번 선수가 찍은 숫자:" + guessp2);

         guessp3 = p3.number;
         System.out.println("3번 선수가 찍은 숫자:" + guessp3);

         guessp4 = p4.number;
         System.out.println("4번 선수가 찍은 숫자:" + guessp4);

			if (guessp1 == targetNumber) {
				p1isRight =true;
			}

			if(guessp2==targetNumber) {
				p2isRight=true;
			}
			
			if(guessp3==targetNumber) {
				p3isRight=true;
			}

			if(guessp4==targetNumber) {
				p4isRight=true;
			}

			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				System.out.println("맞춘선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			}	//if/else 부분 끝
		}	//순환문 끝
	}	//메소드 끝
}	//클래스 끝


public class Player {
	int number = 0; //찍은 숫자를 저장할 변수

	public void guess() {
		number = (int) (Math.random() *10);
		System.out.println("찍은 숫자: " + number);
	}
}


public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame ();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class TapeDeck{
	boolean canRecord = false;

	void playTape() {
	 System.out.println("tape playing");
	}
}

class TapeDeckTestDrive {
	public static void main (String [] args) {
		t.canRecord = true;
		t.playTape();

		if(t.canRecord == true) {
			t.recordTape();
		}
	}
}

B.
class DVDPlayer {
	boolean canRecord = false;

	void recordDVD () {
		system.out.println("DVD recording");
	}
}
class DVDPlayerTestDrive {
	public static void main (String [] args) {
	
		DVDPlayer d = new DVDPlayer ();
		d.canRecord = true;
		d.playDVD ();

		if(d.canREcord == true) {
			d.recordDVD ();
		}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 원시변수는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다.
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
	String name;
	public static void main (String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";

		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[3];
		//그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;


		// 배열 레퍼런스를 써서 Dog객체에 
		//접근합니다.
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";


		// myDogs[2]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[2].name);


		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
        
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat() {}
	public void chaseCat() {}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
                        
A.
class Books {
	String title;
	String author;
}

class BooksTestDrive {
	public static void main (String [] args) {
	
		Books [] myBooks = new Books [3];
		int x = 0;
		myBooks [0].title = "The Grapes of Java";
		myBooks [1].title = "The Java Gatsby";
		myBooks [2].title = "The Java Cookbook";
		myBooks [0].author = "bob";
		myBooks [1].author = "sue";
		myBooks [2].author = "ian";

		while (x<3) {
			System.out.print(myBooks[x].title);
			System.out.print("by");
			System.out.println(myBooks[x].author);
			x = x+1;
		}
	}
}


B.

class Hobbits {   
	String name;
	
	public static void main (String [] args) {
		Hobbits [] h = new Hobbits [3];
		int z =0;

		while (z<4) {
			z=z+1;
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if (z==1) {
				h[z].name = "frodo";
			}
			if (z==2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + "is a");
			System.out.println("good Hobbit name");
		}
	}
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드에서는 while 순환문으로 연락처 10개를 만들때 refc라는 변수 하나에 10개의 contact들을 다 대입시켰다. 순환문이 돌때마다  refc가 갱신되기 때문에 결국 refc에는 마지막 contact밖에 남아있지 않는다. 켄트의 코드는 객체 10개를 모두 save하지 못한다. 그리하여 밥이 이겼다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 데이터가 모두 노출되지 못하게 즉 다른 코드에서 데이터를 직접 접근할 수 없도록 한다.캡슐화를 하려면 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다.
 * 게터와 세터: 게터는 게터가 가져오기로 되어있는값을 리턴값 형대로 받아오기 위한 용도로만 쓰입니다. 정식 명칭은 액세서(accessor)이다.
세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수:
인스턴스 변수는 힙에 들어가고 지역변수는 스택에 들어가므로 지역변수가 효율적이지만 지역변수는 어떤 블록 내에서만 선언되고 다른 블록에고 그것을 사용하는 것은 불가능하다.
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;

	void bark() {
		if (size >60) {
			System.out.println("Woof! Woof!");
		} else if (size >14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {

	public static void main (String[] args) {
		Dog one= new Dog();
		one.size =70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog ();
		three.size =35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class XCopy {
	public static void main(String [] args) {
	int orig = 42; 
	XCopy x = new XCopy(); 
	int y = x.go(orig); // y에  x.go(orig)= x.go( int 42)=42*2=84 (go 함수 실행)
	System.out.println(orig + " " + y); // 42 84 출력
}
로
	int go(int arg) {
		arg = arg * 2; //  42 실행하면 두배 하여 84 값으로return해준다.
		return arg;
	 }
}

출력결과:42 84

B.
class Clock {
	String time;

	void setTime(String t) {
		time = t;
	}

	String getTime() { // return 타입이  time 이므로 void가 아닌 String으로 지정한다.
		return time;
	}
} // 이함수는 setTime에 변수를 넣으면 그 변수가 리턴되는 꼴이다.

class ClockTestDrive {
	public static void main(String [] args) {
                
		Clock c = new Clock();
                
		c.setTime("1235"); // 초기 setTime 에 time=1235가 리턴되어 세팅된다.
		String tod = c.getTime(); // tod에 getTime 함수에서 return 되는 time값, 즉 1235가 대입된다.
		System.out.println("time:"+tod);
	}
}

출력결과: time 1235
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 90년대 말 등장한 소프트웨어 개발 방법으로서 막판에 고객이 스펙을 바꾸려고 해도 원하는 기한에 맞추어서 바뀐 스펙으로 제공할 수 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
import java.io.*;
public class SimpleDotComTestDrive {
	public static void main (String[] args) {
		SimpleDotCom dot = new SimpleDotCom(); // SimpleDotCom클래스의 인스턴스 만들기

		int[] locations = {3,4,5}; // 닷컴 위치를 나타내기 위해 int배열(0~6 연속된 정수 3개)을 만든다.
		dot.setLocationCells (locations);
	
		String userGuess = "3"; //사용자가 추측한 위치 역할을 할 가짜값 만들기
		String result = dot.checkYourself(userGuess); //닷컴 객체에 대해 checkYourself 메소드 호출하고 그 메소드에 가짜값 전달		
		String testResult = "failed";

		if (result.equals ("hit")) {
			testResult = "passed"; // 가짜값이 맞으면 ("hit"가 리턴되면), 제대로 작동
		}
		System.out.println(testResult); // 테스트 결과 출력
	}
}


import java.io.*;
public class SimpleDotCom {
	int[] locationCells;
	int numOfHits = 0;

	public void setLocationCells (int[] locs) {
		locationCells=locs;
	}

	public String checkYourself (String stringGuess) {
		int guess = Integer.parseInt(stringGuess); //String을 int로 변환
		String result = "miss"; //리턴할 결과를 저장할 변수를 만든다. 기본값은 "miss"로. (못맞추는 것을 기본값으로)

		for(int i=0; i<locationCells.length; i++) { //배열에 들어있는 각 원소 (객체의 각 위치 셀)에 대해 반복합니다.
			if(guess==locationCells[i]) { //배열에 들어있는 각 원소 (객체의 각 위치 셀)에 대해 반복합니다.
				result = "hit";
				numOfHits++; // 맞을때
				break;
			}
		}
		if(numOfHits == locationCells.length) {
			result = "kill"; //순환문 밖으로 나왔지만 그 객체가 죽었는지 (3번 맞았는지) 확인 해보고, 그 경우에는 result 라를 String을 "kill"로 바꾼다.
		} 
		System.out.println(result);
		return result;
	}
}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
public class DotComFirst {
	int[] locationCells;
	boolean[] hitCells //사용자가 위치를 맞출 때마다 그 배열을 확인하여 그 셀을 이미 맞췄는지 확인
	int numOfHits = 0;

	public void setLocationCells (int[] locs) {
		locationCells=locs;
	}

	public String checkYourself (String stringGuess) {
		int guess = Integer.parseInt(stringGuess); //String을 int로 변환
		String result = "miss"; //리턴할 결과를 저장할 변수를 만든다. 기본값은 "miss"로. (못맞추는 것을 기본값으로)

		for(int i=0; i<locationCells.length; i++) { //배열에 들어있는 각 원소 (객체의 각 위치 셀)에 대해 반복합니다.
			if(guess==locationCells[i] && hitCellsp[i] !=true) { //이미 맞춘 문제가 아닐때만
				result = "hit";
				numOfHits++; // 맞을때
				break;
			}
		}
		if(numOfHits == locationCells.length) { //마지막 
			result = "kill"; //순환문 밖으로 나왔지만 그 객체가 죽었는지 (3번 맞았는지) 확인 해보고, 그 경우에는 result 라를 String을 "kill"로 바꾼다.
		} 
		System.out.println(result);
		return result;
	}
}
}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
public class DotComSecond {
	int[] locationCells;
	int numOfHits = 0;

	public void setLocationCells (int[] locs) {
		locationCells=locs;
	}

	public String checkYourself (String stringGuess) {
		int guess = Integer.parseInt(stringGuess); //String을 int로 변환
		String result = "miss"; //리턴할 결과를 저장할 변수를 만든다. 기본값은 "miss"로. (못맞추는 것을 기본값으로)

		for(int i=0; i<locationCells.length; i++) { //배열에 들어있는 각 원소 (객체의 각 위치 셀)에 대해 반복합니다.
			if(guess==locationCells[i] && hitCells[i] !=-1) { // -1이면 이미 맞춘 문제
				result = "hit";
				locationCells[i]=-1 
				numOfHits++; // 맞을때
				break;
			}
		}
		if(numOfHits == locationCells.length) { //마지막 
			result = "kill"; //순환문 밖으로 나왔지만 그 객체가 죽었는지 (3번 맞았는지) 확인 해보고, 그 경우에는 result 라를 String을 "kill"로 바꾼다.
		} 
		System.out.println(result);
		return result;
	}
}
}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
상수와 추상메소드로 구성되어 있으므로 다른 클래슬에서 공통된 메소드들이 구현되었으면 했을 때 인터페이스 내부에서 공통기능을 선언하면된다.
이는 서로 관련없는 클래스들을 묶어줄 수 있으면서 독립적 프로그래밍이 가능하다.
 * 다형성:
말 그대로 형태가 다양하게 여러가지라는 것인데, 이 여러가지를 하나의 그릇에 담게 하는 것이다. 이때의 장점은 새로운 하위클래서가 생겨도 코드를 수정하지 않아도 된다는 점이다.
 * 추상 클래스: 클래스를 abstract로 지정한 것. 추상 메소드를 만들기 위해선 추상 클래스가 필요하다.
 * 추상 메소드: 메소드를 abstract로 지정한 것, 하위 클래스를 위한 프로토콜의 일부 정의를 함
 * 다중 상속: 여러 부모 클래스에서 상속받은 것을 의미

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.event.*; //ActionListener와 ActionEvent를 포함하는 import 선언

public class SimpleGuilB implements ActionListener {   // 인스턴스 ActionListener를 SimpleGuilB에 사용
	JButton button;
	
	public static void main (String[] args) {
		SimpleGuilB gui = new SimpleGuilB();
		gui.go();
	}

	public void go() {
		JFrame frame = new JFrame ();
		button = new JButton("click me");

		button.addActionListener(this); // 버튼에 등록,  리스너 목록에 포함 시킴
	
		frame.getContentPane().add(button);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300,300);
		frame.setVisible(true);
	
	}

	public void actionPerformed(ActionEvent event) {
		button.setText("I've been clicked!"); // 버튼에서 메소드 호출 이벤트가 일어났다는 것을 알려줌
	}
}
}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {
	JFrame frame;
	public static void main (String[] args) {
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
		}

	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);

		JButton button = new JButton ("Change colors");
		button.addActionListener (this); // 리스너(this)를 버튼에 추가

		MyDrawPanel drawPanel = new MyDrawPanel();

		frame.getContentPane().add(BorderLayout.SOUTH, button); 
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel); // 위젯(버튼과 그림 패널) 두 개를 프레임의 두 지역에 추가
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	public void actionPerformed(ActionEvent event) {
		frame.repaint(); // 사용자가 버튼을 클릭하면 프레임의 repaint()메소드를 호출. 그러면 그 프레임에 들어있는 모든 위젯의 paintComponent()메소드가 호출됨
	}
}


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


public class MyDrawPanel extends JPanel {
	public void paintComponent(Graphics g) { //사용자가 버튼을 클릭할 떄마다 그림 패널의 paintComponent{} 메소드가 호출됨
		//타원을 무작위적으로 선택한 색으로 칠하기 위한 코드
		Graphics2D g2d = (Graphics2D) g;

		int red = (int) (Math.random() *256);
		int green = (int) (Math.random() *256);
		int blue = (int) (Math.random()*256);
		Color startColor = new Color (red, green, blue);

		red = (int) (Math. random () *256);
		green = (int) (Math.random()*256);
		blue = (int) (Math.random()*256);
		Color endColor = new Color (red,green,blue); // 그래디언트의 시작과 끝색을 무작위로 함

		GradientPaint gradient = new GradientPaint (70,70,startColor, 150,150, endColor);
		g2d.setPaint (gradient);
		g2d.fillOval(70,70,100,100);
	}
}
/* 시작과 끝색 지정
class MyDrawPanel extends JPanel {
	public void paintComponent(Graphics g) { //사용자가 버튼을 클릭할 떄마다 그림 패널의 paintComponent{} 메소드가 호출됨
		//타원을 무작위적으로 선택한 색으로 칠하기 위한 코드
		Graphics2D g2d = (Graphics2D) g;

		
		GradientPaint gradient = new GradientPaint (70,70(시작점),Color.blue(시작색), 150,150(끝점), endColor(끝색));
		g2d.setPaint (gradient); //이렇게 하면 가상 페인트 브러시를 단색이 아닌 그래디언트로 지정할 수 있음
		g2d.fillOval(70,70,100,100) //fillOval()메소드, 현재 페인트 브러시와 색칠함
	}
}
*/
}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


public class TwoButtons { //메인 GUI 클래스에서는 ActionListener 구현하지 않
	JFrame frame;
	JLabel label;

	public static void main (String[] args) {
		TwoButtons gui = new TwoButtons ();
		gui.go();
	}
	public void go () {
		frame = new JFrame ();
		frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
		
		JButton labelButton = new JButton ("Change Label");
		labelButton.addActionListener(new LabelListener()); // 버튼의 리스너 등록 메소드에 this가 아닌 다른 리스너 클래스(내부 클래스)를 가지고 만든 객체를 전달
		
		JButton colorButton = new JButton ("Change Circle");
		colorButton.addActionListener (new ColorListener());
		
		label = new JLabel ("I'm a label");
		MyDrawPanel drawPanel = new MyDrawPanel();

		frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.getContentPane().add(BorderLayout.EAST, labelButton);
		frame.getContentPane().add(BorderLayout.WEST, label);

		frame.setSize (400,300);
		frame.setVisible(true);
	}
	
	class LabelListener implements ActionListener { //이제 클래스 하나 안에 ActionLister 두개를 집어넣을 수 있음
		public void actionPerformed(ActionEvent event) {
			label.setText ("Ouch!"); // 내부 클래스에서도 'label'변수를 사용할 수 있음.
		}
	}
	class ColorListener implements ActionListener { //이제 클래스 하나 안에 ActionLister 두개를 집어넣을 수 있음
		public void actionPerformed(ActionEvent event) {
			frame.repaint(); //내부 클래스에서는 외부 클래스 객체에 대한 레퍼런스 없이 그냥 frame 인스턴스 변수를 사용하면 
		}
	}
}
}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
	
	int x =70;
	int y =70; //메인 GUI클래스에 원의  x와 y좌표를 저장하기 위한 인스턴스 변수 두 개를 만듦

	public static void main (String[] args) {
		SimpleAnimation gui = new SimpleAnimation ();
		gui.go();
	}
	
	public void go() {
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		MyDrawPanel drawPanel = new MyDrawPanel(); //위젯을 만들고 프레임에 집어넣기만 하면 됨
	
		frame.getContentPane().add(drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);

		//애니메이션 수행하는 부분
		for(int i=0; i<130; i++) {
			x++;
			y++;  //x,y좌표 증가

			drawPanel.repaint(); // 스스로 다시 칠하라고 패널에게 알림 (새로운 위치의 원을 볼 수 있게됨)
			
			try {
				Thread.sleep(50); //속도를 약간 줄임(안그러면 너무 빨라 안보일 수 있기 때문)
			} catch (Exception ex) {}
		}
	}
	
	class MyDrawPanel extends JPanel { //내부클래스
		public void paintComponent(Graphics g) {
			g.setColor(Color.white);
			g.fillRect(0,0,this.getWidth(), this.getHeight()); //getWidth()와 getHeight()는 JPanel로부터 상속 밭은 메소드

			g.setColor(Color.green);
			g.fillOval(x,y,40,40); //지속적으로 갱신되는 외부 클래스의 x와 y 좌표를 사용
		}
	} //내부 클래스 끝
} //외부 클래스 
}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{
import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {
	
	static JFrame f = new JFrame ("My First Music Video");
	static MyDrawPanel m1;

	public static  void main (String[] args) {
		MiniMusicPlayer3 mini = new MiniMusicPlayer3 ();
		mini.go();
	}

	public void setUpGui () {
		m1 = new MyDrawPanel();
		f.setContentPane(m1);
		f.setBounds(30,30,300,300);
		f.setVisible(true);
	}

	public void go() {
		setUpGui ();
		try {
			Sequencer sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequencer.addControllerEventListener(m1, new int[] {127});
			Sequence seq = new Sequence (Sequence.PPQ, 4);
			Track track = seq.createTrack();

			int r =0;
			for (int i=0; i<60; i+=4) {
				r=(int) ((Math.random() *50)+1);
				track.add(makeEvent(144,1,r,100,i));
				track.add(makeEvent(176,1,127,0,i));
				track.add(makeEvent(128,1,r,100,i+2));
			}

			sequencer.setSequence(seq);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	
	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent (a, tick);
		} catch (Exception e) {}
		return event;
	}

	class MyDrawPanel extends JPanel implements ControllerEventListener {
		boolean msg = false;
			
		public void controlChange (ShortMessage event) {
			msg = true;
			repaint();
		}
		public void paintComponent (Graphics g) {
			if (msg) {
				Graphics2D g2 = (Graphics2D) g;

				int r = (int) (Math.random()*250);
				int gr= (int) (Math.random()*250);
				int b = (int) (Math.random()*250);
				
				g.setColor (new Color (r,gr,b));

				int ht = (int) ((Math.random()*120) +10);
				int width = (int) ((Math.random()*120)+10);

				int x = (int) ((Math.random()*40) +10);
				int y = (int) ((Math.random()*40) +10);

				g.fillRect(x,y,ht,width);
				msg = false;
			}
		}
	}
}

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {
	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList;
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;

	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", "Open Hi-Hat", "Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", "Open Hi Conga"};
	int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};

	public static void main (String[] args) {
		new BeatBox().buildGUI();
	}

	public void buildGUI() {
		theFrame = new JFrame ("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel (layout);
		background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
		
		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box (BoxLayout.Y_AXIS);
		
		JButton start = new JButton("Start");
		start.addActionListener (new MyStartListener());
		buttonBox.add(start);
	
		JButton stop = new JButton ("Stop");
		start.addActionListener (new MyStartListener());
		buttonBox.add(start);

		JButton upTempo = new JButton("Tempo Up");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo);

		JButton downTempo = new JButton ("Tempo Down");
		downTempo.addActionListener (new MyDownTempoListener());
		buttonBox.add(downTempo);

		Box nameBox = new Box (BoxLayout.Y_AXIS);
		for (int i=0; i<16; i++) {
			nameBox.add(new Label (instrumentNames[i]));
		}
	
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);

		theFrame.getContentPane().add(background);

		GridLayout grid = new GridLayout (16,16);
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel (grid);
		background.add(BorderLayout.CENTER, mainPanel);

		for (int i=0; i<256; i++) {
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		}

		setUpMidi();

		theFrame.setBounds (50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);
	}
	
	public void setUpMidi() {
		try {
			sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence (Sequence.PPQ, 4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public void buildTrackAndStart() {
		int [] trackList = null;
		
		sequence.deleteTrack(track);
		track = sequence.createTrack();

		for (int i =0; i<16;i++) {
			trackList = new int[16];
			
			int key = instruments[i];
			for (int j=0; j<16; j++) {
				JCheckBox jc = checkboxList.get(j+(16*i));
				if (jc.isSelected()) {
					trackList[j] = key;
				}else{
					trackList[j] =0;
				}
			}
			makeTracks(trackList);
			track.add(makeEvent(176,1,127,0,16));
		}
		track.add(makeEvent(192,9,1,0,15));
		try {
			sequencer.setSequence (sequence);
			sequencer.setLoopCount (sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			buildTrackAndStart();
		}
	}
	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			sequencer.stop();
		}
	}
	public class MyUpTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor *1.03));
		}
	}
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer. getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor * .97));
		}
	}

	public void makeTracks (int[] list) {
		for (int i=0; i<16; i++) {
			int key = list [i];
			
			if (key !=0) {
				track.add(makeEvent(144,9,key,100,i));
				track.add(makeEvent(128,9,key,100,i+1));
			}
		}
	}
	public MidiEvent makeEvent (int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent (a, tick);
		} catch (Exception e) {e.printStackTrace(); }
		return event;
	}
}

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}