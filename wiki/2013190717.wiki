#summary 이민경의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong{
	public static void main(String[] args){
		int beerNum = 99;
		String word = "bottles";//plural
 
    		while (beerNum>0){ 
			System.out.println(beerNum + " " + word + " of beer on the wall"); 
			System.out.println(beerNum + " " + word + " of beer."); System.out.println("Take one down."); 
			System.out.println("Pass it around"); beerNum -= beerNum; 

    			if (beerNum==1){
				word = "bottle";//singular 
		   	} 

    			if(beerNum>0){
			        System.out.println(beerNum + " " + word + " of beer on the wall\n"); 
    			}
			
 			else {
			       System.out.println("No more bottles of beer on the wall\n"); 
			} 

    		} 

    	} 

}

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic{
    public static void main(String[] args){
        String[] wordListOne = {"attractive", "bad", "calm", "dangerous", "envious"};
        String[] wordListTwo = {"fancy", "giant", "huge", "irritating", "junior"};
        String[] wordListThree = {"anteater", "bear", "cat", "dog", "elphant"};

        int oneLength = wordListOne.length;
        int twoLength = wordListTwo.length;
        int threeLength = wordListThree.length;

        int rand1 = (int)(Math.random()*oneLength);
        int rand2 = (int)(Math.random()*twoLength);
        int rand3 = (int)(Math.random()*threeLength);

        String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

        System.out.println("What we need is a " + phrase);
    }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 1. 프로그램을 실행. 2. 자바는 순수 인터프리터 언어가 아님. 3. 유형에 엄격함. 4. 동적 바인딩 지원
 * 컴파일러: 1. 문법 검사 2. 실행 시 문제점을 미리 감지 3. 핵심 코드 보안

*55p 컴파일러가 되어봅시다* _구현후 주석달기_


A
{{{
class Exercise1b{
	public static void main(String[] args){
		int x=1;
	
		while(x<10){
			if(x>3){
				System.out.println("big x");
			}//컴파일은 가능하지만 결과가 출력되지 않음
			x += 1;//x를 증가시켜서 결과가 출력되게 함
		}	
	}
}
}}}
B
{{{
//class이름이 없어서 컴파일 불가 -> 추가함
public class smallx {
	public static void main(String[] args){
		int x=5;
		
		while(x>1){
			x = x-1;
			
			if(x<3){
				System.out.println("small x");
			}
		}
	}

}
}}}
C
{{{
public class Exercise1b {
	//main 메소드가 없어서 컴파일 안됨
	public static void main(String[] args){
		int x=5;
		
		while(x>1){
			x = x-1;
			
			if(x<3){
				System.out.println("small x");
			}
		}
	}

}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것. 객체의 상태(데이터)를 나타내며 그 유형에 속하는 각 객체마다 값이 다르다.
 * 메소드: 객체가 할 수 있는 일. 
 * 클래스: 객체를 만들기 위한 청사진. 클래스로부터 만들어진 각 객체는 클래스의 인스턴스 변수용으로 쓰기 위한 변수를 가질 수 있다.
 * 테스트용 클래스: 중요하거나 복잡한 클래스 혹은 메소드를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: 해상도, 화면크기, 가격, 제조사, 소비전력, 스마트TV 여부
 * 메소드: Poweron(),Poweroff(), VolumeUP(), VolumeDown(), ChannelUp(), ChannelDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

GuessGame
{{{
public class GuessGame{
	Player p1;
	Player p2;
	Player p3;
	Player p4;	

	public void startGame(){
		p1=new Player();
		p2=new Player();
		p3=new Player();
		p4=new Player();

		int guess1=0;
		int guess2=0;
		int guess3=0;
		int guess4=0;
		
		boolean correct1=false;
		boolean correct2=false;
		boolean correct3=false;
		boolean correct4=false;

		int answer=(int)(Math.random() * 10);
		System.out.println("Guess the number(0~9)");
		
		while(true){
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();

			guess1 = p1.number;
			System.out.println("P1 : " + guess1);

			guess2 = p2.number;
			System.out.println("P2 : " + guess2);

			guess3 = p3.number;
			System.out.println("P3 : " + guess3);

			guess4 = p4.number;
			System.out.println("P4 : " + guess4);


			if(guess1 == answer)
				correct1 = true;

			if(guess2 == answer)
				correct2 = true;

			if(guess3 == answer)
				correct3 = true;

			if(guess4 == answer)
				correct4 = true;


			if(correct1 || correct2 || correct3 || correct4) {
				System.out.println("Congratulation!");
				System.out.println("P1 : " + correct1);
				System.out.println("P2 : " + correct2);
				System.out.println("P3 : " + correct3);
				System.out.println("P4 : " + correct4);
				System.out.println("The answer is " + answer);
				System.out.println("The end of the game");
				break;		
			}
			
			else 
				System.out.println("Try again");

			
		}
	}
}

}}}
Player
{{{
public class Player{
	int number=0;

	public void guess(){
		number=(int)(Math.random() * 10);
		//System.out.println("The Guessed number : " + number);
	}
}
}}}
GameLauncher.
{{{
public class GameLauncher{
	public static void main(String[] args){
		GuessGame game = new GuessGame();
		game.startGame();
	}
}	
}}}
*76p 컴파일러가 되어봅시다* _구현후 주석달기_

A
{{{
class TapeDeck{
	boolean canRecord=false;

	void playTape(){
		System.out.println("Tape Playing");
	}

	void recordTape(){
		System.out.println("Tape Recording");
	}
}

class TapeDeckTest{
	public static void main(String[] args){
		
		TapeDeck t = new TapeDeck();//새로운 TapeDeck을 만들어주어야 한다.
		
		t.canRecord=true;
		t.playTape();

		if(t.canRecord==true) 
			t.recordTape();
		
	}
}
}}}

B
{{{
class DVDPlayer{
	boolean canRecord=false;

	void recordDVD{
		System.out.println("DVD Recording");
	}

	void playDVD{
		System.out.println("DVD Playing");
	}//Test에서 playDVD 메소드를 호출했으므로 만들어준다.
}

class DVDPlayerTest{
	public static void main(String[] args){
		DVDplayer d = new DVDplayer();

		d.canRecord=true;
		d.playDVD();

		if(d.canRecord=true)
			d.recordDVD();
	}
}
}}}


= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 : 1. 단순한 비트 패턴으로 나타낼 수 있는 값 2. boolean, char, int, short, byte, long, float, double 3. 무언가를 담기 위한 컵이라고 할 수 있다.(컵을 넘치게 무언가를 담을 수 없다.) 4. 변수 이름은 알파벳, "_", $ 로만 시작할 수 있다. 숫자는 불가 5. 변수 이름으로는 예약어를 사용할 수 없다.
 * 레퍼런스 : 1. 객체에 접근하는 방법을 알려주는 비트가 들어있다 2. 컵을 적용시키자면, 컵 안에 리모컨이 들어간 것과 같다 3. 모든 레퍼런스의 크기는 같다 4. 같은 클래스의 객체이기만 하면 다른 객체를 참조할 수도 있다(final없으면)  

 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog96{
	String name;
	public static void main(String[] args){
		Dog96 dog1 = new Dog96();
		dog1.bark();
		dog1.name = "Bart";

		Dog96[] myDogs = new Dog96[3];
		myDogs[0] = new Dog96();
		myDogs[1] = new Dog96();
		myDogs[2] = dog1;

		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";

		System.out.print("The name of the last Dog : ");
		System.out.println(myDogs[2].name);

		int x = 0;
		while(x<myDogs.length){
			myDogs[x].bark();
			myDogs[x].eat();
			myDogs[x].chaseCat();
			x = x+1;
		}

	}

	public void bark(){
		System.out.println(name + " barks.");
	}
	public void eat(){
		System.out.println(name + " eats meat.");
	}
	public void chaseCat(){
		System.out.println(name + " chases a cat.");

	}
}



}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_<br>
A
{{{
class Books{
	String title;
	String author;
}

class BooksTest{
	public static void main(String[] args){
		Books[] myBooks = new Books[3];

		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books();//각자 개체를 추가해주어야 한다.

		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";

		while(x<3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x+1;
		}
	}
}
}}}
B
{{{
class Hobbits{
	String name;
}
class HobbitsTest{
	public static void main(String[] args){
		Hobbits[] h = new Hobbits[3];
		int z=0;

		while(z<3){
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if(z==1)
				h[z].name = "frodo";
			if(z==2)
				h[z].name = "sam";
			
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobbit name.");

			z = z+1;//마지막에 증가시켜야한다. 그대로 실행하면 h[0]이 없다.

		}
	}
}
}}}




*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: refc라는 같은 레퍼런스를 10개 만들었기 때문에 마지막에 만든 객체를 제외하고는 참조할 수 없다. 

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화 : 1. 인스턴스 변수를 private로 지정, 게터와 세터를 생성 2. 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다(인스턴스 변수 범위 제한) 3. 세터를 사용하여 값을 바꿔도 다른 사용자에게 피해가 없다.
 * 게터 : 1. 인스턴스 변수의 값을 알아내기 위한 메소드. 일반적으로 인스턴스 변수의 값을 리턴함
 * 세터 : 1. 인스턴스 변수의 값을 설정하기 위한 메소드. 전달된 값을 확인하고 인스턴스 변수의 값을 설정함
 * 인스턴스 변수 : 1. 초기화하지 않아도 기본값이 있다 2. 클래스 내에서 선언된다  
 * 지역 변수 : 1. 반드시 초기화해야 된다 2. 메소드 내에서 선언된다   
 
*107p Dog* _실행_
Dog
{{{
class Dog{
	int size;
	String name;

	void bark(){
		if(size>60) 
			System.out.println("Woof! Woof");
		else if(size>14)
			System.out.println("Ruff! Ruff!");
		else
			System.out.println("Yip! Yip!");
	}
}

}}}
DogTest
{{{
class DogTest{
	public static void main(String[] args){
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;

		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_<br>
A
{{{
class XCopy{
	public static void main(String[] args){
		int orig = 42;

		XCopy x = new XCopy();

		int y = x.go(orig);

		System.out.println(orig + " " + y);
	}

	int go(int arg){
		arg = arg * 2;

		return arg;
	}
}//이상 없음
}}}
B
{{{
class Clock{
	String time;

	void setTime(String t){
		time = t;
	}

	String getTime(){
		return time;//return 타입을 string으로
	}
}
class ClockTest{
	public static void main(String[] args){
		Clock c = new Clock();

		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time : " + tod);
	}
}
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? : 프로그래머들이 코딩을 할때에 테스트 코드를 작성하도록함과 동시에 테스트를 기반으로 프로젝트를 완성시켜 나가도록 하는 프로그래밍 방법. 다음과 같은 방법을 따른다.
조금씩 자주 발표한다.<br>
사이클을 반복해서 돌리면서 개발한다.<br>
스펙에 없는 것은 절대 집어넣지 않는다.<br>
테스트 코드를 먼저 만든다.<br>
야근은 하지 않는다. 항상 정규 일과 시간에만 작업한다.<br>
기회가 생기는 족족 언제 어디서든 코드를 개선한다.<br>
모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다.<br>
조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만든다.<br>
모든 일을 단순하게 처리한다.<br>
두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업한다.<br>
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotCom{
	int[] locationCells;
	int hits = 0;

	void setLocationCell(int[] cellLocations){
		locationCells = cellLocations;

	}

	public String checkYourself(String userGuess){
		int guess = Integer.parseInt(userGuess);
		String result = "miss";

		for(int cell : locationCells){
			if(guess == cell){
				result = "hit";
				hits++;
				break;
			}
		}
		
		if(hits==locationCells.length)
			result = "kill";
		
		return result;
			
	}
}

import java.util.Scanner;

public class SimpleDotComTest{
	

	public static void main(String[] args){
		SimpleDotCom dot = new SimpleDotCom();
		Scanner scan = new Scanner(System.in);

		int[] locations = {2,3,4,5};
		dot.setLocationCell(locations);
		
		System.out.println("The chances : " + (locations.length+3));
		for(int i=0;i<locations.length+3;i++){
			String guess = scan.next();
			String result = dot.checkYourself(guess);
			System.out.println(result);
			if(dot.hits==locations.length)
				break;
		}
		
	}
}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
<Test_First.java>
import java.util.ArrayList;

public class Test_First {
	int[] locationCells;
	boolean[] checkCells;
	
	int hits = 0;

	void setLocationCell(int[] cellLocations){
		locationCells = cellLocations;
	}
	
	void setCheckedCell(boolean[] checked){
		checkCells = checked;
		
	}

	public String checkYourself(String userGuess){
		int guess = Integer.parseInt(userGuess);
		String result = "miss";

		for(int i=0; i<locationCells.length;i++){
			if(guess == locationCells[i]){
				if(checkCells[i]==false){
					result = "hit";
					hits++;
					checkCells[i] = true;
					break;	
				}
				else
					break;

			}
		}
		
		if(hits==locationCells.length)
			result = "kill";
		
		return result;
			
	}

	
}




<TEST1.java>
public class TEST1{
	public static void main(String[] args){
		int numOfGuess = 0;
		GameHelper helper = new GameHelper();

		Test_First dot = new Test_First();
		int randomNum = (int)(Math.random()*5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};
		dot.setLocationCell(locations);
		boolean isAlive = true;
		
		boolean[] checked = {false,false,false};
		dot.setCheckedCell(checked);

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = dot.checkYourself(guess);
			numOfGuess++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuess + " guesses");
			}

		}
		
		}

	}
}}}







*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

<Test_Second.java>
public class Test_Second{
	int[] locationCells;
	int hits = 0;

	void setLocationCell(int[] cellLocations){
		locationCells = cellLocations;

	}

	public String checkYourself(String userGuess){
		int guess = Integer.parseInt(userGuess);
		String result = "miss";

		for(int i=0; i<locationCells.length;i++){
			if(guess == locationCells[i]){
				result = "hit";
				hits++;
				locationCells[i]=-1;
				break;
			}
		}
		
		if(hits==locationCells.length)
			result = "kill";
		
		System.out.println(result);
			return result;
			
	}
}

<TEST2.java>

public class TEST2{
	public static void main(String[] args){
		int numOfGuess = 0;
		GameHelper helper = new GameHelper();

		Test_Second dot = new Test_Second();
		int randomNum = (int)(Math.random()*5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};
		dot.setLocationCell(locations);
		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = dot.checkYourself(guess);
			numOfGuess++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuess + " guesses");
			}

		}
		
		}

	}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
<Test_Third.java>

import java.util.ArrayList;

public class Test_Third{
	private ArrayList<String> locationCells;
	private int hits = 0;

	void setLocationCell(ArrayList<String> cellLocations){
		locationCells = cellLocations;

	}

	public String checkYourself(String userGuess){
		int guess = Integer.parseInt(userGuess);
		String result = "miss";
		
		int index = locationCells.indexOf(userGuess);
		
		if(index>=0){
			locationCells.remove(index);
			
			if(locationCells.isEmpty())
				result = "kill";
			else
				result = "hit";
		}
			System.out.println(result);
			return result;
			
	}
}

<TEST3.java>

import java.util.ArrayList;


public class TEST3{
	public static void main(String[] args){
		int numOfGuess = 0;
		GameHelper helper = new GameHelper();

		Test_Third dot = new Test_Third();
		int randomNum = (int)(Math.random()*5);

		ArrayList<String> locations = new ArrayList();
		locations.add(Integer.toString(randomNum));
		locations.add(Integer.toString(randomNum+1));
		locations.add(Integer.toString(randomNum+2));
		dot.setLocationCell(locations);
		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = dot.checkYourself(guess);
			numOfGuess++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuess + " guesses");
			}

		}
		
		}

	}
}}}



*174p 진짜 닷컴 게임* _구현후 주석달기_

DotComBust
{{{
import java.util.*;

public class DotComBust {
	private GameHelper helper = new GameHelper();
	private ArrayList<DotCom> dotComList = new ArrayList<DotCom>();
	private int guessnum;
	
	private void setUpGame(){
		DotCom one = new DotCom();
		one.setName("Pets.com");
		DotCom two = new DotCom();
		two.setName("eToys.com");
		DotCom three = new DotCom();
		three.setName("Go.com");
		dotComList.add(one);
		dotComList.add(two);
		dotComList.add(three);
		
		System.out.println("Your goal is to sink three dot coms.");
		System.out.println("Pets.com, eToys.com, Go.com");
		System.out.println("Try to sink them all in the fewest number of guesses");
		
		for(DotCom dotComToSet : dotComList){
			ArrayList<String> newLocation = helper.placeDotCom(3);
			dotComToSet.setLocationCells(newLocation);
		}
	}
	
	private void startPlaying(){
		while(!dotComList.isEmpty()){
			String userGuess = helper.getUserInput("Enter a guess");
			checkUserGuess(userGuess);
		}
		finishGame();
	}
	
	private void checkUserGuess(String userGuess){
		guessnum++;
		String result = "miss";
		
		for(DotCom dotComToTest : dotComList){
			result = dotComToTest.checkYourself(userGuess);
			
			if(result.equals("hit")){
				break;
			}
			if(result.equals("kill")){
				dotComList.remove(dotComToTest);
				break;
			}
		}
		System.out.println(result);
	}
	
	private void finishGame(){
		System.out.println("All Dot Coms are dead! Your stock is now worthless");
		
		if(guessnum<=18){
			System.out.println("It only took you" + guessnum + " guessses");
			System.out.println("You got out before your options sank");
		}
		else{
			System.out.println("Took you long enough." + guessnum + " guesses");
			System.out.println("Fish are dancing with your options.");
		}
	}
	
	public static void main(String[] args){
		DotComBust game = new DotComBust();
		game.setUpGame();
		game.startPlaying();
	}
}


}}}

GameHelper

{{{
import java.io.*;
import java.util.ArrayList;

public class GameHelper {
	public static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int[] grid = new int[gridSize];
	private int count=0;
	
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			
			if (inputLine.length() == 0)
				return null;			
		}
		catch(IOException e){
			System.out.println("IOExcepton: " + e);
		}
		
		return inputLine;
	}
	
	public ArrayList<String> placeDotCom(int comSize){
		ArrayList<String> alphaCells = new ArrayList<String>();
		String tmp = null;
		int[] coords = new int[comSize];
		int attempt = 0;
		boolean success = false;
		int location;
		
		count++;
		int incr = 1;
		if((count%2)==1)
			incr = gridLength;
		
		while(!success & attempt++ <200){
			location = (int)(Math.random() * gridSize);
			//System.out.print("Try" + location);
			int x=0;
			success = true;
			while(success && x<comSize){
				if(grid[location] == 0){
					coords[x++] = location;
					location += incr;
					
					if(location >= gridSize)
						success = false;
					
					if(x>0 & (location%gridLength == 0))
						success = false;
					else{
						//System.out.print("used" + location);
						success = false;
					}					
				}
			}//안쪽 while			
		}//바깥 while
		
		int x = 0;
		int row = 0, col = 0;
		//System.out.println("\n");
		
		while(x<comSize){
			grid[coords[x]] = 1;
			row = (int)(coords[x]/gridLength);
			col = coords[x] % gridLength;
			tmp = String.valueOf(alphabet.charAt(col));
			
			alphaCells.add(tmp.concat(Integer.toString(row)));
			x++;
			//System.out.print("	coords	" + x + " = " + alphatCells.get(x-1));
		}
		
		//System.out.println("\n?");
		
		return alphaCells;
	}

}

}}}

DotCom

{{{
import java.util.*;

public class DotCom {
	private ArrayList<String> locationCells;
	private String name;
	
	public void setLocationCells(ArrayList loc){
		locationCells = loc;
	}
	
	public void setName(String n){
		name = n;
	}
	
	public String checkYourself(String input){
		String status = "miss";
		int index = locationCells.indexOf(input);
		
		if(index>0){
			locationCells.remove(index);
			
			if(locationCells.isEmpty()){
				status = "kill";
				System.out.println("Ouch! You sunk " + name + " :(");
			}
			else
				status = "hit";
		}
		
		return status;
	}
}

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 1. 상위 클래스의 인스턴스 변수, 메소드를 하위 클래스에 물려주는 것.
        2. 하위 클래스에 별도의 인스턴스 변수, 메소드를 추가할 수도 있고 상속받은 메소드를 오버라이드 할 수도 있다.<br>
        3. 인스턴스 변수는 오버라이드 하지 않는다.<br>
        4. B라는 클래스가 A라는 클래스를 확장하면(=B가 A를 상속받으면) B 클래스는 A클래스이다. "B는 A다" 라는 관계가 성립하지 않으면 상속하지 않는다.<br>
        5. private로 지정된 인스턴스 변수나 메소드는 상속하지 않는다.<br>
        6. 코드 중복을 막을 수 있다.<br>
        7. 상위 클래스만 수정하면 하위 클래스에는 자동으로 적용된다.   
 * 다형성: 1. 상위 클래스가 하위 클래스를 참조할 수 있도록 한 것.<br>
         2. 레퍼런스 유형을 실제 객체 유형의 상위 클래스 유형으로 지정할 수 있다. 

*208p 클래스 계층 구조* _클래스로 구현_

{{{

public class Animal {
	String picture;
	String food;
	int hunger;
	float[] boundaries = new float[2];// height & width
	float[] location = new float[2];//x & y
	
	public void makeNoise(){
		
	}
	
	public void eat(){
		
	}
	
	public void sleep(){
		
	}
	
	public void roam(){
		
	}
	
	public class Feline extends Animal{
		public void roam(){
			
		}
		
		public class Lion extends Feline{
			public void makeNoise(){
				
			}
			public void eat(){
				
			}
		}
		
		public class Tiger extends Feline{
			public void makeNoise(){
				
			}
			public void eat(){
				
			}
		}
		
		public class Cat extends Feline{
			public void makeNoise(){
				
			}
			public void eat(){
				
			}
		}
	}
	
	public class Canine extends Animal{
		public void roam(){
			
		}
		
		public class Wolf extends Canine{
			public void makeNoise(){
				
			}
			public void eat(){
				
			}
		}
		
		public class Dog extends Canine{
			public void makeNoise(){
				
			}
			public void eat(){
				
			}
		}
	}
	
	public class Hippo extends Animal{
		public void makeNoise(){
			
		}
		public void eat(){
			
		}
	}
}


}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 1. 상위 클래스와 메소드 이름, 인자, 리턴 유형이 같은 메소드를 하위 클래스에 만드는 것.
             2. 하위 클래스에서 오버라이드하면 오버라이드된 메소드가 호출된다.
 * 오버로딩: 1. 이름이 같고 인자 목록이 다른 두 개 이상의 메소드를 만드는 것.
           2. 리턴 유형이 달라도 된다.<br>
           3. 리턴 유형만 바꿀 수는 없다.(=인자 목록을 반드시 변경해야 한다)<Br>
           4. 접근 단계를 마음대로 바꿀 수 있다(private, public 등)<br>
              (접근단계 : private> default> protected> public)

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class MonsterTestDrive {
	public static void main(String[] args){
		Monster[] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		
		for(int x = 0; x<3; x++){
			ma[x].frighten(x);
		}
	}
}

class Monster{
	boolean frighten(int d){
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster{
	boolean frighten(int x){
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster{
	boolean frighten(int x){
		System.out.println("breath fire");
		return true;
	}
}



}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 다중 상속 문제를 해결하기 위해 자바에서 지원하는 방법. 100% 추상 클래스, 추상 메소드 
 * 다형성: 
 * 추상 클래스: 1. 인스턴스를 만들 수 없는 클래스. 레퍼런스로 사용할 수는 있다. abstract를 붙이면 된다.
              2. 확장하지 않으면 쓸모 없다.
 * 추상 메소드: 반드시 오버라이드해야하는 메소드. 추상 메소드를 만들 대는 클래스도 반드시 추상 클래스여야 한다. 
 * 다중 상속: 상위 클래스를 2개 이상 상속받는 것. 자바에서는 지원 안함.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 1. 모든 객체. 따라서 인스턴스 변수도 힙에 저장
               
 * 스택에서의 변수: 1.메소드 호출과 지역변수
                 2. 실제로는 스택 프레임(실행코드, 모든 지역변수의 값을 포함한 메소드)이 들어간다<br>
                 3. 지역변수가 객체에 대한 레퍼런스인 겅유 변수만 스택에 들어간다<br>
 * 생성자: 1. 어떤 클래스 유형의 인스턴스를 만들 때 실행할 코드
          2. 객체를 실제로 사용하기 전에 그 객체를 쓰는 데 필요한 작업을 처리.<Br>
          3. 오버로드 가능(단, 인자 목록은 서로 달라야 함)<br>
          4. 생성자가 실행되면 Object 클래스의 생성자에 다다를 때까지 상위 클래스의 생성자를 실행해 나간다.<br>
          5. 상위 클래스의 생성자는 super();로 호출한다. 인자를 넣어도 된다.(단, 이 선언문은 모든 생성자의 첫번째 선언문이어야 한다).<br>
          6. 같은 클래스에 있는 다른 생성자를 호출할 때는 this();를 사용한다.역시 반드시 그 생성자의 첫번째 선언문이어야 한다.<br>
          7. super와 this를 동시에 사용할 수 없다.
 * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스(리모콘은 있는데 조종할 TV가 없음).
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 1. 객체의 상태를 나타냄 2. 힙에 저장 3. 객체가 가비지 컬렉트 당하면 같이 사라짐.
 * 지역 변수: 1. 메소드를 실행시키기 위한 변수 2. 스택에 저장 3. 메소드 실행 종료와 함께 사라짐 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}