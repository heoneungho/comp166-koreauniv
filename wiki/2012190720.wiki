#summary 어헝헝어헝어헝헝어헝어헝헝어헝

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
 public class BeerSong{ // 클래스 생성
   public static void main (String[] args) { // main 생성
      int beerNum = 99; // 정수 beerNum 설정

      String word = "bottles"; // 복수형

      while (beerNum > 0) // beerNum이 0이 되면 while문을 빠져나갑니다.
       {
 
     System.out.println(beerNum + " " + word + " of beer on the wall");

     System.out.println(beerNum + " " + word + " of beer .");

     System.out.println("Take one down.");

     System.out.println("Pass it around."); //문자열들 출력

     beerNum = beerNum - 1; // beerNum 정수를 99부터 1씩 줄여나갑니다.

   
       if (beerNum == 1) // beerNum이 1이면 단수형을 씁니다.
       {
           word = "bottle"; // 단수형
       } /* if문이 문자열 출력 앞에 있으면 나중에 beerNum이 1이 됐을 때 1 bottles of beer on the wall과 ,1 bottle of beer on the wall 으로 단수와 복수문장 모두 출력됩니다. 따라서 위치를 문자열 출력 아래로 두어야 단수문장 두개가 출력됩니다.*/

       if (beerNum > 0) {
    
     System.out.println(beerNum + " " + word + " of beer on the wall"); } // 문자열에 word를 넣어서 출력

    else {
    
     System.out.println("No more bottles of beer on the wall"); /* beerNum이 0이 되면 이 문자열을 출력*/
} // else문 끝
} // while 순환문 끝
}// main 클래스 끝
}// 클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
   public static void main (String[] args) {
// 세종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
   
    String[] wordListOne = {"Oh", "my", "god", "JAVA","is","so","difficult","T_T"};

    String[] wordListTwo = {"One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten"};

    String[] wordListThree = {"when","where","what","how","why","who","process","solution","strategy"}

// 각 단어 목록에 단어가 몇 개 씩 들어있는지 확인합니다.

   int oneLength = wordListOne.length;
   int twoLength = wordListTwo.length;
   int threeLength = wordListThree.length;

// 난수 세 개를 발생시킵니다.

   int rand1 = (int) (Math.random() * oneLength);
   int rand2 = (int) (Math.random() * twoLength);
   int rand3 = (int) (Math.random() * threeLength);

// 이제 구문을 만듭니다.

  String phase = wordListOne[rand1] + " " = wordListTwo[rand2] + " " + wordListThree[rand3];

// 구문을 출력합니다.
  System.out.println("What we need is a " + phrase);
  }
}
}}}

*52p 집중토론* _요약_
{{{
 * 자바 가상 머신: 
   1. 프로그램을 실행시킨다.
 
             2. 변수에 원래 들어가야 힐 것이 아닌 다른 유형의 값이 들어갈 떄 ClassCast Exception 을 발생시킨다.

             3. 보안 관련 작업을 한다.
 
             4. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 그걸 건드리지 않았는지 확인한다.
 * 컴파일러: 
   1. 컴파일러에게 파일을 준다.

             2. 문법이 맞았는지 틀렸는지 확인한다.

             3. 코드를 해석한다.

             4. 변수에 이상한 유형의 데이터를 저장하게 할 수 없도록 한다.

             5. 문제를 미리 감지해서 실행시 절대로 일어나면 안되는 일을 방지한다.

             6. 사람들이 함부로 건드리면 안되는 코드를 건드리려는 등의 일을 방지한다.
}}}


*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
 class Exercise1b {
   public static void main(String [] args) {
    int x = 1;
    while ( x < 10 ) {
     if ( x > 3 ) {
        System.out.println("big x"); 
      }
   }
  }
} 

 public static void main( String [] args ) {
   int x = 5;
   while ( x > 1 ) {
    x = x - 1;
    if ( x < 3 ) {
       System.out.println("small x");
    }
  }
}

class Exercise1b {
   int x = 5;
    while ( x > 1 ) {
      x = x - 1;
      if ( x < 3 ) {
         System.out.println("small x");
      }
   }
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_
{{{
 * 인스턴스 변수: 객체의 상태를 나타내며 그 유형에 속하는 각 개체마다 값이 다릅니다.
 * 메소드: 객체에서 할 수 있는 일을 말합니다.
 * 클래스: 객체를 만들기 위한 청사진입니다.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스입니다. 이름은 <클래스명>TestDrive 와 같은 식으로 붙습니다. 
 
}}}


*68p Television* _채워넣기_
{{{
 * 인스턴스 변수: channel, power,volume
 * 메소드: channelUp(), channelDown(), powerOn(),powerOff(),volumeUp(),volumeDown()
}}}

*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

class Player {
	int number = 0;

	void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);

	}
}

class GameLauncher {

	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();

		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;

		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;

		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

		while (true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + " 입니다.");

			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();

			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);

			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);

			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);

			guessp1 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);

			if (guessp1 == targetNumber) {
				p1isRight = true;
			}

			if (guessp2 == targetNumber) {
				p2isRight = true;
			}

			if (guessp3 == targetNumber) {
				p3isRight = true;
			}

			if (guessp4 == targetNumber) {
				p4isRight = true;
			}

			if (p1isRight || p2isRight || p3isRight || p4isRight) {

				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break;
			}

			else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			} // if/else 부분 끝
		} // 순환문 끝
	} // 메소드 끝
} // 클래스 끝

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
[A]
class TapeDeck{ // 클래스를 생성합니다.

        boolean canRecord=false; /* boolean값으로 canRecord을 지정합니다. false로 초기화합니다.*/

        void playTape(){
                System.out.println("tape playing");
        }

        void recordTape(){
                System.out.println("tape recording");
        }
}

class TapeDeckTestDrive{ // 클래스를 만듭니다.
        public static void main(String[]args){

                TapeDeck t=new TapeDeck(); //객체를 하나 만들어 줍니다.

                t.canRecord=true;
                t.playTape();

                if(t.canRecord==true){
                        t.recordTape();
                }
        }
}

[B]
class DVDPlayer{
        boolean canRecord=false;
        void recordDVD(){
                System.out.println("DVD recording");
        }
        void playDVD(){ /* 클래스에서 객체를 사용할 수 있도록 playDVD 메소드를 설정해줍니다.*/ 
                System.out.println("DVD playing");
        }
}
class DVDPlayerTestDrive{
        public static void main(String[]args){
                DVDPlayer d = new DVDPlayer();
                d.canRecord=true;
                d.playDVD();
                        if(d.canRecord==true){
                                d.recordDVD();
                        }
        }
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 
원시 변수 - 정수, 부울, 부동소수점 수와 같은 기초적인 값이 있다.
                  - 

레퍼런스 변수 - 객체에 대한 레퍼런스가 들어간다.
                          - 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
		String name;
		public static void main(String[] args) {
			// Dog 객체를 만들고 접근합니다.
			Dog dog1 = new Dog();
			dog1.bark();
			dog1.name = "Bart";
			
			//  이번에는 Dog 배열을 만듭니다.
			Dog[] myDogs = new Dog();
			//그리고 개를 몇 마리 집어넣습니다.
			myDogs[0] = new Dog();
			myDogs[1] = new Dog();
			myDogs[2] = new Dog();
			myDogs[3] = new Dog();
			myDogs[4] = new Dog();
			myDogs[5] = new Dog();
			myDogs[6] = new Dog();
			myDogs[7] = dog1;

			//배열 레퍼런스를 써서 Dog 객체에 접근합니다.
			
			myDogs[0].name = "Fred";
			myDogs[1].name = "Bart";
			myDogs[2].name = "Suhyeon";
			myDogs[3].name = "John";
			myDogs[4].name = "Michael";
			myDogs[5].name = "Abbb";
			myDogs[6].name = "Bccc";
		// myDogs[7]의 이름이 뭐였지?
			System.out.print("마지막 개의 이름: ");
                        System.out.println(myDogs[7].name);

// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.

                        int x = 0;
                        while( x < myDogs.length) {
                           myDogs[x].bark();
                           x = x + 1;
			}

                        public void bark() {
                           System.out.println(name + "이(가) 왈! 하고 짖습니다.");
}

public void eat() { }
public void chaseCat() {}

}

}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
[A]

// 클래스를 생성합니다.
class Books{
        String title;
        String author;
}

class BooksTestDrive{
        public static void main(String[]args){
                Books[]myBooks=new Books[3]; 
                int x=0;
                // 객체를 생성합니다.
                myBooks[0]=new Books();
                myBooks[1]=new Books();
                myBooks[2]=new Books();

                // 객체들의 속성을 채워줍니다.
                myBooks[0].title="The Grapes of Java";
                myBooks[1].title="The Java Gatsby";
                myBooks[2].title="The Java Cookbook";
                myBooks[0].author="bob";
                myBooks[1].author="sue";
                myBooks[2].author="ian";
                while(x<3){
                        System.out.print(myBooks[x].title);
                        System.out.print("by");
                        System.out.println(myBooks[x].author);
                        x=x+1;
                }               
        }

}

[B]
// Hobbits 클래스를 생성합니다.
class Hobbits {
        String name;
        public static void main (String [] args) {

                Hobbits [] h = new Hobbits[3];
                int z = 0; // 배열의 인덱스는 0에서 시작하므로 0으로 설정합니다.

                while (z<3)     {    // 따라서 z<3입니다.

                h[z] = new Hobbits(); // 객체를 생성합니다.
                h[z].name = "bilbo";
                if (z==1) {
                        h[z].name = "frodo";
                }
                if (z==2) {
                        h[z].name = "sam";
                }
                System.out.print(h[z].name + " is a ");
                System.out.println("good hobbit name");
                z = z + 1; //값을 1씩 증가시킵니다.
                }
        }
}
}}}

*101p 레퍼런스 도용사건* _요약_
{{{


 * 누가 이겼나요?: 밥
 
 * 문제가 된 부분은 어딘가요?: 켄트의 메소드는 기껏 10개를 만들었지만 객체 하나에만 접근할 수 있기 때문에 쓸모가 없습니다.


}}}
= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_
{{{
 * 캡슐화: 객체의 인스턴스 변수 주변에 방어막 같은 것을 만들어 주어서 다른 코드에서느느 이 데이터를 절대 직접 접근할 수 없도록 해주는 것입니다.
 * 게터와 세터: 게터는 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰이고, 세터는 그 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 극 값으로 설정하기 위한 용도로 쓰입니다.
 * 인스턴스 변수 vs 지역 변수:인스턴스 변수에는 항상 어떤 기본값이 들어갑니다. 인스턴스 변수에 직접 어떤 값을 대입하거나 세터 메소드를 호출하지 않은 경우에도 그 인스턴스 변수에는 기본값이 들어있습니다. 예를 들어, 정수는 0, 레퍼런스는 null 등이 있습니다. 그리고 인스턴스 변수는 클래스 내에서 선언됩니다.
지역변수에는 인스턴스 변수와 달리 기본값이 없습니다. 따라서 초기화를 해주기 전에 사용하려고 하면 컴파일 과정에서 오류가 납니다. 그리고 지역변수는 메소드 내에서 선언됩니다.
 
}}}

*107p Dog* _실행_

{{{
class Dog {
        int size;
        String name;

        void bark(){
                if(size>60){
                        System.out.println("Wooof! Wooof!");
                }else if(size>14){
                        System.out.println("Ruff! Ruff!");
                }else{
                        System.out.println("Yip! Yip!");
                }
        } // 사이즈에 따라 어떻게 짖을 지 정해줍니다.

}
class DogTestDrive{

        public static void main(String[]args){
                
                Dog one=new Dog();
                one.size=70;
                Dog two=new Dog();
                two.size=8;
                Dog three=new Dog();
                three.size=35;
                // Dog 객체를 생성해주고, 값을 입력합니다.
                one.bark();
                two.bark();
                three.bark(); // 실행 결과가 어떻게 나오는지 확인합니다.

        }
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
[A]

class XCopy {

        public static void main(String[] args) {
                int orig=42;
                XCopy x=new XCopy(); // XCopy 객체 x를 생성합니다.
                int y= x.go(orig); // y변수에 42를 go 메소드에 넘겨받은 리턴값을 대입합니다.
                System.out.println(orig+""+y); // orig와 y를 출력합니다.
        }

        int go(int arg){ // 이때 orig의 값은 바뀌지 않습니다.
                arg=arg*2;
                return arg;
        }
}


[B]

class Clock{
        String time;
        void setTime(String t){
                time=t;
        } // 세터를 이용하여 시간을 설정합니다.
        String getTime(){ 
                return time;
        } // 게터를 이용하여 시간을 return합니다.
}

class ClockTestDrive {

        public static void main(String[] args) {
                Clock c= new Clock();
                c.setTime("1245");
                String tod=c.getTime(); // 세터를 이용하여 시간을 설정
                System.out.println("time:"+tod); // 게터를 이용하여 리턴값 받습니다.
        }

}
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_
{{{
 * 익스트림 프로그래밍이란? 
 익스트림 프로그래밍이란, 최근 소프트웨어 개발 방법론 분야에 새로 등장한 프로그래밍 방법입니다. 이 것은 "프로그래머들이 정말 원하는 방법"이라고 불리며, 다양한 규모의 회사에서 쓰이고 있습니다. 이 것의 가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는 점입니다. 이 프로그래밍을 하는 데에는 몇가지 규칙이 있습니다. 
 - 조금씩, 하지만 자주 발표한다.
 - 사이클을 반복해서 돌리면서 개발한다.
 - 스펙에 없는 것은 절대 집어넣지 않는다.
 - 테스트 코드를 먼저 만든다.
 - 야근은 하지 마라. 항상 정규 일과 시간에만 작업한다.
 - 기회가 생기는 족족 언제 어디서든 코드를 개선한다.
 - 모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다.
 - 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만든다.
 - 모든 일을 단순하게 처리한다.
 - 두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업한다.

위의 10가지가 그 규칙입니다.


 }}}


*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive{

public static void main(String[] args){
SimpleDotCom dot = new SimpleDotCom();
int[] locations = {2,3,4};
dot.setLocationCells(locations);
String userGuess = "2";
String result = dot.checkYourself(userGuess);
}
}

public class SimpleDotCom{
int[] locationCells;
int numOfHits = "0";

public void setLocationCells(int[] locs){
locationCells = locs;
}

public String checkYourself(String stringGuess){
int guess = Integer.parseInt(stringGuess);
String result = "miss";
for(int i = 0; i < locationCells.length; i++){
if (guess == locationCells[i]){
result = "hit";
numOfHits++;
break;
}
}

if(numOfHits == locationCells.length){
result = "kill";
}

System.out.println(result);
return result;
}
}


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

import java.io.*;

public class DotcomFirstOption
{
                public static void main(String[] args) 
                {
                        int numOfGuesses = 0;
                        GameHelper helper = new GameHelper();
                        
                        SimpleDotCom theDotCom = new SimpleDotCom();
                        int randomNum = (int) (Math.random() * 5);
                        int[] locations = {randomNum, randomNum + 1,randomNum + 2};
                        theDotCom.setLocationCells(locations);
                        boolean isAlive = true;
                        
                        while(isAlive == true)
                        {
                                String guess = helper.getUserInput("enter a number");
                                String result = theDotCom.checkYourself(guess);
                                numOfGuesses++;
                                
                                if(result.equals("kill"))
                                {
                                        isAlive = false;
                                        System.out.println(numOfGuesses + " guesses");
                                }
                        }
                        
                }

        }

public class SimpleDotCom
{
        int[] locationCells;
        int numOfHits = 0;
        boolean[] hitCells = {false, false, false};

        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == locationCells[i]&& hitCells[i] == false)
                        {
                        
                                result = "hit";
                                hitCells[i] = true;
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}


public class GameHelper 
{
        public String getUserInput(String prompt)
        {
                String inputLine = null;
                System.out.println(prompt + " ");
                try
                {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0)
                                return null;
                        
                }
                catch (IOException e)
                {
                        System.out.println("IOException: " + e);
                        
                }
                return inputLine;
        }
}
}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

{{{
 * 상속: 이 관계는 하위클래스가 상위클래스의 멤버를 물려받는다는 것을 의미합니다. 클래스의 멤버에는 인스턴스 변수와 메소드가 있습니다. 하위클래스는 상위클래스보다 더 구체적입니다. 


 * 다형성: 
}}}
*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_
{{{
 * 오버라이드: 오버라이드는 메소드를 다시 정의하는 것입니다. 오버라이드 하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 합니다. 
 오버라이드를 하는 데에는 두가지 규칙이 있습니다. 첫 째, 인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 한다. 둘 째, 메소드를 더 접근하기 어렵게 만들면 안된다. 이 두가지 입니다.
 

 * 오버로딩: 오버로딩은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것입니다. 오버로드된 메소드는 다형성과는 전혀 관계가 없습니다. 오버로딩을 활용하면 호출하는 쪽의 편의를 위해 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있습니다. 상위 클래스에서 정의한 다형성 계약을 이행하지 않아도 되기 때문에 메소드 오버로딩은 훨씬 더 융통성이 좋다고 할 수 있습니다. 
 오버로드를 할 때에는 세 가지 규칙이 있습니다. 첫 째, 인자 목록만 다르면 리턴 유형이 달라도 된다. 둘 째, 인자 목록을 변경하지 않고 리턴 유형만 바꿀 수 는 없다. 셋 째,  접근 단계를 마음대로 바꿀 수 있다. 이렇게 세 가지 입니다.
}}}
*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class TwoButtons{

        JFrame frame;
        JLabel label;

        public static void main (String[] args){
                TwoButtons gui = new TwoButtons();
                gui.go();
        }

        public void go(){
                frame = new JFrame ();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                JButton labelButton = new JButton("Change label");
                labelButton.addActionListener(new LabelListener());

                JButton colorButton = new JButton("Change Circle");
                colorButton.addActionListener(new ColorListener());

                label = new JLabel("I'm a label");
                MyDrawPanel drawPanel = new MyDrawPanel();

                frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
                frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
                frame.getContentPane().add(BorderLayout.EAST, labelButton);
                frame.getContentPane().add(BorderLayout.WEST, label);

                frame.setSize(300,300);
                frame.setVisible(true);
        }

        class LabelListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        label.setText("Ouch!");
                }
        }

        class ColorListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        frame.repaint();
                }
        }
}
~                                                             import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
public class TwoButtons{

        JFrame frame;
        JLabel label;

        public static void main (String[] args){
                TwoButtons gui = new TwoButtons();
                gui.go();
        }

        public void go(){
                frame = new JFrame ();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                JButton labelButton = new JButton("Change label");
                labelButton.addActionListener(new LabelListener());

                JButton colorButton = new JButton("Change Circle");
                colorButton.addActionListener(new ColorListener());

                label = new JLabel("I'm a label");
                MyDrawPanel drawPanel = new MyDrawPanel();

                frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
                frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
                frame.getContentPane().add(BorderLayout.EAST, labelButton);
                frame.getContentPane().add(BorderLayout.WEST, label);

                frame.setSize(300,300);
                frame.setVisible(true);
        }

        class LabelListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        label.setText("Ouch!");
                }
        }

        class ColorListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        frame.repaint();
                }
        }
}
~                                                                                                                                           
~                                                                                       
~         
}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation{

        int x = 70;
        int y = 90;

        public static void main(String[] args){
                SimpleAnimation gui = new SimpleAnimation();
                gui.go();
        }

        public void go(){

                JFrame frame = new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                MyDrawPanel drawPanel = new MyDrawPanel();

                frame.getContentPane().add(drawPanel);
                frame.setSize(300,300);
                frame.setVisible(true);

                for(int i = 0; i <130; i++){

                        x++;
                        y++;

                        drawPanel.repaint();

                        try {
                                Thread.sleep(50);
                        }catch(Exception ex){ }
                }
                }
                class MyDrawPanel extends JPanel {

                        public void paintComponent(Graphics g){
                                g.setColor(Color.green);
                                g.fillOval(x,y,40,40);
                        }
                }
}
}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{
import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {

        static JFrame f = new JFrame("My First Music Video");
        static MyDrawPanel m1;

        public static void main(String [] args){
                MiniMusicPlayer3 mini = new MiniMusicPlayer3();
                mini.go();
        }// 메소드 끝

        public void setUpGui(){
                m1 = new MyDrawPanel();
                f.setContentPane(m1);
                f.setBounds(30, 30, 300, 300);
                f.setVisible(true);
        }// 메소드 끝

        public void go(){
                setUpGui();

                try{

                        Sequencer sequencer = MidiSystem.getSequencer();
                        sequencer.open();
                        sequencer.addControllerEventListener(m1, new int[] {127});
                        Sequence seq = new Sequence(Sequence.PPQ, 4);
                        Track track = seq.createTrack();

                        int r = 0; 
                        for(int i; i<60 ; i+=4){

                                r=(int)((Math.random()*50)+1);
                                track.add(makeEvent(144,1,r,100,i));
                                track.add(makeEvent(176,1,127,0,i));
                                track.add(makeEvent(128,1,r,100,i+2));
                        }// 순환문 끝

                        sequencer.setSequence(seq);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                } catch(Exception ex) {ex.printStackTrace();}
        }// 메소드 끝

        public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
                MidiEvent event = null;
                try{
                        ShortMessage a = new ShortMessage();
                        a. setMessage(comd,chan,one,two);
                        event = new MidiEvent(a, tick);
                }catch(Exception e){}
                return event;

        }// 메소드 끝

        class MyDrawPanel extends JPanel implements ControllerEventListener{
                boolean msg=false;

                public void controlChange(ShortMessage evet){
                        msg= true;
                        repaint();
                }

                public void paintComponent(Graphics g){
                        if(msg){

                                Graphics2D g2= (Graphics2D)g;

                                int r = (int) (Math.random()*250);
                                int gr=(int) (Math.random()*250);
                                int b= (int ) (Math.random()*250);

                                g.setColor(new Color(r,gr,b));

                                int ht=(int) ((Math.random()*120)+10);
                                int width=(int) ((Math.random()*120)+10);

                                int x=(int) ((Math.random()*40)+10);
                                int y=(int) ((Math.random()*40)+10);

                                g.fillRect(x, y, ht, width);
                                msg = false;
                        }//if문 끝
                }// 메소드 끝
        }// 내부 클래스 끝
}//클래스 끝
}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {

	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; /*체크상자를 ArrayList에 저장합니다.*/
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;

	String[] instrumentNames = { "Bass Drum", "Closed Hi-Hat", "Open Hi-Hat",
			"Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom",
			"Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell",
			"Vibraslap", "Low-mid Tom", "High Agogo", "Open Hi Conga" }; // 악기명을 string 으로 배열합니다.
	int[] instruments = { 35, 42, 46, 38, 49, 39, 50, 60, 70, 72, 64, 56, 58,
			47, 67, 63 }; /* 실제 드럼 건반을 나타냅니다. 드럼 채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 예를 들어 35번 건반은 베이스 드럽을, 42번 건반은 하이햇을 나타냅니다.*/

	public static void main(String[] args) {
		new BeatBox().buildGUI();
	}

	public void buildGUI() {
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있습니다.

		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);

		JButton start = new JButton("start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);

		JButton stop = new JButton("stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);

		JButton upTempo = new JButton("Tempo Up");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo);

		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(stop);

		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for (int i = 0; i < 16; i++) {
			nameBox.add(new Label(instrumentNames[i]));
		}

		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);

		theFrame.getContentPane().add(background);

		GridLayout grid = new GridLayout(16,16);
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER, mainPanel);

		for (int i = 0; i < 256; i++) {
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		} /* 체크 상자를 만들고 모든 값을 false 로 설정한 다음 ArrayList와 GUI에 패널을 추가합니다.*/

		setUpMidi();

		theFrame.setBounds(50, 50, 300, 300);
		theFrame.pack();
		theFrame.setVisible(true);
	}

	public void setUpMidi() {
		try {
			sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ, 4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		} catch (Exception e) {
			e.printStackTrace();
		}
	} /* 시퀀서,시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드입니다.*/

	public void buildTrackAndStart(){
	 int[] trackList = null;
	 
	 sequence.deleteTrack(track);
	 track = sequence.createTrack(); /* 기존트랙을 제거하고 트랙을 새로 만듭니다.*/
	 
	 	for (int i = 0; i < 16; i++){ 
	 		trackList = new int[16];
	 		
	 		int key = instruments[i]; /* 어떤 악기인지를 나타내는 건번 번호를 설정합니다.*/
	 		
	 		for ( int j = 0; j < 16; j++){
	 			
	 		 		JCheckBox jc = checkboxList.get(j + (16*i));
	 		 		if( jc.isSelected()){
	 		 			trackList[j] = key;
	 		 		} else {
	 		 			trackList[j] = 0;
	 		 		}
	 		} /* 박자에 해당하는 체크상자가 선택되었는지 확인합니다. 되었으면 연주를 하고 안되었습니다 0으로 설정합니다.*/
	 		makeTracks(trackList); /* 악기의 16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가합니다.*/
	 		track.add(makeEvent(176,1,127,0,16)); 

	 	}

	 	track.add(makeEvent(192,9,1,0,15));// 16번 째 박자에는 반드시 이벤트가 있어야 합니다. 이렇게 하지 않으면 다시 시작하기 전에 16박자가 모두 끝나지 않을 수도 있습니다.
	 	try{
	 		
	 		sequencer.setSequence(sequence);
	 			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); /* 루프 반복 횟수를 지정하기 위한 메소드입니다. 계속 반복할 수 있도록 sequencer.LOOP_CONTINUOUSLY를 인자로 했습니다.*/
	 			sequencer.start();
	 			sequencer.setTempoInBPM(120);
	 	} catch(Exception e) { e.printStackTrace();}
		 	
 }// 연주합니다.

	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			buildTrackAndStart();
		}
	}

	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			sequencer.stop();
		}
	}

	public class MyUpTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor * 1.03));
		}
	}

	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor * 0.97));
		}
	} /* 버튼에 대한 리스너 역할들 입니다. 빠르게 하면 속도가 3%증가, 느리게 하면 3% 감소합니다. */
	public void makeTracks(int[] list) {

		for (int i = 0; i < 16; i++) {
			int key = list[i];

			if (key != 0) {
				track.add(makeEvent(144, 9, key, 100, i));
				track.add(makeEvent(128, 9, key, 100, i + 1)); /* NOTE ON과 NOTE OFF 를 만들고 추가합니다.*/

			}
		}
	} /* 한 악기의 16박자 전체에 대해 이벤트를 만듭니다. int[] 배열에는 0 또는 악기의 건반 번호가 들어갑니다.*/

	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return event;
	}
} // 클래스 끝

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.*;

public class BeatBox {

	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; /*체크상자를 ArrayList에 저장합니다.*/
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;

	String[] instrumentNames = { "Bass Drum", "Closed Hi-Hat", "Open Hi-Hat",
			"Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom",
			"Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell",
			"Vibraslap", "Low-mid Tom", "High Agogo", "Open Hi Conga" }; // 악기명을 string 으로 배열합니다.
	int[] instruments = { 35, 42, 46, 38, 49, 39, 50, 60, 70, 72, 64, 56, 58,
			47, 67, 63 }; /* 실제 드럼 건반을 나타냅니다. 드럼 채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 예를 들어 35번 건반은 베이스 드럽을, 42번 건반은 하이햇을 나타냅니다.*/

	public static void main(String[] args) {
		new BeatBox().buildGUI();
	}

	public void buildGUI() {
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있습니다.

		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);

		JButton start = new JButton("start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);

		JButton stop = new JButton("stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);

		JButton upTempo = new JButton("Tempo Up");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo);

		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(stop);

		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for (int i = 0; i < 16; i++) {
			nameBox.add(new Label(instrumentNames[i]));
		}

		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);

		theFrame.getContentPane().add(background);

		GridLayout grid = new GridLayout(16,16);
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER, mainPanel);

		for (int i = 0; i < 256; i++) {
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		} /* 체크 상자를 만들고 모든 값을 false 로 설정한 다음 ArrayList와 GUI에 패널을 추가합니다.*/

		setUpMidi();

		theFrame.setBounds(50, 50, 300, 300);
		theFrame.pack();
		theFrame.setVisible(true);
	}

	public void setUpMidi() {
		try {
			sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ, 4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		} catch (Exception e) {
			e.printStackTrace();
		}
	} /* 시퀀서,시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드입니다.*/

	public void buildTrackAndStart(){
	 int[] trackList = null;
	 
	 sequence.deleteTrack(track);
	 track = sequence.createTrack(); /* 기존트랙을 제거하고 트랙을 새로 만듭니다.*/
	 
	 	for (int i = 0; i < 16; i++){ 
	 		trackList = new int[16];
	 		
	 		int key = instruments[i]; /* 어떤 악기인지를 나타내는 건번 번호를 설정합니다.*/
	 		
	 		for ( int j = 0; j < 16; j++){
	 			
	 		 		JCheckBox jc = checkboxList.get(j + (16*i));
	 		 		if( jc.isSelected()){
	 		 			trackList[j] = key;
	 		 		} else {
	 		 			trackList[j] = 0;
	 		 		}
	 		} /* 박자에 해당하는 체크상자가 선택되었는지 확인합니다. 되었으면 연주를 하고 안되었습니다 0으로 설정합니다.*/
	 		makeTracks(trackList); /* 악기의 16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가합니다.*/
	 		track.add(makeEvent(176,1,127,0,16)); 

	 	}

	 	track.add(makeEvent(192,9,1,0,15));// 16번 째 박자에는 반드시 이벤트가 있어야 합니다. 이렇게 하지 않으면 다시 시작하기 전에 16박자가 모두 끝나지 않을 수도 있습니다.
	 	try{
	 		
	 		sequencer.setSequence(sequence);
	 			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); /* 루프 반복 횟수를 지정하기 위한 메소드입니다. 계속 반복할 수 있도록 sequencer.LOOP_CONTINUOUSLY를 인자로 했습니다.*/
	 			sequencer.start();
	 			sequencer.setTempoInBPM(120);
	 	} catch(Exception e) { e.printStackTrace();}
		 	
 }// 연주합니다.

	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			buildTrackAndStart();
		}
	}

	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			sequencer.stop();
		}
	}

	public class MyUpTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor * 1.03));
		}
	}

	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float) (tempoFactor * 0.97));
		}
	} /* 버튼에 대한 리스너 역할들 입니다. 빠르게 하면 속도가 3%증가, 느리게 하면 3% 감소합니다. */
	public void makeTracks(int[] list) {

		for (int i = 0; i < 16; i++) {
			int key = list[i];

			if (key != 0) {
				track.add(makeEvent(144, 9, key, 100, i));
				track.add(makeEvent(128, 9, key, 100, i + 1)); /* NOTE ON과 NOTE OFF 를 만들고 추가합니다.*/

			}
		}
	} /* 한 악기의 16박자 전체에 대해 이벤트를 만듭니다. int[] 배열에는 0 또는 악기의 건반 번호가 들어갑니다.*/

	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return event;
	}
	
	public class MySendListener implements ActionListener {
		public void actionPerformed(ActionEvent a){/* 사용자가 버튼을 클릭해서 ActionEvent가 발생된 경우에 실행*/
			boolean[] checkboxState = new boolean[256]; /* 각 체크상자의 상태를 담아두기 위한 부울배열을 만듭니다.*/
			
			for (int i = 0; i < 256; i++ ){
				JCheckBox check = (JCheckBox) checkboxList.get(i); /* CheckboxList를 훑어보면서 각 체크상자의 상태를 확인하고 그 결과를 부울배열에 추가합니다.*/
				if (check.isSelected()){
					checkboxState[i] = true;
				}
				
			}
		try { 
			FileOutputStream fileStream = new FileOutputStream(new File("Checkbox.ser"));
			ObjectOutputStream os = new ObjectOutputStream(fileStream);
			os.writeObject(checkboxState);
		} catch (Exception ex){
				ex.printStackTrace();
		}
		}
		}
	
	public class MyReadInListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			boolean[] checkboxState = null;
			try{
				FileInputStream fileIn = new FileInputStream(new File("checkbox.ser"));
				ObjectInputStream is = new ObjectInputStream(fileIn);
				checkboxState = (boolean[])is.readObject(); /* 파일에서 객체 하나를 읽은 다음 부울 배열로 다시 캐스트합니다.*/
					} catch(Exception ex) {ex.printStackTrace();}
			
			for (int i = 0; i < 256; i++){
				JCheckBox check = (JCheckBox) checkboxList.get(i);
				if ( checkboxState[i]){
					check.setSelected(true);
				}else {
					check.setSelected(false);
				}
			}/* 실제 JCheckBox 객체로 구성된 ArrayList에 들어있는 각각의 체크상자의 상태를 원래대로 복구합니다.*/
			sequencer.stop();
			buildTrackAndStart(); /* 현재 연주중인 것을 멈추고 ArrayList에 들어있는 체크상자의 새로운 상태를 이용하여 시퀀스를 구성합니다.*/
				}
			}
		
	}
	// 클래스 끝
}}}