#summary 김석환의 완벽한 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong
{
	public static void main (String[] args)
	{
		int beerNum = 99;
		String word = "bottles"; //복수형

		while (beerNum>0)
		{
			if (beerNum == 1)
			{
				word = "bottle"; //단순형(한병인경우)
			}

			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum - 1;

			if (beerNum > 0)
			{
				System.out.println(beerNum + " " + word + " of beer on the wall");
			} else 
			{
				System.out.println("No more bottles of beer on the wall");
			} //else문 끝
		} //while문 끝
	} //main 클래스 끝
} //클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic
{
  public static void main(String[] args)
  {
     String[] wordListOne = {"김석환은", "김명준은","임태완은","이미현은","박선우는"}; 

     String[] wordListTwo = {"렙1의","브론즈의","실버의","골드의","플래티넘의","다이아의"};

     String[] wordListThree = {"실력입니다","실력이 안됩니다","실력을 넘습니다"};

		//각 단어 목록에 단어가 몇 개씩 들어있는지 확인!!
     int oneLength = wordListOne.length;
     int twoLength = wordListTwo.length;
     int threeLength = wordListThree.length;

		//난수 세 개 발생!!
     int rand1 = (int) (Math.random()*oneLength);
     int rand2 = (int) (Math.random()*twoLength);
     int rand3 = (int) (Math.random()*threeLength);

		//랜덤으로 구문 만들기!!
     String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

		//구문 출력!!
     System.out.println("리그오브레전드 게임에서 " + phrase);
   }
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램 실행이나 보안관련 작업등을 한다.
 * 컴파일러: 자바 가상 머신에 바이트코드로 작성된 파일을 주고 실행에 있어 발생할 수 있는 문제점의 99%를 미리 잡아 낸다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class Exercise1b {
	public static void main(String [] args) {
		int x = 1;
		while ( x < 10 ) {
			if ( x > 3 ) {
				System.out.println("big x");
			}
			x = x+1 ;	// x를 1씩 증가시켜 무한반복되는 것을 막는다.
		}
	}
}

B.
class Exercise1b {	// 클래스 명을 지정해 주어야 한다.
	public static void main(String [] args) {
		int x = 5;
		while ( x > 1 ) {
			x = x-1;
			if ( x < 3 ) {
				System.out.println("small x");
			}
		}
	}
} // }하나 추가

C.
class Exercise1b {
	public static void main(String [] args) { // method가 있어야 한다.
		int x = 5;
		while ( x > 1 ) {
			x = x-1;
			if ( x < 3 ) {
				System.out.println("small x");
			}
		}
	} // }하나 추가
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것.
 * 메소드: 객체에서 할 수 있는 일.
 * 클래스: 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: volume, channel
 * 메소드: upVolume(), downVolume(), upchannel(), downchannel()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1=new Player();
		p2=new Player();
		p3=new Player();
		p4=new Player();
		
		int guessp1=0;
		int guessp2=0;
		int guessp3=0;
		int guessp4=0;
		
		boolean p1isRight=false;
		boolean p2isRight=false;
		boolean p3isRight=false;
		boolean p4isRight=false;
		
		int targetNumber=(int)(Math.random()*10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는 "+ targetNumber+"입니다");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1=p1.number;
			System.out.println("1번 선수가 찍은 숫자: "+guessp1);
			
			guessp1=p2.number;
			System.out.println("2번 선수가 찍은 숫자: "+guessp1);
			
			guessp1=p3.number;
			System.out.println("3번 선수가 찍은 숫자: "+guessp1);
			
			guessp1=p4.number;
			System.out.println("4번 선수가 찍은 숫자: "+guessp1);
			
			if(guessp1==targetNumber){
				p1isRight=true;
			}
			
			if(guessp2==targetNumber){
				p1isRight=true;
			}
			
			if(guessp3==targetNumber){
				p1isRight=true;
			}
			
			if(guessp4==targetNumber){
				p1isRight=true;
			}
			
			if(p1isRight||p2isRight||p3isRight||p4isRight){
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: "+p1isRight);
				System.out.println("2번 선수: "+p2isRight);
				System.out.println("3번 선수: "+p3isRight);
				System.out.println("4번 선수: "+p4isRight);
				System.out.println("게임 끝.");
				break;
			}else{
				System.out.println("다시 시도해야 합니다.");				
			}
		}
	}
}

public class Player{
	int number=0;
	
	public void guess(){
		number=(int)(Math.random()*10);
		System.out.println("찍은 숫자: "+number);
	}
}


public class GameLauncher{
	public static void main(String[] args){
		GuessGame game=new GuessGame();
		game.startGame();
	}
}
}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class TapeDeck
{
        boolean canRecord = false;

        void playTape() // 테이프 실행 메소드 생성
        {
                System.out.println("tape playing"); // tape playing 출력
        }

        void recoredTape() // 테이프 녹음 메소드 생성
        {
                System.out.println("tape recording"); // tape recording 출력
        {
}

class TapeDeckTestDrive
{
        public static void main(String [] args)
        {
                TapeDeck t = new TapeDeck(); //t라는 테이프 객체 생성
                t.canrecord = true;
                t.playTape(); //테이프 실행 메소드 호출

                if(t.canRecord == true)
                        t.recordTape(); //테이프 녹음 메소드 호출
        }
}


class DVDPlayer 
{
        boolean canRecord = false;
        
        void playDVD() //디비디 실행 메소드 생성
        {
                System.out.println("DVD playing"); //DVD playing 출력
        }
        
        void recordDVD() //디비디 녹음 메소드 생성
        {
                System.out.println("DVD recording"); //DVD recording 출력
        }
}

class DVDPlayerTestDrive
{
        public static void main(String [] args)
        {
                DVDPlayer d = new DVDPlayer(); // d라는 디비디 플레이 객체 생성
                d.canRecord = true;
                d.playDVD(); // 디비디 플레이 메소드 호출
        
                if(d.canRecord == true)
                        d.recordDVD(); // 디비디 녹음 메소드 호출
        }
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
원시 변수에는 정수,부울,부동소수전 수와 같이 비트 패턴으로 나타낼 수 있는 기초적인 값이 들어간다. 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다. 
 <br>
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
        String name;
        public static void main (String[] args) {
                Dog dog1 = new Dog();
                dog1.bark() ;
                dog1.name = "Bill" ;
                
                Dog[] myDogs = new Dog[8];
                myDogs[0] = new Dog() ;
                myDogs[1] = new Dog() ;
                myDogs[2] = new Dog() ;
                myDogs[3] = new Dog() ;
                myDogs[4] = new Dog() ;
                myDogs[5] = new Dog() ;
                myDogs[6] = new Dog() ;
                myDogs[7] = dog1;
        
                //배열 레퍼런스를 써서 Dog객체에 접근합니다.
                myDogs[0].name = "명준";
                myDogs[1].name = "태완";
                myDogs[2].name = "미현";
                myDogs[3].name = "선우";
                myDogs[4].name = "기태";
                myDogs[5].name = "진우" ;
                myDogs[6].name = "민주";
                //myDogs[7] 개의 이름이 뭐였지?
                System.out.print("마지막 개의 이름: ");
                System.out.println(myDogs[7].name);
                
        
                //이제 순환문을 써서 배열에 들어있는
                   //모든 개가 짖도록 합시다.
                int x = 0;
                while(x < myDogs.length) {
                        myDogs[x].bark();
                        x = x + 1;
                }
        }
        public void bark() {
                System.out.println(name + "이(가) 왈! 하고 짖습니다.");
        }
        public void eat() { }
        public void chaseCat() { }
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Books {
        String title ;
        String author ;
}

class BooksTestDrive {
        public static void main(String [] args) {
        
                Books [] myBooks = new Books[3] ;
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books(); // Books라는 객체 생성한다.
                int x = 0;
                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";
        
                while(x<3) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}

B
class Hobbits {
        
        String name ;
        
        public static void main(String [] args) {
        
                Hobbits [] h = new Hobbits[3];
                int z = 0 ;

                while(z<3) { //이름의 수가 3이므로 3으로 바꾼다.
        
                        h[z] = new Hobbits();
                        h[z].name = "bilbo";
                        if(z==1) {
                                h[z].name = "frodo";
                        }
                        if(z==2) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.println("good Hobbit name");
                        z=z+1; //맨앞에 있으면 0번째가 의미가 없다.
                }
        }
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?:
켄트의 방법은 메모리를 약간 절약할 수는 있었지만, 매번 순환문을 돌 때마다 새로운 값으로 초기화되서 밥의 방법보다 효용성이 없다. 

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 외부에 노출되어있는 변수를 보호하기 위하여 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다.
 * 게터와 세터:게터는 게터가 가져오기로 한 값을 리턴값 형태로 받아오기 위한 용도이고 세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도이다.
 * 인스턴스 변수 vs 지역 변수:인스턴스 변수는 클래스 내에서 선언되야 하고 지역변수는 메소드 내에서 선언되며, 사용하기 전에 반드시 초기화 해야한다.
 
*107p Dog* _실행_

{{{

public class Dog2 {
        int size;
        String name;
        
        void bark() {
                if(size>60) {
                        System.out.println("Wooof! Wooof!");
                }else if (size >14) {
                        System.out.println("Ruff! Ruff!");
                }else {
                        System.out.println("Yip! Yip!");
                }
        }

}

-----------------------------------------------------------------

public class DogTestDrive {

                public static void main (String[] args) {
                        Dog2 one = new Dog2();
                        one.size=70;
                        Dog2 two = new Dog2();
                        two.size=8;
                        Dog2 three = new Dog2();
                        three.size=35;
                        
                        one.bark();
                        two.bark();
                        three.bark();
                }
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class XCopy {
        
        public static void main(String []args) {
        
                int orig = 42;
        
                XCopy x = new XCopy(); // XCopy유형의 객체 x를 선언한다.

                int y = x.go(orig);//객체x에서 go를 호출하고 이때 orig값을 보낸후 메소드를 실행해 y에 그값을 리턴한다.
        
                System.out.println(orig + " " + y );
        }
        
        int go(int arg) { //함수를 int값으로 리턴을 받게된다.
        
                arg=arg*2;
                
                return arg;//arg를 리턴한다.
        }
} //결과 : 42 84

B

class Clock {
        String time;
        
        void setTime(String t) {
                time = t;
        }
        
        String getTime() { //time을 리턴받는 게터이고 받을 time은 String이므로 String으로 선언한다.
                return time;
        }
}

class ClockTestDrive {
        public static void main(String [] args) {
        
                Clock c = new Clock();
                
                c.setTime("1245");
                String tod = c.getTime();
                System.out.println("time :  "  + tod);
        }
} // 결과 time : 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? <br>
익스트림 프로그래밍이란 소프트웨어 개발 방법중의 하나로 가장 큰 장점은 스펙이 변경되어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는것이다. 
 <br>
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class simpledotcomtestdrive {
        
    public static void main(String[] args)  {
        int numofGuesses = 0;
        GameHelper helper = new GameHelper();
        
        simpledotcom thedotcom = new simpledotcom();
        
        int randomNum = (int)(Math.random()*5);
        
        int[] locations = {randomNum, randomNum+1, randomNum+2};
        thedotcom.setLocationCells(locations);
        boolean isAlive = true;
        
        while(isAlive == true)  {
                String guess = helper.getUserInput("enter a number");
                String result = thedotcom.checkYourself(guess);
                numofGuesses++;
                
                if(result.equals("kill"))       {
                        isAlive = false;
                        
                        System.out.println(numofGuesses + " guesses");
                }
        }
    }
}



public class simpledotcom {

        int[] locationCells;
        int numOfHits = 0;

public void setLocationCells (int[] locs)       {
        locationCells = locs;
}

public String checkYourself (String stringGuess)        {
        int guess = Integer.parseInt(stringGuess);
        String result = "miss";
        for(int i=0; i < locationCells.length; i++)     {
                if(guess == locationCells[i])   {
                        result = "hit";
                        numOfHits++;
                        break;
                }
        }

        if (numOfHits == locationCells.length)  {
                result = "kill";
        }

        System.out.println(result);
        
        return result;
        }       
}
             


import java.io.*;

public class GameHelper {
        public String getUserInput(String prompt)       {
                String inputLine = null;
                
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        
                        if(inputLine.length() == 0 )
                                return null;
                }       catch (IOException e)   {
                        System.out.println("IOException: " + e);
                }
                
                return inputLine;
        }
}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
 
public class GameHelper { 
         
        public String getUserInput(String prompt) { 
                 
                String inputLine = null; 
                 
                System.out.print(prompt + " " ); 
                 
                try{ 
                 
                        BufferedReader is = new BufferedReader ( 
                         
                        new InputStreamReader(System.in)); 
                         
                inputLine = is.readLine(); 
        
                if(inputLine.length()==0) return null; 
                         
                } catch (IOException e) { 
                         
                        System.out.println("IOExceoption:  " + e); 
                } 
                 
                return inputLine; 
        } 
} 
 
 
 
public class SimpleDotCom { 
         
        int[] locationCells; 
        boolean[] hitCells = new boolean[3];//hitCells이라는 boolean형 배열을 생성한다.
        int numOfHits = 0 ; 
 
        public void setLocationCells(int[] locs) { 
                locationCells = locs; 
        } 
         
        public void sethitCells(boolean[] hit) {//위의 setLocationCells처럼 sethitCells메소드를 추가한다.
                hitCells = hit; 
        } 
        public String checkYourself(String stringGuess) { 
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss"; 
                for(int i=0;i<locationCells.length;i++) { 
                        if(guess==locationCells[i]&&hitCells[i]==false) {//이미 맞췃는지에대한 확인추가한다.
                                result = "hit"; 
                                numOfHits++; 
                                hitCells[i]=true;//맞췃다는 표시를 한다.
                                break; 
                        } 
                } 
                 
                if(numOfHits == locationCells.length) { 
                        result = "kill"; 
                } 
                System.out.println(result); 
                return result; 
        } 
} 
 
 
public class SimpleDotComTestDrive {  
 
        public static void main(String[] args) { 
 
                int numOfGuesses = 0; 
                GameHelper helper = new GameHelper(); 
 
                SimpleDotCom theDotCom = new SimpleDotCom(); 
 
                int randomNum = (int) (Math.random() * 5); // 난수를 발생한다.
 
                int[] locations = { randomNum, randomNum + 1, randomNum + 2 }; 
         
                boolean[] hitCells = new boolean[3];//첫번째 옵션에 필요한 boolean배열을 생성한다.
                theDotCom.sethitCells(hitCells);//boolean배열을 닷컴클래스로 보내준다.
                theDotCom.setLocationCells(locations); 
                boolean isAlive = true; 
 
                while (isAlive == true) { 
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++; 
 
                        if (result.equals("kill")) { 
                                isAlive = false; 
                                System.out.println(numOfGuesses + " guesses"); 
                        } 
 
                }  
 
        }  
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
 
public class GameHelper { 
         
        public String getUserInput(String prompt) { 
                 
                String inputLine = null; 
                 
                System.out.print(prompt + " " ); 
                 
                try{ 
                 
                        BufferedReader is = new BufferedReader ( 
                         
                        new InputStreamReader(System.in)); 
                         
                inputLine = is.readLine(); 
         
                if(inputLine.length()==0) return null; 
                         
                } catch (IOException e) { 
                         
                        System.out.println("IOExceoption:  " + e); 
                } 
                 
                return inputLine; 
        } 
} 
 
public class SimpleDotCom { 
         
        int[] locationCells; 
        int numOfHits = 0 ; 
 
        public void setLocationCells(int[] locs) { 
                locationCells = locs; 
        } 
         
        public String checkYourself(String stringGuess) { 
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss"; 
                for(int i=0;i<locationCells.length;i++) { 
                        if(guess==locationCells[i]&&locationCells[i]!=-1) {//-1이면 맞춘자리 이므로 이에대한 확인한다.
                                result = "hit"; 
                                numOfHits++; 
                                locationCells[i]=-1;//맞췃다는 표시로 -1을 넣어준다.
                                break; 
                        } 
                } 
                 
                if(numOfHits == locationCells.length) { 
                        result = "kill"; 
                } 
                System.out.println(result); 
                return result; 
        } 
} 
 
public class SimpleDotComTestDrive {  
 
        public static void main(String[] args) { 
 
                int numOfGuesses = 0; 
                GameHelper helper = new GameHelper(); 
 
                SimpleDotCom theDotCom = new SimpleDotCom(); 
 
                int randomNum = (int) (Math.random() * 5); // 난수를 발생한다. 
                int[] locations = { randomNum, randomNum + 1, randomNum + 2 }; 
                theDotCom.setLocationCells(locations); 
                boolean isAlive = true; 
 
                while (isAlive == true) { 
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++; 
 
                        if (result.equals("kill")) { 
                                isAlive = false; 
                                System.out.println(numOfGuesses + " guesses"); 
                        } 
 
                }  
 
        }  
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
 
public class DotCom { 
 
  private ArrayList<String> locationCells; 
  //private int numOfHits; 
 
  public void setLocationCells(ArrayList<String> loc) { 
    locationCells = loc; 
  } 
 
  public String checkYourself(String userInput) { 
 
    String result = "miss"; 
 
      int index = locationCells.indexOf(userInput); 
 
       if(index>=0) { 
 
          locationCells.remove(index); 
 
          if(locationCells.isEmpty()){ 
            result = "kill"; 
          } else { 
            result = "hit"; 
          }//if문 끝 
 
         }//바깥쪽if문 끝 
 
      return result; 
 
   }//메소드 끝 
 }//클래스끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
 
public class DotCom 
{ 
        private ArrayList<String> locationCells;//DotCom의 인스턴스 변수 셀위치 
        private String name;//DotCom의 인스턴스 변수  DotCom의 이름 
 
        public void setLocationCells(ArrayList<String> loc) 
        { 
                locationCells = loc;//DotCom의 위치를 받는다.
        } 
         
        public void setName(String n) 
        { 
                name = n;//이름을 설정한다.
        } 
         
        public String checkYourself(String userInput) 
        { 
                String status = "miss";//올바른 실행을 위해 초기값은 miss 
                int index = locationCells.indexOf(userInput); 
                //ArrayList의 indexOf()메소드를 사용하여  사용자가 추측한 위치가 ArrayList에 들어있으면 인덱스를 그렇지 않으면 -1을 리턴한다.
                if(index >= 0) 
                { 
                        locationCells.remove(index); 
                        //삭제합니다. 
                        if(locationCells.isEmpty())//모두 비엇는지 확인한다. 
                        { 
                                status = "kill"; 
                                System.out.println("Ouch! You sunk " + name + "    : ( "); 
                                                        } 
                        else 
                        { 
                                status = "hit"; 
                        } 
                }//if문 끝 
 
        return status; 
        } 
        //status에는 miss나 kiil이나 hit이 저장된다. 
} 
 
import java.util.*; 
 
public class DotComBust  
{ 
        private GameHelper helper = new GameHelper();//객체를 생성합니다. 
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();//DotCom객체로 이루어진 ArrayList를 만듭니다. 
        private int numOfGuesses = 0; 
         
        private void setUpGame()//닷컴 객체를 만들고 위치를 지정 
        { 
                DotCom one = new DotCom(); 
                one.setName("Pets.com"); 
                DotCom two = new DotCom(); 
                two.setName("eToys.com"); 
                DotCom three = new DotCom(); 
                three.setName("Go2.com"); 
                dotComsList.add(one); 
                dotComsList.add(two); 
                dotComsList.add(three); 
                //DotCom 객체 세 개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다. 
                 
                System.out.println("Your goal is to sink three dot coms."); 
                System.out.println("Pets.com, eToys.com, Go2.com"); 
                System.out.println("Try to sink them all in the fewest number of guesses"); 
                //사용자에게 간단한 게임 방법을 설명한다. 
                 
                for(DotCom dotComToSet : dotComsList)//모든 dotCom에 반복한다.
                { 
                        ArrayList<String> newLocation = helper.placeDotCom(3); 
                         
                        dotComToSet.setLocationCells(newLocation); 
                        //이 DOtCom 객체의 세터 메소드를 호출하여 방금 보조 메소드에서 받아온 위치를 지정한다.
                         
                }//for 순환문 끝 
        }//setUpgame 메소드 끝 
         
        private void startPlaying() 
        { 
                while(!dotComsList.isEmpty())//dotComsList가 비어있지 않으면 계속 반복합니다. 
                { 
                        String userGuess = helper.getUserInput("Enter a guess"); 
                        //추측시작 
                        checkUserGuess(userGuess); 
                        //checkUserGuess 메소드를 호출한다.
                         
                }//while문 끝 
                finishGame(); 
        }//startPlaying 메소드 끝 
 
        private void checkUserGuess(String userGuess) 
        { 
                numOfGuesses++;//메소드가 호출되면 사용자 추측 횟수를 증가 시킨다.
                String result = "miss";//일단 miss라고 초기화한다.
                 
                for(DotCom dotComToTest : dotComsList)//목록의 모든 DotCom 객체에 대해 반복한다. 
                { 
                        result = dotComToTest.checkYourself(userGuess); 
                        //결과확인 
                        if(result.equals("hit"))//hit일때 
                        { 
                                break;//                        } 
                        if(result.equals("kill"))//kill일때 
                        { 
                                dotComsList.remove(dotComToTest);//지움! 
                                break; 
                        } 
                }//for 문 끝 
        }//checkUserGuess 메소드 끝 
         
        private void finishGame()//게임이 끝난후 사용하는 메소드 
        { 
                System.out.println("All Dot Coms are dead! Your stock is now worthless"); 
                if(numOfGuesses <= 18) 
                { 
                        System.out.println("It only took you " + numOfGuesses + " guesses."); 
                        System.out.println("You got out before your options sank"); 
                } 
                else 
                { 
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses."); 
                        System.out.println("Fish are dancing with your options"); 
                } 
        } 
 
        public static void main(String[] args) 
        { 
                DotComBust game = new DotComBust();//객체생성 
                game.setUpGame();//게임설정 
                game.startPlaying(); 
                //게임시작 
        } 
 
} 
 
 
import java.io.*; 
import java.util.*; 
 
public class GameHelper 
{ 
        private static final String alphabet = "abcdefg"; 
        private int gridLength = 7; 
        private int gridSize = 49; 
        private int[] grid = new int[gridSize]; 
        private int comCount = 0; 
         
        public String getUserInput(String prompt) 
        { 
                String inputLine = null; 
                System.out.println(prompt +" "); 
                try 
                { 
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); 
                        inputLine = is.readLine(); 
                        if(inputLine.length() == 0) 
                                return null;     
                } 
                catch(IOException e) 
                { 
                        System.out.println("IOException: " + e); 
                } 
         
                return inputLine.toLowerCase(); 
                 
        } 
         
        public ArrayList<String> placeDotCom(int comSize) 
        { 
                ArrayList<String> alphaCells = new ArrayList<String>();//좌표 
                String temp = null;//temp의 용도로 사용되는 String 
                int[] coords = new int[comSize];//현재 후보 좌표 
                int attempts = 0;//카운터 
                boolean success = false;//적당한 위치를 찾았느지 표시하기 위한 플래그 
                int location = 0;//현재 시작 위치 
                 
                comCount++;//n번째 닷컴 
                int incr = 1;//수평 방향으로 증가시킬 값 설정 
                if((comCount % 2)==1)//홀수 번째 닷컴인 경우 
                { 
                        incr = gridLength;//수직 방향으로 증가시킬 값 결정한다. 
                } 
                 
                while(!success & attempts++ < 200)//주 검색 순환문(32) 
                { 
                        location = (int) (Math.random() * gridSize);//임의 시작 위치를 구한다. 
                        //System.out.print(" try " + location); 
                         
                        int x = 0;//위치시킬 닷컴의 n번째 위치 
                        success = true;
                        while(success && x < comSize)//닷컴이 들어갈 자리가 비었는지 확인한다.
                        { 
                                if(grid[location] == 0)
                                { 
                                        coords[x++] = location; 
                                        location += incr;
                                        if(location >= gridSize)
                                                success = false;//실패 
                                        if(x > 0 & (location % gridLength == 0))//경계를 벗어난 경우(오른쪽) 
                                                success = false;//실패 
                                        else//이미 사용중인 경우 
                                                //System.out.print(" used " + location) 
                                                success = false;//실패 
                                } 
                        } 
                         
                }//while 끝 
 
        int x = 0; 
        int row = 0; 
        int column = 0; 
         
        while(x < comSize) 
        { 
                grid[coords[x]] = 1;//기본 그리드 좌표를 사용중 으로 표시한다.
                row = (int) (coords[x] / gridLength);//행 값을 구한다.
                column = coords[x]&gridLength;//열 값을 구한다.
                temp = String.valueOf(alphabet.charAt(column));//숫자가 된 열을 알파벳으로 변환한다. 
                 
                alphaCells.add(temp.concat(Integer.toString(row))); 
                x++; 
                //System.out.println("   coord  " + x + " = "  + alphaCells.get(x-1)); 
                //DotCom의 위치를 알려주는 메소드 
                                 
        } 
         
        return alphaCells; 
        } 
         


}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:하위클래스가 상위클래스의 멤버(인스턴스 변수와 메소드)를 물려받는다는 것을 의미한다. 
 * 다형성:일련의 클래스에 대한 상위클래스를 만들면 그 상위클래스 형식이 들어갈 수 있는 모든 자리에 해당 상위클래와 임의 하위클래스에 속하는 객체를 마음대로 사용할 수 있다. 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다. 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없다. 


*208p 클래스 계층 구조* _클래스로 구현_

{{{

class Animal 
{ 
        String picture; 
        Boolean food; 
        int hunger; 
        float boundaries; 
        float location; 
 
        void makeNoise() 
        { 
                //소리를 낼 때의 행동 
        } 
 
        void eat() 
        { 
                //그 동물이 음식을 접했을 때의 행동 
        } 
 
        void sleep() 
        { 
                //그 동물이 잠들어 있을 때의 행동 
        } 
 
        void roam() 
        { 
                //그 동물이 먹거나 자고 있지 않을 때의 행동 
        } 
 
} 
class Feline extends Animal//Feline은 Animal을 상속받는다. 
{ 
        void roam() 
        { 
                //roam을 오버라이드한다. 
        } 
} 
 
class Canine extends Animal//Canine은 Animal을 상속받는다. 
{ 
        void roam() 
        { 
                //roam을 오버라이드한다. 
        } 
} 
 
class Lion extends Feline//Lion은 Feline을 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
} 
 
class Tiger extends Feline//Tiger은 Feline을 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
} 
 
 
 
class Cat extends Feline//Cat은 Feline을 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
} 
 
class Hiippo extends Animal//Hippo는 Animal을 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
} 
 
class Wolf extends Canine//Wolf는 Canine를 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
} 
 
class Dog extends Canine//Dog는 Canine를 확장한다. 
{ 
        void makeNoise() 
        { 
                //makeNoise를 오버라이드한다. 
        } 
 
        void eat() 
        { 
                //eat를 오버라이드한다. 
        } 
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 한다. 

 * 오버로딩:메소드 오버로딩은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것이다. 이를 활용하면 호출하는 쪽의 편의를 위해 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있다.


*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

1. 
public class MonsterTestDrive { 
        public static void main(String []args) { 
                Monster [] ma= new Monster[3]; 
                ma[0]=new Vampire(); 
                ma[1]=new Dragon(); 
                ma[2]=new Monstere(); 
                for(int x=0;,x<3;x++) { 
                        ma[x].fighten(x); 
                } 
        } 
} 
 
class Monster { 
        boolean frighten(int d) { 
                System.out.println("arrrgh"); 
                return true; 
        } 
} 
 
class Vampire extends Monster { 
        boolean frighten (int x) { 
                System.out.println("a bite?"); 
                return false; 
        } 
} 
 
class Dragon extends Monster { 
        boolean frighten (int degree) { 
                System.out.println("breath fire"); 
                return true; 
        } 
} 
---------------------------------------------------------------------
2. 
public class MonsterTestDrive { 
        public static void main(String []args) { 
                Monster [] ma= new Monster[3]; 
                ma[0]=new Vampire(); 
                ma[1]=new Dragon(); 
                ma[2]=new Monstere(); 
                for(int x=0;,x<3;x++) { 
                        ma[x].fighten(x); 
                } 
        } 
} 
 
class Monster { 
        boolean frighten(int x) { 
                System.out.println("arrrgh"); 
                return true; 
        } 
} 
 
class Vampire extends Monster { 
        boolean frighten (int f) { 
                System.out.println("a bite?"); 
                return 1; //Vampire의 리턴유형이 int여서 컴파일이 안됨 
        } 
} 
 
class Dragon extends Monster { 
        boolean frighten (int degree) { 
                System.out.println("breath fire"); 
                return true; 
        } 
} 
---------------------------------------------------------------------
3. 
public class MonsterTestDrive { 
        public static void main(String []args) { 
                Monster [] ma= new Monster[3]; 
                ma[0]=new Vampire(); 
                ma[1]=new Dragon(); 
                ma[2]=new Monstere(); 
                for(int x=0;,x<3;x++) { 
                        ma[x].fighten(x); 
                } 
        } 
} 
 
class Monster { 
        boolean frighten(int x) { 
                System.out.println("arrrgh"); 
                return false; 
        } 
} 
 
class Vampire extends Monster { 
        boolean frighten (int x) { 
                System.out.println("a bite?"); 
                return true; 
        } 
} 
 
class Dragon extends Monster { 
        boolean frighten (int degree) { 
                System.out.println("breath fire"); 
                return true; 
        } 
} 
---------------------------------------------------------------------
4. 
public class MonsterTestDrive { 
        public static void main(String []args) { 
                Monster [] ma= new Monster[3]; 
                ma[0]=new Vampire(); 
                ma[1]=new Dragon(); 
                ma[2]=new Monstere(); 
                for(int x=0;,x<3;x++) { 
                        ma[x].fighten(x); 
                } 
        } 
} 
 
class Monster { 
        boolean frighten(int z) { 
                System.out.println("arrrgh"); 
                return true; 
        } 
} 
 
class Vampire extends Monster { 
        boolean frighten (byte b) //int가 아닌 byte로 인자를 받아서  
         { 
                System.out.println("a bite?"); 
                return true; 
        } 
} 
 
class Dragon extends Monster { 
        boolean frighten (int degree) { 
                System.out.println("breath fire"); 
                return true; 
        } 
} 
 
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:100% 추상클래스로 자바에서 정말 필수불가결한 부분이다.
 * 다형성:'여러형태'를 의미한다.
 * 추상 클래스:클래스 선언시 앞에 abstract만 붙이면 된다. 추상클래스란, 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스를 의미하고 반드시 확장해야하는 클래스를 의미한다.
 * 추상 메소드:반드시 오버라이드해야하는 메소드를 의미한다. 중괄호없이 세미콜론을 써서 선언을 끝낸다. 추상 메소드를 만들 때는 클래스도 반드시 추상클래스여야한다.
 * 다중 상속:상위클래스를 두 개 사용하는 접근법이다. 하지만 여기에는 '죽음의 다이아몬드'라고 알려져 있는 문제가 있다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:힙은 모든 객체가 사는 곳이다. 인스턴스 변수는 객체 안에 살기 때문에 즉 인스턴스 변수가 힙 안에 살고 있는 것이다. 

 * 스택에서의 변수:스택은 메소드 호출과 지역 변수가 사는 곳이다. 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수만 스택에 들어간다. 객체 자체는 힙 안에 있다.
 * 생성자:객체를 생성할 때 실행되는 코드가 들어있다. 즉 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있다. 우리가 직접 만들지 않아도 된다. 

 * 널 레퍼런스:레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException? 이 생긴다. 

 
*298p 집중토론* _요약_

 * 인스턴스 변수:객체를 지원하는 역할을 하며 항상 객체와 함께 하나이다. 객체에 상태가 없으면 쓸모가 없는데 그 상태가 바로 인스턴스변수에 저장된 값이다. 객체와 함께 힙에 산다. 정확히는 객체 안에 산다. 객체가 가비지 컬렉터에 의해 처리된다면 인스턴스 변수도 없어지고 만다. 

 * 지역 변수: 객체가 중요한데 행동이 없으면 쓸모가 없다. 거기서 행동이란 것은 메소드에 들어있는 알고리즘이며 이 알고리즘을 작동시키려면 메소드에 지역변수가 있어야 한다. 지역 변수는 인스턴스 변수에 비해서 수명이 짧다. 지역 변수는 자신의 프레임이 스택 맨 위로 올라갈 때 까지 아무것도 하지 않는다. 인스턴스가 변수가 들어있는 객체를 지역 변수에서만 참조할 수도 있다 


*302p 5분 미스터리* _구현후 주석달기_

{{{

class V2Radiator 
{ 
        V2Radiator(ArrayList<SimUnit> list) 
        { 
                for(int x = 5; x < 5 ; x++) 
                { 
                        list.add(new SimUnit("V2Radiator"));//list에 SimUnit 객체를 더한다. 
                } 
        } 
} 
 
class V3Radiator //extends V2Radiator 
{ 
        V3Radiator(ArrayList<SimUnit> lglist) 
        { 
                //super(lglist); 
                for(int g = 0; g < 10 ; g++) 
                { 
                        lglist.add(new SimUnit("V3Radiator"));//lglist에 SimUnit객체를 더한다. 
                } 
        } 
} 
 
class RetentionBot 
{ 
        RetentionBot(ArrayList<SimUnit> rlist) 
        { 
                rlist.add(new SimUnit("Rention"));//rlist에 SimUnit객체를 더한다. 
        } 
} 
 
public class TestLifeSupportSim  
{ 
        public static void main(String[] args) 
        { 
                ArrayList<SimUnit> aList = new ArrayList<SimUnit>();//ArrayList를 만든다. 
                V2Radiator v2 = new V2Radiator(aList);//V2Radiator객체 생성한다. 
                V3Radiator v3 = new V3Radiator(aList);//V3Radiator객체 생성한다. 
                for(int z = 0 ; z < 20 ; z++) 
                { 
                        RetentionBot ret = new RetentionBot(aList);//RententionBot객체 생성한다. 
                } 
        } 
} 
 
class SimUnit 
{ 
        String botType;//문자열 선언한다.
        SimUnit(String type) 
        { 
                botType = type;
        } 
        int powerUse() 
        { 
                if("Retention".equals(botType)) 
                { 
                        return 2;                        
                } 
                else 
                { 
                        return 4; 
                } 
        } 
} 


}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않은 메소드이다. 클래스만 있어도 가능하다. 정적메소드를 호출할 때는 클래스명을 사용한다. 

 * 정적 메소드를 선언하는 방법:static 이라는 키워드를 사용하면 클래스의 인스턴스 없이 메소드를 실행할 수 있다. 

 * static final:final로 지정한 변수는 일단 초기화되고나면 절대 그 값을 바꿀 수 없다. 즉 static final 로 선언한 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지한다. 상수의 변수명은 모두 대문자로 쓴다.
 * 널 레퍼런스:레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException? 이 생긴다
 * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능이다. 

 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 정적 임포트를 활용하여 타이핑을 적게 해보자는 개념이다. 잘못 사용하면 코드의 가독성이 크게 떨어질 수 있다. 


*339p Calendar* _구현후 주석달기_

{{{

public class Calendercheck 
{ 
        public static void main(String[] args) 
        { 
                Calender c = Calender.getInstance(); 
                c.set(2004,0,7,15,40);//시각을 2004년 1월 7일 15:40 으로 설정한다.
                long day1 = c.getTimeInMillis();//1970년 1월1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴한다.
                day1 += 1000 * 60 * 60; 
                c.setTimeInMillis(day1);//한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신한다. 
                System.out.println("new hour" + c.get(c.HOUR_OF_DAY)); 
                c.add(c.DATE, 35);//35일을 더한다. 
                System.out.println("add 35 days " + c.getTime()); 
                c.roll(c.DATE, 35);//35일 뒤로 넘긴다. 하지만 달은 바뀌지 않는다.
                System.out.println("roll 35 days " + c.getTime()); 
                c.set(c.DATE, 1);//날짜를 1로 설정한다. 
                System.out.println("set to 1 " + c.getTime()); 
                 
         
        } 
}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:인스턴스마다 하나씩 있다. 

 * 정적 변수: 상수이다. 인스턴스마다 하나씩 있는 게 아니고 클래스마다 하나씩 있다.(메모리 절약을 위해서). 한 클래스에 속하는 모든 인스턴스에 의해서 공유된다. 


*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class StaticSuper{ 
 
        static { //ststic 메소드. 딱 한번 실행된다. 
        System.out.println("super static block"); 
        } 
 
        StaticSuper() { //StaticSuper는 생성자이므로 반드시 ()가 있어야한다. 
        System.out.println("super constructor"); 
        } 
} 
 
public class StaticTests extends StaticSuper { //StaticTests 는 StaticSuper을 확장한다.
 
        static int rand; //static 변수. 
 
        static { //static 메소드. 
        rand=(int_ (Math.random()*6); 
        System.out.println("static block " + rand); 
        } 
 
        StaticTests(){ //생성자. 
        System.out.println("constructor"); 
        { 
 
        public static void main(String [] args) { 
        System.out.println("in main"); 
        StaticTests st = new StaticTests (); //StaticTests 객체를 생성한다. 
        } 
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

public class Test 
{ 
 
        public static void main() 
        { 
                 
         
        public void takeRisk() throws BadException 
        { 
                if(abandonAllHope) 
                { 
                        throw new BadException(); 
                } 
        } 
         
        public void crossFingers() 
        { 
                try 
                { 
                        anObject.takeRisk();    //오류가 발생할 수 있는 행동이다. 
                } 
                catch(BadException ex) 
                { 
                        System.out.println("Aaargh!");//오류를 잡으면 출력한다.
                        ex.printStackTrace(); 
                } 
        } 
         
        } 
}

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

public class MiniMiniMusicApp 
{ 
        public static void main(String[] args) 
        { 
                MiniMiniMusicApp mini = new MiniMiniMusicApp(); 
                mini.play();//play 메소드 호출 
        } 
         
        public void play()//play 메소드 
        { 
                try 
                { 
                        Sequencer player = MidiSystem.getSequencer();//Sequencer를 얻는다. 
                        player.open();//Sequencer를 연다.
                         
                        Sequence seq = new Sequence(Sequence.PPQ, 4); 
                         
                         
                        Track track = seq.createTrack();//Track을 생성한다. 
                         
                        ShortMessage a = new ShortMessage(); 
                        a.setMessage(144, 1, 44, 100); 
                        MidiEvent noteOn = new MidiEvent(a, 1); 
                        track.add(noteOn); 
                         
                        ShortMessage b = new ShortMessage(); 
                        b.setMessage(128, 1, 44, 100); 
                        MidiEvent noteOff = new MidiEvent(b, 16); 
                        track.add(noteOff); 
                         
                  
                       
               
                         
                        player.setSequence(seq);//Sequencer에 Sequence를 보낸다.
                         
                        player.start();//Sequencer의 start()메소드를 호출한다.
                         
                } 
                catch(Exception ex) 
                { 
                        ex.printStackTrace(); 
                         
                } 
                 
        }
}

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

public class MiniMusicCmdLine {  
 
        public static void main(String[]args){ 
                MiniMusicCmdLine mini = new MiniMusicCmdLine();//MiniMusicCmdLine 생성한다.
                if(args.length<2){ 
                        System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요."); 
                }else{ 
                        int instrument = Integer.parseInt(args[0]); 
                        int note = Integer.parseInt(args[1]); 
                        mini.play(instrument, note);//인자를 전달하면서 play메소드호출한다.
                } 
        }
 
          
        public void play (int instrument, int note){//play메소드 
                try{ 
                        Sequencer player = MidiSystem.getSequencer(); 
                        player.open(); 
                        Sequence seq = new Sequence(Sequence.PPQ, 4); 
                        Track track = seq.createTrack(); 
 
                        MidiEvent event = null; 
 
                        ShortMessage first = new ShortMessage(); 
                        first.setMessage(192,1,instrument,0); 
                        MidiEvent changeInstrument = new MidiEvent(first, 1); 
                        track.add(changeInstrument); 
 
                        ShortMessage a = new ShortMessage(); 
                        a.setMessage(144,1,note,100); 
                        MidiEvent noteOn = new MidiEvent(a,1); 
                        track.add(noteOn); 
 
                        ShortMessage b = new ShortMessage(); 
                        a.setMessage(128,1,note,100); 
                        MidiEvent noteOff = new MidiEvent(b,16); 
                        track.add(noteOff); 
                        player.setSequence(seq); 
                        player.start(); 
                }catch(Exception ex){ex.printStackTrace();} 
        }
}

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}