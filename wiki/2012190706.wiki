#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

package ch1;

public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99;  //int형 변수이름을 beerNum 으로하고 99를 초기화합니다.
		String word = "bottles";  // String 형 변수이름을 word로 하고 bottles 로 초기화합니다.
		
		while (beerNum > 0) {
			
			if (beerNum == 1) {
				word = "bottle";
			}  //만약 beerNum 이 1이라면 word에 bottle 을 저장시킵니다.
			
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum - 1; 
			
			/*
                        // 아래의 문장은 필요 없기에 주석처리하였습니다.         

                       if (beerNum > 0 ) {
				System.out.println(beerNum + " " + word + " of beer on the wall");
			} else { 
                        
                        
                        */
			
			if(beerNum == 0)
				{System.out.println("No more bottles of beer on the wall");
			} //  if 문 끝
		} // while 순환문 끝
	} //main 클래스 끝
} //클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

package ch1;

public class PhraseOMatic {
	public static void main (String[] args) {
		
		//세 종류의 단어 목록을 만듭니다. 적당히 이필요한 단어를 추가해도 됩니다.
		String[] wordListOne = {"능호","채원","성호","영현","규원","종한"};
		String[] wordListTwo = {"은","는"};
		String[] wordListThree = {"바보예요","멍청이예요","멋쟁이예요","사랑스러워요","잘생겼어요",
"교수님을 좋아해요","교수님을 싫어해요"};
		
		// 각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		// 난수 세 개를 발생시킵니다.
		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);
		
		// 이제 구문을 만듭니다.
		String phrase = wordListOne[rand1] + wordListTwo[rand2] + " " + wordListThree[rand3];
		
		// 구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
		}
	}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:  바이트코드로 작성된 프로그램을 해석해서 실행하는 프로그램
 * 컴파일러:  잘못된 코드 부분을 알려주고 소스 코드를 바이트코드로 바꿔주는 프로그램

*55p 컴파일러가 되어봅시다* _구현후 주석달기_
는
{{{

----A----

package ch1;

class Exercise1b1 {  
	public static void main(String [] args)  {
		int x = 1;
		while( x<10) {
			if(x>3) {
				System.out.println("big x");
				
			}
			x=x+1; // 이거를 안붙여주면 무한루프가 되어 아무 값도 안나옵니다.
		}
	}

}
코딩결과
big x
big x
big x
big x
big x
big x


----B----

package ch1;

class Exercise1b {   //class Exercise1b 를 붙어줍니다.
	public static void main(String [] args)  {
		int x = 5;
		while( x > 1) {
			x=x-1;
			if(x>3) {
				System.out.println("small x");
			}
		}
	} // 앞에서 class Exercise1b { 를 붙였으니 여기서 } 를 붙여줍니다.
}

코딩결과 
small x


----C----

package ch1;

class Exercise1b {  
	public static void main(String [] args)  { //public static void main(String [] args)  { 가 없으니 추가해줍니다.
		int x = 5;
		while( x>1) {
			
			x=x-1;
			if(x>3) {
				System.out.println("small x");
			}
		}
	}
}

코딩결과
small x


}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터)를 나태내며 그 유형에 속하는 각 개체마다 값이 다릅니다.
 * 메소드:객체에서 할수 있는일을 뜻합니다.
 * 클래스: 객체의 청사진으로 인스턴스 변스와 메소드를 가지고 있습니다. 클래스의 상속을 받아 객체를 만들수 있습니다.
 * 테스트용 클래스: main()메소드를 가지고 있으며 새로운 유형의 객체를 만들고 점 연산자를 써서 새로운 객체의 메소드와 변수에 접근할 수 있게 하기 위한 클래스입니다.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channelnumber,tvinformation
 * 메소드: getchannelnumber(), display()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

package ch2;

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight =false;
		boolean p2isRight =false;
		boolean p3isRight =false;
		boolean p4isRight =false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
	
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight || p4isRight ) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break;
				
			} else {
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

public class Player {
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}

public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}
코드 결과
0 이상 9 이하의 숫자를 맞춰보세요.
맞춰야 할 숫자는 7입니다.
찍은 숫자: 9
찍은 숫자: 2
찍은 숫자: 2
찍은 숫자: 9
1번 선수가 찍은 숫자: 9
2번 선수가 찍은 숫자: 2
3번 선수가 찍은 숫자: 2
4번 선수가 찍은 숫자: 9
다시 시도해야 합니다.
맞춰야 할 숫자는 7입니다.
찍은 숫자: 5
찍은 숫자: 7
찍은 숫자: 9
찍은 숫자: 0
1번 선수가 찍은 숫자: 5
2번 선수가 찍은 숫자: 7
3번 선수가 찍은 숫자: 9
4번 선수가 찍은 숫자: 0
맞춘 선수가 있습니다.
1번 선수: false
2번 선수: true
3번 선수: false
4번 선수: false
게임 끝.




}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

----A----

package ch2;

class TapeDeck {
	
	boolean canRecord = false ;
	
	void playTape() {
		System.out.println("tape playing");
		
	}
	
	void recordTape() {
		System.out.println("tape recording");
		
	}

}

class TapeDeckTestDrive {
	public static void main(String [] args) {
		TapeDeck t = new TapeDeck(); // 이걸 만들어야지 TapeDeck 클래스의 객체 t가 만들어짐. 그리고 점연산자를 쓸수 있게됨.
		t.canRecord = true;
		t.playTape();
		
		if(t.canRecord == true) {
			t.recordTape();
			
		}
	}	
}

코딩 결과
tape playing
tape recording


----B----
package ch2;

class DVDPlayer {
	
	boolean canRecord = false ;
	
	void playDVD() {
		System.out.println("DVD playing");
	} // 밑에 d.playDVD(); 가 있는데 여기서 playDVD() 라는 메소드를 정의안하면 오류가 생기기때문에 임의로 메소드 하나를 만들었습니다.
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
}

class DVDPlayerTestDrive {
	public static void main(String [] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		
		if(d.canRecord == true) {
			d.recordDVD();
			
		}
	}

}

코딩 결과
DVD playing
DVD recording



}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시변수는 값이 들어가있고 레퍼런스변수는 참조하는 객체를 연결해주는 정보가 들어가 있다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

package ch3;

class Dog {
	String name; //인스턴스 변수를 선언합니다.
	public static void main (String[] args) {
		Dog dog1 = new Dog(); //dog1 이라는 Dog 객체를 만듭니다.
		dog1.bark(); //bark 라는 매소드를 실행합니다.
		dog1.name = "Bart"; // dog1 의 인스턴스변수인 name 에 Bart를 저장시킵니다.
		
		Dog[] myDogs = new Dog[8]; // myDogs 라는 객체 배열을 만듭니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		myDogs[3] = new Dog();
		myDogs[4] = new Dog();
		myDogs[5] = new Dog();
		myDogs[6] = new Dog();
		myDogs[7] = new Dog();
		// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
	
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";
		

		int i= 3;
		while (i < myDogs.length) {
			myDogs[i].name = i + "번째 강아지";
			i = i + 1;
			
		}
		// 개의 이름을 순환문을 이용해 저장시킵니다.
		
		System.out.print("마지막 개의 이름: ");
		System.out.println(myDogs[2].name);
		
		// myDogs[2] 의 이름을 출력합니다.
		
		int x = 0;
		while(x<myDogs.length) {
			myDogs[x].bark();
			x=x+1;
		}
	}
	// 순환문을 이용해 myDogs[0]부터 myDogs[7] 까지 bark 매소드를 실행시킵니다.
	
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	
	}
	//bark 매소드 입니다.
	
	public void eat() { } //eat 매소드 입니다.
	public void chaseCat() { } //chaseCat 매소드입니다.
	
	
}

코딩 결과
null이(가) 왈!하고 짖습니다.
마지막 개의 이름: Bart
Fred이(가) 왈!하고 짖습니다.
Marge이(가) 왈!하고 짖습니다.
Bart이(가) 왈!하고 짖습니다.
3번째 강아지이(가) 왈!하고 짖습니다.
4번째 강아지이(가) 왈!하고 짖습니다.
5번째 강아지이(가) 왈!하고 짖습니다.
6번째 강아지이(가) 왈!하고 짖습니다.
7번째 강아지이(가) 왈!하고 짖습니다.
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
----A----
package ch3;

class Books {
	String title;
	String author;
} //Books 클래스를 만듭니다.

public class BooksTestDrive {
	public static void main(String [] args) {
	
		Books [] myBooks = new Books[3]; // 배열 레퍼런스를 만듭니다.
		int x = 0;

		int i = 0;
		while ( i <3) {
			myBooks[i] = new Books();
			i = i+1;
		} //책에서는 이부분이 없어서 오류가 나게 됩니다. 순환문을 이용해 배열 레퍼런스가 Books 객체에 접근하도록 합니다.

		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		//title과 author에 정보를 입력합니다.
		
		while(x<3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x=x+1;
		} // 순환문을 이용해 title by author 순으로 출력하도록 만듭니다.
	}

}
코딩 결과
The Grapes of Java by bob
The Java Gatsby by sue
The Java Cookbook by ian

----B----
package ch3;

class Hobbits { //Hobbits 클래스를 만듭니다.

	String name;
	
	public static void main(String [] args) {
		
		Hobbits [] h = new Hobbits[3]; // 배열 레퍼런스를 만듭니다
		int z = 0;
		
		while (z<3) { //책에는 z<4 인데 배열이 3이 므로 3을 해줘야 합니다.
			// z = z+1; // 책에는 이부분때문에 Hobbits[2] 부분이 짤리게 됩니다. 이 식을 맨 밑으로 내려야 정상적인 결과가 나옵니다.
			h[z] = new Hobbits(); //배열 레퍼런스를 써서 Hobbits 객체에 접근합니다.
			h[z].name = "bilbo"; // h[0]의 name 에 bilbo 가 들어가게 됩니다.
			if(z==1) {
				h[z].name = "frodo"; //z=1 일 때, h[1]의 name 에 frodo 가 들어가게 됩니다.
			}
			
			if (z==2) {
				h[z].name = "sam"; //z=2 일 때, h[2]의 name 에 sam 이 들어가게 됩니다.
			}
			
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobiit name"); //name is a good Hobbit name 이 나오게 출력합니다.
			z=z+1; // 이부분으 추가 시켜줘야 정상적인 결과가 나옵니다.
		}
	}
}

코딩 결과
bilbo is a good Hobiit name
frodo is a good Hobiit name
sam is a good Hobiit name
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 밥은 연락처 10개에 다 접근할수 있는 반면에 켄트는 맨 마지막꺼에만 접근할 수있고 그 전에 접근했떤 연락처에는 접근할수 없어서 밥이 이겼습니다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 바뀌면 안되는 정보들을 
 * 게터와 세터: 개터는 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰이고 세터는 그 세터가 설정할 값을 인자로 받아서 인스터늣 변수를 그 값으로 설정하기 위한 용도로 쓰입니다.
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언됩니다. 지역변수는 메소드 내에서 선언됩니다.
 
*107p Dog* _실행_

{{{
package ch4;

class Dog {
	int size;
	String name;
	
	void bark() {
		if (size > 60) { 
			System.out.println("Woof! Woof!"); //size가 60보다 크면 Woof! Woof! 를 표시합니다.
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!"); //size가 14보다 크면 Ruff! Ruff! 를 표시합니다.
		} else {
			System.out.println("Yip! Yip!"); //size가 14이하이면 Yip! Yip! 를 표시합니다.
		}
	}

}

class DogTestDrive {
	
	public static void main (String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		// 각 객체를 만들고 size값을 입력합니다.
		one.bark();
		two.bark();
		three.bark();
		// bark() 메소드를 실행합니다.
	}

}

코딩 결과
Woof! Woof!
Yip! Yip!
Ruff! Ruff!

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

-----A-----
package ch4;

class XCopy {
	public static void main(String [] args) {
		int orig = 42; // orig 란 변수에 42를 넣는다.
		XCopy x = new XCopy(); // x 라는 XCopy 객체를 만듭니다.
		int y = x.go(orig); // y 에 x.go(orig) 메소드를 실행시킨 값을 저장시킵니다.
		System.out.println(orig + " " + y); //  orig 값과 y값을 순서대로 나타냅니다.
	}
	
	int go(int arg) { 
		arg = arg *2;
		return arg;
	} // arg * 2 가 되도록하는 매소드 go를 만듭니다.

}

코딩 결과
42 84


----B-----
package ch4;

class Clock {

	String time;
	
	void setTime(String t) {
		time = t;
		
		// setTime 메소드를 만든다. 이건 세터라 볼 수 있다.
		
	}
	
	String getTime() {    //책은 void 인데 리턴값은 String 이다. 그래서 String 으로 바꿔줘야한다.
		return time;
	
		// getTime 메소드를 만든다. 이건 게터라 볼 수 있다.
		
	}
	
}

class ClockTestDrive {
	public static void main(String [] args) {
		
		Clock c = new Clock(); //c라는 Clock 객체를 만든다.
		
		c.setTime("1245"); //세터를 이용해 "1245"를 time 에 넣는다.
		String tod = c.getTime(); //tod 에 게터로 받아 들인 값을 넣는다.
		System.out.println("time: " + tod); // time tod 순으로 출력한다.
	}
}



코딩 결과
time: 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_
최근의 소프트웨어 개밟 방법론 분야로써 많은 사람들이 프로그래머들이 정말 원하는 방법이라고 한다. XP의 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는 점입니다.


 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
package ch5;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.println(prompt + "");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
		
	}

} //GameHelper 클래스 입니다.

public class SimpleDotCom {
	int[] locationCells; //int 배열을 만듭니다.
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) {
		locationCells = locs; //받은 배열을 locationCells에 넣습니다. 세터입니다.
		
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess); //stringGuess를 인트형 값으로 만듭니다.
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		} // locationCells의 길이만큼 0부터 증가합니다. guess와 locationCells[i]의 값이 같으면 result에 hit을 넣고 numOfHits의 수를 1 증가시킵니다.
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		} // locationCells의 길이 numOfHits 의 값이 같으면 result에 kill를 넣습니다.
		
		System.out.println(result); //result의값을 출력합니다.
			return result; // result를 반환합니다.
		
	}
}

public class SimpleDotComTestDrive {
	public static void main (String[] args) {
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); //helper 라는 GameHelper 객체를 만듭니다.
		
		SimpleDotCom theDotCom = new SimpleDotCom(); //theDotCom 이라는 simpleDotCom 객체를 만듭니다.
		int randomNum = (int) (Math.random()*5); // 랜덤으로 수를 뽑는데 0에서 4.9999.. 사이의 값을 int로 캐스트 햇으므로 0,1,2,3,4의 값만 randomNum으로 들어간다.
		
		int[] locations = {randomNum,randomNum+1,randomNum+2}; //locations 배열에 값을 넣어준다.
		theDotCom.setLocationCells(locations); // locations 의 값을 세터해준다.
		boolean isAlive = true; //while 문을 빠져나가게 하기 위한 수단이다.
		
		while(isAlive ==true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess); //checkYourself 를 하고 난뒤 리턴값이 result에 저장된다.
			numOfGuesses++; //numOfGuesses 의 값을 1만큼 증가시킨다.
			if(result.equals("kill")) {
				isAlive = false; // 이 if문을 만족한다는 말 자체가 닷컴을 다 죽였단 말이므로 while 문을 더이상 못 돌리게 해야한다. 그래서 isAlive를 false가 되게 해 while문을 빠져나오도록 해준다.
				System.out.println(numOfGuesses + " guesses"); // numOfGuesses guesses 가 출력되도록 한다.1
				
			}
		}
	}
}

코딩 결과
enter a number
0
miss
enter a number
1
miss
enter a number
2
hit
enter a number
3
hit
enter a number
4
kill
5 guesses

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
package ch6;

import java.util.ArrayList;

public class DotCom {
	private ArrayList<String> locationCells; //string ArrayList인 locationCells 를 만듭니다.
	
	public void setLocationCells(ArrayList<String> loc) {
		locationCells = loc;
		
	} // 입력받은 어레이리스트를 locationCells 로 입력해주는 세터입니다.

	public String checkYourself(String userInput) {
		String result = "miss"; 
		int index = locationCells.indexOf(userInput); //userInput이 locationCells안에 있으면 그 해당 index를 저장하고 아니면 -1을 저장합니다.
		if(index>=0) {
			locationCells.remove(index); // locationCells의 해당위치의 숫자를 삭제합니다.
			
			if(locationCells.isEmpty()) {
				result = "kill";
			} else {
				result = "hit";
				
			}
			// locagtionCells를 다맞혀서 비어있다면 "kill"을 , 그렇지 않다면 "hit"을 result에 저장합니다.
		}
		return result;
	}
}

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
package ch6_1;

import java.util.*;

public class DotCom {
	private ArrayList<String> locationCells; //어레이리스트 locationCells를 만듭니다.
	private String name; // 닷컴의 이름이 되는 스트링 변수를 선언합니다.
	
	public void setLocationCells(ArrayList<String> loc)	{
		locationCells = loc;
	} //locationCells에 값을 넣기 위한 세터입니다.
	
	public void setName(String n) {
		name = n;
		
	} //name 에 값을 넣기 위한 세터입니다.

	public String checkYourself(String userInput) {
		String status = "miss"; //status 의 초기값은 miss입니다.
		int index = locationCells.indexOf(userInput); // index 에 유저가 입력한 값의 항목의 index숫자를 저장합니다.
		if(index >= 0) {
			locationCells.remove(index); //항목을 삭제합니다. 
			if(locationCells.isEmpty()) {
				status = "kill"; //비어 있으면 status 를 kill 로 바꿉니다.
				System.out.println("Ouch! You sunk " + name + "   : ( ");
			} else {
				status = "hit"; // 비어 있지 않으면 hit 으로 바꿉니다.
			}
		}
		return status;
	}
}

import java.util.*;

public class DotComBust {
	
	private GameHelper helper = new GameHelper(); //GameHelper 의 객체 helper를 만듭니다.
	private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>(); // ArrayList인 dotComsList를 만듭니다.
	private int numOfGuesses = 0; // 추측한 횟수를 저장합니다.
	
	private void setUpGame() {
		DotCom one = new DotCom();
		one.setName("Pets.com");
		DotCom two = new DotCom();
		two.setName("eToys.com");
		DotCom three = new DotCom();
		three.setName("Go2.com");
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three);
		//아까 만든 어레이리스트 dotComsList에 DotCom 객체인 one,two,three 를 넣습니다.
		
		System.out.println("Your goal is to sink three dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in the fewest number of guesses");
		// 뭘해야하는지 알려줍니다.
		
		for (DotCom dotComToSet : dotComsList) {
			ArrayList<String> newLocation = helper.placeDotCom(3); // newLocation 에 위치 3개를 저장합니다.
			dotComToSet.setLocationCells(newLocation); //dotComsList에 있는 각원소에 위치 3개를 지정해줍니다. 세터죠!
		}
	}
	
	private void startPlaying() {
		while(!dotComsList.isEmpty()) { //dotcomsList가 비어 있지 않으면 실행합니다.
			String userGuess = helper.getUserInput("Enter a guess"); //추측값을 쓰게하고 userGuess에 그 값을 저장합니다. 
			checkUserGuess(userGuess); //유저가 입력한 값으로 checkuserGuess 메소드를 실행합니다.
		}
	}
	
	private void checkUserGuess(String userGuess)	{
		numOfGuesses++; //추측값을 증가시킵니다.
		String result = "miss"; // 맨처음 result 는 miss로 초기화합니다.
		for (DotCom dotComToTest : dotComsList) { 
			result = dotComToTest.checkYourself(userGuess); //result에 checkYourself를 실행하고 얻은 리턴값을 저장합니다.
			if (result.equals("hit")) {
				break;
			} //result의 값이 hit이면 순환문을 빠져나옵니다.
			
			if (result.equals("kill")) {
				dotComsList.remove(dotComToTest); //result의 값이 kill 이면 dotComsList에서 그 항목을 빼닙니다.
				break;
			} 
		}
		System.out.println(result); // result의 값을 출력합니다.
	}
	
	private void finishGame() {
		System.out.println("All Dot Coms are dead! Your stock is now worthless");
		if(numOfGuesses <= 18) {
			System.out.println("It only took you" + numOfGuesses + " guesses.");
			System.out.println("You got out before your options sank");
		} else {
			System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
			System.out.println("Fish are dancing with your options");
		}	
	} //몇번만에 맞췄는지에 따라 출력을 달리합니다.
	
	public static void main (String[] args)	{
		DotComBust game = new DotComBust(); //DotComBust 객체인 game을 만듭니다.
		game.setUpGame();  //setUpGame메소드를 실행합니다. 
		game.startPlaying(); //startPlaying메소드를 실행합니다.
		game.finishGame(); //finishGame 메소드를 실행합니다.
	}
}

import java.io.*;
import java.util.*;

public class GameHelper {
	
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int [] grid = new int[gridSize];
	private int comCount = 0;
	
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.println(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(
					new InputStreamReader(System.in)) ;
			inputLine = is.readLine();
			if (inputLine.length() == 0 ) return null;
		} catch(IOException e) {
			System.out.println("OException: " + e);
		}
		return inputLine.toLowerCase();
	}
	
	public ArrayList<String> placeDotCom(int comSize) {
		ArrayList<String> alphaCells = new ArrayList<String> ();
		String[] alphacoords = new String [comSize];
		String temp = null;
		int [] coords = new int[comSize];
		int attempts = 0;
		boolean success = false;
		int location = 0;
		
		comCount++;
		int incr = 1;
		if((comCount &2) == 1) {
			incr = gridLength;
		}
		
		while (!success & attempts++ < 200) {
			location =(int) (Math.random() * gridSize);
			
			int x = 0;
			success = true;
			while(success && x < comSize) {
				if (grid[location] == 0) {
					coords[x++] = location;
					location += incr;
					if(location >= gridSize) {
						success = false;
					}
					if(x>0 & (location % gridLength == 0)) {
						success = false;
					}
					
				} else {
					success = false;
				}
			}
		}
		
		int x= 0;
		int row = 0;
		int column = 0;
		
		while(x<comSize) {
			grid[coords[x]] = 1;
			row= (int)	(coords[x] / gridLength);
			column = coords[x]	% gridLength;
			temp = String.valueOf(alphabet.charAt(column));
			
			alphaCells.add(temp.concat(Integer.toString(row)));
			x++;
		}
		return alphaCells;
	}
} //GameHelper 클래스 코드입니다.

코딩결과
Your goal is to sink three dot coms.
Pets.com, eToys.com, Go2.com
Try to sink them all in the fewest number of guesses
Enter a guess 
a0
miss
Enter a guess 
a1
miss
Enter a guess 
a2
miss
Enter a guess 
a3
miss
Enter a guess 
a4
hit
Enter a guess 
a5
miss
Enter a guess 
b4
hit
Enter a guess 
c4
Ouch! You sunk Pets.com   : ( 
kill
Enter a guess 
a6
miss
Enter a guess 
a7
miss
Enter a guess 
b0
miss
Enter a guess 
b1
miss
Enter a guess 
b2
miss
Enter a guess 
b3
miss
Enter a guess 
b5
miss
Enter a guess 
b6
miss
Enter a guess 
b7
miss
Enter a guess 
c0
hit
Enter a guess 
c1
miss
Enter a guess 
d0
hit
Enter a guess 
e0
Ouch! You sunk eToys.com   : ( 
kill
Enter a guess 
f0
miss
Enter a guess 
f1
miss
Enter a guess 
f2
miss
Enter a guess 
f3
miss
Enter a guess 
f4
miss
Enter a guess 
f5
miss
Enter a guess 
f6
miss
Enter a guess 
f7
miss
Enter a guess 
g0
miss
Enter a guess 
g1
miss
Enter a guess 
g2
miss
Enter a guess 
g
miss
Enter a guess 
g3
miss
Enter a guess 
g4
miss
Enter a guess 
g5
miss
Enter a guess 
g6
miss
Enter a guess 
c6
miss
Enter a guess 
d6
miss
Enter a guess 
e6
miss
Enter a guess 
f6
miss
Enter a guess 
g6
miss
Enter a guess 
e1
miss
Enter a guess 
e2
hit
Enter a guess 
e3
miss
Enter a guess 
f2
miss
Enter a guess 
e2
miss
Enter a guess 
d2
hit
Enter a guess 
c2
Ouch! You sunk Go2.com   : ( 
kill
All Dot Coms are dead! Your stock is now worthless
Took you long enough. 49 guesses.
Fish are dancing with your options
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 하위클래스가 상위클래스의 멤버(인스턴스변수,메소드)를 물려받는다는 것을 의미합니다.
 * 다형성: 다형성을 이용해 메소드 매개변수를 상위클래스 유형으로 선언하면 실행할 때 어떤 하위 클래스의 객체도 전달할 수 있어서 편리하다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{
package ch7;

public class animal {
	String picture;
	String food;
	int hunger;
	int boundaries;
	String location;
	
	void makeNoise() {
		//소리를 낼때의 행동
	}
	void eat() {
		//음식을 접했을 대의 행동
	}

	void sleep() {
		//잠들어 있을 때의 행동
	}
	void roam() {
		//먹이를 찾아 다닐때의 해옫ㅇ
	}
}

public class Feline extends animal{
	
	void roam() {
		//Feline 소리를 낼때의 행동
	}

}

public class Lion extends Feline {
	void makeNoise(){
		//사자 소리를 낼때의 행동
	}
	void eat() {
		//사자가 먹이를 접했을 때의 행동
	}

}

public class Tiger extends Feline {
	void makeNoise() {
		//호랑이가 소릴를 낼때의 행동
	}
	void eat() {
		//호랑이가 먹을때의 행동
	}
}

public class Cat extends Feline{
	void makeNoise(){
		//고양이가 소리낼때의 행동
	}

	 void eat() {
		 //고양이가 먹을때의 행동
	 }
}

public class Hippo extends animal{
	void makeNoise(){
		//하마가 소리를 낼때의 행동
	}
	void eat() {
		//하마가 먹이를 접했을 때의 행동
	}

}

public class Canine extends animal{
	void roam() {
		//cCanine 이 먹이를 찾아다닐때의 행동
	}

}

public class Wolf extends Canine{
	void makeNoise(){
		//늑대기 소리를 낼때의 행동
	}
	void eat() {
		//늑대가 먹이를 접했을 때의 행동
	}

}

public class Dog extends Canine{
	void makeNoise(){
		//개가 소리를 낼때의 행동
	}
	void eat() {
		//개가 먹이를 접했을 때의 행동
	}

}
}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이드는 하위클래스에서 상위클래스에서 상속받은 메소드를 바꾸는 것이다. 규칙이 있는데 인자는 독같아야 하고 리턴 유형도 호환가능해야 한다. 또 메소드를 더 접근하기 어렵게 만들면 안된다.
 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두개를 만드는 것입니다. 규칙은 리턴 유형이 달라도 되지만 리턴 유형만 바꿀 수는 없습니다. 또 접근 단계를 마음대로 바꿀 수 있습니다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
package ch7_1;

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3]; //레퍼런스 배열을 만듭니다.
		ma[0] = new Vampire(); //뱀파이어 클래스는 몬스터 클래스를 상속받으니 이런 관계가 가능합니다.
		ma[1] = new Dragon(); //드래곤 클래스는 몬스터 클래스를 상속받으니 이런 관계가 가능합니다.
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++) {
			ma[x].frighten(x); // 다형성을 이용해서 frighten 매소드를 실행시킵니다.
		}
	}

}

public class Monster {
	boolean frighten(int d) {
		System.out.println("arrrgh"); //arrrgh 를 출력합니다.
		return true;
		
	}

}

public class Vampire extends Monster{
	boolean frighten(int x) {
		System.out.println("a bite?"); //a bite? 를 출력합니다.
		return false;
	}

}

public class Dragon extends Monster{ //몬스터를 상속받습니다.
	boolean frighten(int degree) {
		System.out.println("breath fire"); //breath fire 을 출력합니다.
		return true;
	}

}

코딩결과
a bite?
breath fire
arrrgh

1번은 위에 보듯이 가능합니다.
2번은 Vamprie 의 리턴유형이 int 라서 안됩니다. 리턴유형만 바꾸는 것은 오버라이드도 오버로드도 아니기때문입니다.
3번,4번은 arrrgh ,breath fire, arrrgh 로 코딩결과가 나옵니다. 3번은 뱀파이어의 frighten 을 바꿨어야 했는데 scare로 새로운 메소드를 만들어서 scare의 내용이 적용이 안됬습니다. 4번은 뱀파이어의 frighten 이 인자를 byte로 받아 오버로드 된격이 되었습니다. 인자는 int 이므로 monster에서 상속받은 frighten 을 그대로 사용하게 되었습니다. 그래서 3,4번 결과는 책의 요구사항과 다릅니다.
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 다중 상속의 단점의 해결책으로써 추상 클래스와 비슷하다. 인터페이스로 다른 상속 트리에 들어있는 클래스에도 공통적인 인터페이스를 구현할 수 있다.
 * 다형성: 같은 이름의 함수 호출에 대하여 객체에 따라 다른 동작을 할 수 있도록 구현 하는 것을 말한다.
 * 추상 클래스: 클래스를 만들 때 객체를 만들 수 없게 하고 싶은 클래스를 abstract 를 이용해 추상클래스를 만듭니다.
 * 추상 메소드: 실제 메소드 코드를 전혀 집어넣지는 않았더라도 일련의 하위클래스를 위한 규약의 일부를 정의하기 위한 것입니다. 
 * 다중 상속:상위 클래스를 두 개 사용하는 접근법

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객체가 사는 곳으로써 객체속의 변수(인스턴스 변수)는 그 객체속에서 삽니다.
 * 스택에서의 변수: 스택은 메소드와 지역변수가 사는 곳으로 스택 프레임에 해당 메소드와 지역변수가 들어 있습니다.
 * 생성자: 생성자는 객체를 생성할 때 실행되는 코드가 들어있으므로, 객체 만들기 전에 무언가 필요하다면 생성자를 이용해 설정할 수 있다.
 * 널 레퍼런스: 널 레퍼런스는 리모컨의 기능을 해제하는 것과 같으므로, 객체를 제거할때 쓰일 수 있다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체를 지원하는 역할을 하며 보통 객체가 살아있는 동안 항상 객체와 함께 합니다. 객체와 함게 힙에서 살며 객체의 상태를 저장합니다.
 * 지역 변수:  메소드에 있는 알고리즘을 작동시키려면 메소드 안에 지역 변수를 이용해야 한다. 그 메소드가 끝나면 지역변수 또한 없어지게 된다.

*302p 5분 미스터리* _구현후 주석달기_

{{{
package ch9;



import java.util.*;

class V2Radiator {
	V2Radiator(ArrayList<SimUnit> list)	{ //Simunit 유형의 어레이 리스트를 이용합니다.
		for(int x = 0; x < 5 ; x++){ // for문을 이용해 5번 반복시킵니다.
			list.add(new SimUnit("V2Radiator")); // V2Radiator객체를 list에 추가시킵니다.
		}
	}
}


class V3Radiator { // extends V2Radiator 를 지워서 불필요하게 상속되는 것을 막습니다.
	V3Radiator(ArrayList<SimUnit> lglist){ //SimUnit 유형의 어레이 리스트를 이용합니다.
		//super(lglist); 가 없어야 합니다.
		for(int g = 0; g < 10 ; g++){ //for 문을 이용해 10번 반복합니다.
			lglist.add(new SimUnit("V3Radiator")); //V3Radiator객체를 lglist에 추가시킵니다.
		}
	}
}

class RetentionBot{
	RetentionBot(ArrayList<SimUnit> rlist){
		rlist.add(new SimUnit("Rention")); // Rention 객체를 rlist에 추가시킵니다.
	}
}

public class TestLifeSupportSim{
	public static void main(String[] args){
		ArrayList<SimUnit> aList = new ArrayList<SimUnit>(); // aList 라는 SimUnit유형의 어레이 리스트를 만듭니다.
		V2Radiator v2 = new V2Radiator(aList);// v2 라는 V2Radiator 객체를  민듭니다.
		V3Radiator v3 = new V3Radiator(aList);// v3 라는 V3Radiator 객체를  만듭니다.
		for(int z = 0 ; z < 20 ; z++){
			RetentionBot ret = new RetentionBot(aList); //ret라는 RententionBot 객체를 만듭니다.
		}
	}
}

class SimUnit {
	String botType;
	SimUnit(String type){
		botType = type;
	}
	int powerUse(){
		if("Retention".equals(botType)){
			return 2;  // botType 값이 Retention 이면 2를 반홥합니다.                     
		}else{
			return 4; // 아니라면 4를 반환합니다.
		}
	}
}



}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 클래스의 객체를 만들 필요없이 메소드를 실행할 수 있게 해줍니다.
 * 정적 메소드를 선언하는 방법: 메소드에 static을 붙입니다.
 * static final: 변수를 상수로 지정하게 해줍니다.
 * 널 레퍼런스: 널 레퍼런스는 리모컨의 기능을 해제하는 것과 같으므로, 객체를 제거할때 쓰일 수 있다.
 * 오토 박싱: 원시값과 레퍼 객체 사이의 변환을 자동으로 처리해주는 기능입니다.
 * 정적 임포트: 정적 클래스,정적변수,enum 값 등을 사용할 때 정적 임포트를 활용하면 타이핑을 더 적게 할 수 있습니다. 타이핑을 줄이기 위함임을 알 수 있습니다.

*339p Calendar* _구현후 주석달기_

{{{
package ch10;

import java.util.*;

class Calendar {
	public static void main(String args[]){
		Calendar c  =Calendar.getInstance(); 
		c.set(2004, 0, 7, 15, 40); //시작을 2004년 1월 7일 15:40으로 설정(달은 0이 1월입니다.)
		long day1 = c.getTimeInMillis(); //1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴합니다.
		day1 += 1000 * 60*  60;

		c.setTimeInMillis(day1); //한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
		System.out.println("new hour"+c.get(Calendar.HOUR_OF_DAY));
		c.add(Calendar.DATE, 35); //35일을 더합니다.
		System.out.println("add 35 days"+c.getTime());
		c.roll(Calendar.DATE, 35); //35일 뒤로 넘깁니다. 달은 바뀌지 않습니다.
		System.out.println("roll 35 days"+c.getTime());
		c.set(Calendar.DATE,1); //날짜를 더하는게 아니라, 날짜를 1로 설정합니다.
		System.out.println("set to 1"+c.getTime());
	}
}
}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 정적 변수가 상수에 불과합니다. 모든사람이 정적변수를 사용하지 않습니다. 스윙 라이브러리에 정적 변수가 있을 순 있으나 스윙은 특별한 경우이다.
 * 지역 변수: API에는 정적변수가 많습니다. 그리고 특별한 경우일 수 도 있지만 중요하기 때문에 충분히 감수할만 하다.

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
package ch10_1;

class StaticSuper{ 
	static{
		System.out.println("super static block"); //super static block 을 출력합니다.
	}
	StaticSuper(){ // StaticSuper 생성자를 만듭니다.
		System.out.println("super constructor"); // super constructor 를 출력합니다.
 	}
}

public class StaticTests extends StaticSuper { // StaticSuper가 StaticTests에게 상속합니다.
	static int rand;
	
	static{
		rand=(int)(Math.random()*6); // 0부터 5까지의 임의의 수를 만듭니다.
		System.out.println("static block"+rand); // static block + 임의의 수를 충력합니다.
	}
	StaticTests(){ //StaticTests 의 생성자를 만듭니다.
		System.out.println("constructor"); // constructor 를 출력합니다.
	}
	public static void main(String[]args){ // 메인 함수입니다.
		System.out.println("in main"); // in main 을 출력합니다.
	}
	StaticTests st=new StaticTests(); // 메인 메소드 밖으로 나와야 합니다.
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

package ch11;

public void takeRisk() throws BadException { //예외를 선언하는 과정을 통해 BadException 을 던질수 있다는 것을 외부에 알립니다.
     if (abandonAllHope){
           throw new BadEXception(); //새로운 Exception 객체를 만들고 던집니다. 
    }
}

public void crossFingers(){
     try{
               anObject.takeRisk();
     } catch (BadException ex){
        System.out.println("Aaargh!");
        ex.printStackTrace(); //예외상황을 해결할 수 없다면 적어도 모든 예외 객체에서 물려받는 printStackTrace()메소드를 써서 스택 트레이스를 출력하는 정도는 해줘야 합니다.
     }
}

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{
package ch11_1;

import javax.sound.midi.*; // 미디 패키지를 불러옵니다.

public class MiniMiniMusicApp {

	public static void main(String [] args){
		MiniMiniMusicApp mini = new MiniMiniMusicApp(); //mini라는 MiniMiniMusicApp 객체를 만듭니다.
		mini.play(); // play라는 메소드를 실행시킵니다.
	} // main 메소드 끝
	public void play(){
		try{
			Sequencer player = MidiSystem.getSequencer(); //Sequencer를 받아서 엽니다.
			player.open();

			Sequence seq = new Sequence(Sequence.PPQ, 4); //Sequencer 생성자로 넘기는 인자에 대해서는 신경 쓰지 않아도 됩니다.
			Track track = seq.createTrack(); // Sequence에 Track을 요청합니다.

			// 인스턴트 코드입니다.
			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,44,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);

			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,44,100);
			MidiEvent noteOff = new MidiEvent(b,16);
			track.add(noteOff);

		
			player.setSequence(seq); //Sequencer에 Sequence를 보냅니다.

			player.start(); // Sequencer의 start()메소드를 호출합니다.

		} catch (Exception ex){
			ex.printStackTrace();
		}

	} // play 메소드 끝
} // 클래스 끝

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{
package ch11_2;

import javax.sound.midi.*; //미디 패키지를 불러옵니다.

public class MiniMusicCmdLine { // 첫번째

	public static void main(String[]args){
		MiniMusicCmdLine mini = new MiniMusicCmdLine(); //mini라는 MiniMusicCmdLine 객체를 만듭니다.
		if(args.length<2){ // 인자의 개수가 2보다 작다면 아래의 코드를 실행합니다.
			System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요."); //악기와 음 높이를 지정하는 인자를 입력하세요. 를 출력합니다.
		}else{
			int instrument = Integer.parseInt(args[0]); //args[0] 의 값인 String 값을 int로 바꿉니다. 그리고 instrument 저장합니다.
			int note = Integer.parseInt(args[1]); //args[1] 의 값인 String 값을 int로 바꿉니다. 그리고 note에 저장합니다.
			mini.play(instrument, note); //play 메소드를 실행합니다.
		}
	} // main 끝


	public void play (int instrument, int note){
		try{
			Sequencer player = MidiSystem.getSequencer();//Sequencer를 받아서 엽니다.
			player.open(); // open 메소드를 실행합니다.
			Sequence seq = new Sequence(Sequence.PPQ, 4); // Sequencer 생성자로 넘기는 인자에 대해서는 신경 쓰지 않아도 됩니다.
			Track track = seq.createTrack(); //Sequence에 Track을 요청합니다.

			MidiEvent event = null; event 를 null로 설정합니다.

			//인스턴스 코드입니다.
			ShortMessage first = new ShortMessage(); 
			first.setMessage(192,1,instrument,0);
			MidiEvent changeInstrument = new MidiEvent(first, 1);
			track.add(changeInstrument);

			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,note,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);

			ShortMessage b = new ShortMessage();
			a.setMessage(128,1,note,100);
			MidiEvent noteOff = new MidiEvent(b,16);
			
			
			track.add(noteOff); //track 에 noteOff를 추가시킵니다.
			player.setSequence(seq); //setSequence 메소드를 실행시킵니다.
			player.start(); //start 메소드를 실행시킵니다.
		}catch(Exception ex){ex.printStackTrace();}
	} // play 메소드 끝
} // 클래스 끝

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
package ch12;

import javax.swing.*;

public class SimpleGui1{
	public static void main(String [] args) {
		JFrame frame = new JFrame(); // JFrame을 만듭니다.
		JButton button = new JButton("click me");  // JButton을 생성합니다. 버튼위가 clock me 로 나타납니다.

		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 이렇게 하면 창을 닫았을 때 프로그램이 바로 종료됩니다.

		frame.getContentPane().add(button); // 버튼을 프레임의 내용 틀에 추가합니다.

		frame.setSize(300,300); //프레임의 크기를 픽셀 단위로 지정합니다.

		frame.setVisible(true); // 화면에 표시되도록 설정합니다.
	}
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
package ch12_1;

import javax.swing.*;
import java.awt.event.*; //   ActionListener와 ActionEvent가 들어있는 패키지를 사용하기 위한 import 선언문

public class SimpleGui1B implements ActionListener { //인터페이스를 구현합니다. 이 구문은 SimpleGui1B의 객체는 ActionListener 임을 나타냅니다.
	JButton button; // JButton을 만듭니다. 

	public static void main(String []args){
		SimpleGui1B gui=new SimpleGui1B(); //gui 라는 SimpleGui1B의 객체를 만듭니다.
		gui.go(); //go 메소드를 실행합니다.

	}

	public void go(){
		JFrame frame= new JFrame(); // JFrame를 만듭니다.
		button=new JButton("click me"); // JButton을 만드는데 그 버튼이 click me 를 나타냅니다.

		button.addActionListener(this); // button에 등록합니다.

		frame.getContentPane().add(button); //프레임에 button 을 추가시킵니다.
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 이렇게 하면 창을 닫았을 때 프로그램이 바로 종료됩니다.
		frame.setSize(300,300);// 프레임의 크기를 픽셀 단위로 지정합니다.
		frame.setVisible(true); // 화면에 표시되도록 합니다.
	}
	public void actionPerformed(ActionEvent event){ // 실제 이벤트를 처리하는 메소드입니다.
		button.setText("I've been clicked!");
		
	}
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}