#summary 임태휘의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class beersong{
	public static void main (String[] args) {
		int beerNum = 99;
		String word = "bottles";     //more than one

		while (beerNum > 0) {
			
			if(beerNum == 1) {
				word = "bottle";     //for one bottle
			}

			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum - 1;

			if(beerNum > 0)
			{
				if(beerNum == 1)
					word = "bottle";     //for one bottle					
				System.out.println(beerNum + " " + word + " of beer on the wall");
			}
			else
			{
				System.out.println("No more bottles of beer on the wall");
			}//else end
		}//while end
	}//main end
}//class end
			

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
    public static void main (String[] args) {
        String[] wordListOne = {"I", "He", "They", "She", "You"};     //주어로 String 배열 선언
        String[] wordListTwo = {"is", "are", "am", "were", "was"};     //동사로 String 배열 선언
        String[] wordListThree = {"fair", "great", "beautiful", "dog", "pig"};     //보어로 String 배열 선언

        int oneLength = wordListOne.length;
        int twoLength = wordListTwo.length;
        int threeLength = wordListThree.length;

        int rand1 = (int)(Math.random()*oneLength);
        int rand2 = (int)(Math.random()*twoLength);
        int rand3 = (int)(Math.random()*threeLength);

        String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

        System.out.println("What we need is a " + phrase);
    }
}



}}}

*52p 집중토론* _요약_

{{{

 *     자바 가상 머신: 1. 프로그램을 실행한다. 2. 바이트 코드가 만들어진 다음 바이트코드가 실행되기 전까지 외부에서의 접근을 확인하는 작업 수행한다. 

 *   컴파일러: 1. 자바 언어를 해석한다. 2. 동적 바인딩을 지원한다. 3. 실행 시 오류를 막아준다. 4. 클래스 및 메소드의 보안을 담당한다. 

}}}

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

public class Exercise1b {
	public static void main (String[] args) {
		int x;
		while(x<10)
		{
	 		if(x>3)
				System.out.println("big x");
			x++;     //x를 증가시켜서 루한루프를 방지
		}
	}
}

}}}
{{{

B

public class Exercise1b {     /*클래스 선언이 필요하다*/ 
	public static void main (String[] args) {
		int x = 5;
		while(x>1)
		{
			x = x-1;
			if(x<3)
			{
				System.out.println("small x");
			}	
		}
	}
}

}}}

{{{			

C

public class Exercise1b {
	public static void main (String[] args) {     /*메인 메소드 선언이 필요하다.*/
		int x = 5;
		while(x>1)
		{
			x = x-1;
			if(x<3)
			{
				System.out.println("small x");
			}	
		}
	}
}
			
}}}

= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

{{{

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것에 해당
 * 메소드: 객체에서 할 수 있는 일에 해당 
 * 클래스: 가상머신에 그 유형의 객체에 대해 알려주는 역할과 만들어주는 역할을 한다.
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트하는 역할을 한다, main() 메소드를 포함하며 main() 메소드에서 테스트 할 클래스 유형의 객체를 만들어서 접근하도록 해준다. 

}}}

 

*68p Television* _채워넣기_

{{{

 * 인스턴스 변수: 크기, 제조사, 제조연도, 전력소비량   
 * 메소드: 전원(), 음량조절(), 화면설정()

}}}

*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

GuessGame.java

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();

		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;

		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;

		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0이상 9 이하의 숫자를 맞춰보세요.");

		while(true) {
			System.out.println("맞춰야 할 숫자는" + targetNumber +"입니다.");

			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();

			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자 : " + guessp1);
		
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자 : " + guessp2);

			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자 : " + guessp3);

			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자 : " + guessp4);


			if(guessp1 == targetNumber) {
				p1isRight = true;
			}

			if(guessp2 == targetNumber) {
				p2isRight = true;
			}

			if(guessp3 == targetNumber) {
				p3isRight = true;
			}

			if(guessp4 == targetNumber) {
				p4isRight = true;
			}


			if(p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수 : " + p1isRight);
				System.out.println("2번 선수 : " + p2isRight);
				System.out.println("3번 선수 : " + p3isRight);
				System.out.println("4번 선수 : " + p4isRight);				
				System.out.println("게임 끝.");
				break;  //게임이 끝났으므로 순환문을 빠져 나오는 break문
			} else {
				//아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			}  //if/else문 종료
		}  //while문 종료
	}  //메소드 종료료
}  //클래스 종

}}}

{{{

Player.java

public class Player {
	int number = 0; //찍은 숫자를 저장할 변수

	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자 : " + number);
	}
}

}}}

{{{

GameLauncher.java

public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
public class TapeDeck{
        boolean canRecord = false;
        
        void playTape(){
                System.out.println("tape playing");
        }
        
        void recordTape(){
                System.out.println("tape recording");
        }
}

public class TapeDeckTestDrive {
        public static void main(String[] args) {
                TapeDeck t = new TapeDeck(); //새로운 객체를 지정이 생략됨.
                
                t.canRecord = true;
                t.playTape();
                
                if (t.canRecord == true){
                        t.recordTape();
                }
        }
}
}}}

{{{
B
public class DVDPlayer {
        boolean canRecord = false;
        
        void recordDVD(){
                System.out.println("DVD recording");
        }
        
        void playDVD(){
                System.out.println("DVD playing");
        } // playDVD에 대한 메소드 삽입
}

public class DVDPlayerTestDrive {
        public static void main(String[] args) {
                
                DVDPlayer d = new DVDPlayer();
                d.canRecord = true;
                d.playDVD();
                
                if(d.canRecord == true){
                        d.recordDVD();
                }
        }
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

* 원시변수 vs 레퍼런스변수: 
{{{
 * 원시변수 : 원시변수는 커피전문점에서 사용하는 컵과 같은 개념, 해당 변수의 크기를 나타내는 비트들이 저장된다.
             변수에는 해당하는 크기보다 큰 값을 넣을 수 없다. 
             자바에서 사용하는 원시변수의 유형에는 boolean, char, byte, short, int, long, float, double이 있다.
 
 * 레퍼런스변수 : 객체 레퍼런스변수라고하며, 객체에 접근하는 방법을 알려주는 비트가 들어있다. 
                객체 자체가 저장되는 것이 아니라 접근을 가능하도록 해주는 리모컨 과 같은 역할을 하는 변수라고 보면 된다.
}}}
 
{{{ 
 * 변수 선언
 
 * 원시변수 : 원시변수유형 뒤에 변수명을 선언해주면 된다.

 ex) int x;
    float y;
    double z;

 * 레퍼런스변수 : 객체 선언, 생성, 대입의 3단계로 선언이 이루어진다.

ex) 
1)레퍼런스변수 선언 => Student MyS;(레퍼런스변수용 공간 할당을 요청, 변수명은 MyS)
  여기서 MyS라는 레퍼런스변수는 Student 객체를 제어하기 위한 리모컨 역할을 함.

2)객체 생성 => new Student();(힙에 새로운 객체 Student를 위한 공간 마련)

3)객체와 레퍼런스의 연결 => '='의 기능, 새로운 Student 객체를 MyS라는 레퍼런스 변수에 대입

Student MyS = new Student(); => 한 줄로 표현 가능하다. 
}}}
               

 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog { 
	String name;   //Dog에 대해 아는 것에 해당(인스턴트 변수)
	
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat();
	public void chaseCat();   //Dog가 하는 것에 해당(메소드)
	//책과는 달리 편의상 인스턴트 변수와 메소드를 모아놓았다.

	public static void main(String[] args) {
		// Dog 객체를 만들고 접근
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";

		//Dog 배열을 만듬.
		Dog[] myDogs = new Dog[3];
		//개를 3마리 집어넣기
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;

		//배열 레퍼런스로 Dog 객체에 접근하기
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";

		//myDogs[2]의 이름 출력해보기
		System.out.print("마지막 개의 이름 : ");
		System.out.println(myDogs[2].name);

		//순환문을 사용하여 모든 개들이 짖도록 하기
		int x = 0;
		while(x < myDogs.length) {
			myDogs[x].bark();
			x = x + 1;
		}   //while 순환문 종료
	}   //메인 메소드 종료
}   //클래스 Dog 종료   
}}}
{{{
* 알게 된 사항 *
클래스 안의 인스턴트변수와 메소드의 위치는 메인 함수의 위치에 전혀 영향을 받지 않는다.
메인함수보다 아래쪽에 위치하여도 메인함수에서 호출 및 사용에 문제가 없다.

* 참고사항 *
클래스 내에 메소드에서는 클래스가 아는 것과 하는 것에 해당하는 인스턴트 변수와 메소드를 그대로 사용할 수 있으며, 인스턴트 변수와 메소드의 
변경이 필요하다면 해당 메소드 내에 같은 변수명으로 인스턴트변수나 메소드를 선언해주면 해당 메소드 내에서만 변경 및 사용이 가능하다.  
 
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class Books {
	String title;
	String author;
}

class BooksTestDrive {
	public static void main(String[] args) {
		
		Books[] myBooks = new Books[3];
		int x = 0;

	// 추가해야할 부분	
		myBooks[0] = new Books;
		myBooks[1] = new Books;
		myBooks[2] = new Books;	  // 배열 선언 이후에 각각의 myBooks의 객체를 만들어야한다.
	// 추가해야할 부분

		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";

		while(x < 3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}   // while 순환문 종료
	}   // 메인 메소드 종료
}   // 클래스 BooksTestDrive종료
}}}
{{{

B

public class Hobbits {
	String name;
	
	public static void main(String[] args) {
		
		Hobbits[] h = new Hobbits[3];
		int z = 0;
		
		while(z < 3 /* =바뀐 부분= 0~2번까지 순환해야 하므로 */ ) {
			
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			
			if(z == 1) {
				h[z].name = "frodo";
			}
			
			if(z == 2) {
				h[z].name = "sam";
			}
			
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobbit name");
			
			z = z + 1; //=바뀐 부분= 처음부터 z를 증가시키면 안되므로 위치 변경
		}   //while문 종료
	}   //메인 메소드 종료
}   //클래스 Hobbits종료

}}}

*101p 레퍼런스 도용사건* _요약_

{{{

 * 누가 이겼나요? : 밥이 이겼다.

 * 문제가 된 부분은 어딘가요? : 켄트는 메모리를 절약하기 위해 동일한 변수명을 사용하여 연락처 객체를 10개를 만들었지만
                                만들어진 객체 중 마지막 객체를 제외한 나머지에는 접근할 수 없다는 문제가 생겼기 때문이다.

}}}

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_


 * 캡슐화: 

  #. 데이터와 자신이 구현한 코드를 나중에 수정할 권한을 보호할 수 있도록 구현하는 방법
  #. 인스턴트 변수 앞에는 private, '*_게터_*'와 '*_세터_*' 앞에는 public을 써준다.

 * 게터와 세터:
 
  #. '_*게터*_' : 인스턴트 변수의 값을 알아내기 위한 메소드
             일반적으로 인스턴트 변수의 값을 리턴함.
         ex) getNum(), getBrand() 
  #. '_*세터*_' : 인스턴트 변수의 값을 설정하기 위한 메소드
             전달된 값을 확인하고 인스턴트 변수의 값을 설정해줌.
         ex) setNum(), setBrand()

 * 인스턴스 변수 vs 지역 변수 :

  #. 인스턴트 변수는 클래스 내에서 선언되고, 선언 시 초기화 값을 지정해주지 않아도 항상 기본값이 들어간다. 
  #. 지역 변수는 메소드 내에서 선언되고, 선언 시 초기화 값을 지정해주어야한다. 

*107p Dog* _실행_

{{{

클래스 Dog

public class Dog {
	int size;
	String name;
	
	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if(size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		} //if-else문 종료
	}  //메소드 bark종료
}  //클래스 Dog종료

}}}

{{{

클래스 DogTestDrive

public class DogTestDrive {
	
	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();
	}  //메인 메소드 종료

}  //클래스 DogTestDrive 종료

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A 


class XCopy {
	public static void main(String[] args) {
		
		int orig = 42;
		
		XCopy x = new XCopy();
		
		int y = x.go(orig);
		
		System.out.println(orig + " " + y);
	}  // 메인 메소드 종료
	
	int go(int arg) {
		
		arg = arg * 2;
		
		return arg;
	}  //메소드 go 종료
}  //클래스 XCopy 종료
}}}
{{{
* A의 연산 결과
  
    42 84 

* 자바는 call by value 만을 지원하기 때문에 orig의 초기 값은 go라는 함수에서 호출되어 사용되지만 함수 go 내에서의
 연산과정은 main 메소드 내의 orig에 영향을 주지 못한다. 
}}}
{{{

B

클래스 Clock


class Clock {
	String time;
	
	void setTime(String t) {
		time = t;
	}
	
	String getTime() {   /*리턴형을 String으로 수정 */ 
		return time;
	}
}

클래스 ClockTestDrive


class ClockTestDrive {
	public static void main(String[] args) {
		
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time : " + tod);
	}

}

}}}

{{{
* 주의할 점 *

 메소드의 리턴형에 유의해서 메소드 앞 부분을 지정해주어야한다. 

}}}

= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 프로그래머들이 원하는 방법. 

 장점 : 마지막에 스펙이 변경되더라도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공이 가능

  #. 조금씩, 하지만 자주 발표한다.
  #. 사이클을 반복해서 돌리면서 개발한다. 
  #. 스펙에 없는 내용은 절대 집어넣지 않는다.(요구기능이외의 부가기능은 필요X) 
  #. 테스트 코드를 먼저 만든다.
  #. 야근은 하지 마라. 항상 정규 일과 시간에만 작업한다.
  #. 기회가 생기는 족족 어디서든 코드를 개선한다.
  #. 모든 테스트를 통과하기 전에는 어떠한 것도 발표하지 않는다.
  #. 조금씩 발표하는 것을 기반으로 현실적인 작업 계획을 만든다.
  #. 모든 일을 단순하게 처리한다.
  #. 두 명씩 팀을 편성하고, 모든 사람이 코드를 알 수 있도록 돌아가면서 작업한다.

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
클래스 SimpleDotComTestDrive

public class SimpleDotComTestDrive {
	
	public static void main (String args[]) {
		
		int numOfGuesses = 0; //닷컴 지우기까지 몇 번을 입력하였는 지 검사해주는 integer 
		GameHelper helper = new GameHelper();  
		
		SimpleDotCom theDotCom = new SimpleDotCom(); 
		int randomNum = (int) (Math.random()*5); //Math.random에 의해 0이상 1미만의 수 생성
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations); //locations배열을 객체 theDotCom의 locationCells배열로 대입
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number"); //guess에 User의 input을 대입
			String result = theDotCom.checkYourself(guess); //guess로 객체 닷컴의 checkYourself 메소드를 이용해서 검사
			numOfGuesses++;
			
			if(result.equals("kill")) {
				isAlive = false; //모든 닷컴 수를 찾을 경우 isAlive을 이용하여 반복문을 나온다.
				System.out.println(numOfGuesses + "guesses");
			}// if문 끝
		}// while문 끝
	}// main문 
}


}}}

{{{
클래스 SimpleDotCom

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0; //닷컴에 해당하는 지역을 모두 눌러주었는지 검사하기 위한 장치
	
	public void setLocationCells (int[] locs) {
		
		locationCells = locs;
	}

	public String checkYourself (String stringGuess) {
		
		int guess = Integer.parseInt(stringGuess); //User에게 입력받은 Character형 -> int형
		String result = "miss";
		for(int i = 0 ;i < locationCells.length ; i++) {
			if(guess == locationCells[i]) {
				result = "hit";  // for문을 돌려서 User의 input의 해당하는 수가 있는지 검사
				numOfHits++;
				break;
				
			}
		}// 순환문 끝
		
		if(numOfHits == locationCells.length) { //닷컴을 모두 누를 시 kill을 return하며 종료
			result = "kill";
		}
		System.out.println(result); //맞으면 hit, 틀리면 miss를 return 출력
		return result; //result를 메인 메소드의 result에 대입해주는 역할
	}// 메소드 끝
	
}// 클래스  끝

}}}

{{{
클래스 GameHelper

import java.io.*;
public class GameHelper { //키보드로 입력을 받기 위한 선언들이 담고있는 클래스
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + " "); //User가 입력한 input을 화면으로 바로 띄워줌.
		
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) 
				return null;
		} catch (IOException e) {
			System.out.println("IOException: "+ e);
		}
		
		return inputLine; //User's input을 main메소드의 guess에 대입해주는 역할
	}
	
}
}}}
{{{
 * 알게 된 점 *

BufferedReader is = new BufferedReader(new InputStreamReader(System.in));

1. System.in => 키보드로부터 입력을 받은 것
2. 그것을 InputStreamReader로 읽는다.
3. 2번에서 읽은 것으로 BufferedReader형 객체인 is를 만든다.


}}}
= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

{{{
 * 각 닷컴 게임의 클래스 오른쪽 번호가 몇 번째 수정본인지를 의미함.
 * 5장 연습문제의 코드를 그대로 썼으나 추가 혹은 수정된 사항을 표시하기위해 기존의 주석은 모두 지움.
}}}

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

 * boolean형 배열을 추가적으로 이용한 구성

{{{
클래스 SimpleDotComTestDrive1

public class SimpleDotComTestDrive1 {
	
	public static void main (String args[]) {
		
		int numOfGuesses = 0; 
		GameHelper helper = new GameHelper();  
		
		SimpleDotCom theDotCom = new SimpleDotCom(); 
		int randomNum = (int) (Math.random()*5); 
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations); 

		boolean[] checks = {false, false, false}; // boolean형 배열의 값을 모두 false로 초기화
		theDotCom.setcheckCells(checks); // 새로운 배열을 만들어 준다.	

		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number"); 
			String result = theDotCom.checkYourself(guess); 
			numOfGuesses++;
			
			if(result.equals("kill")) {
				isAlive = false; 
				System.out.println(numOfGuesses + "guesses");
			}
		}
	} 
}
}}}
{{{
클래스 SimpleDotCom1

public class SimpleDotCom1 {
	
	int[] locationCells;
	int numOfHits = 0; 

	boolean[] checkCells; // 눌린 닷컴의 위치를 체크하기 위한 boolean형의 배열 선언
	
	public void setLocationCells (int[] locs) {
		
		locationCells = locs;
	}

	public void setcheckCells (int[] checks) { /*set해주는 함수 또한 하나 추가한다.*/
		
		checkCells = checks;
	}

	public String checkYourself (String stringGuess) {
		
		int guess = Integer.parseInt(stringGuess); 
		String result = "miss";

		for(int i = 0 ;i < locationCells.length ; i++) {
			if(guess == locationCells[i]) {

				if(checkCells[i] == true)  // 이미 true인 경우는 break을 통해 빠져나오게 해준다.
					break;

				result = "hit";  
				numOfHits++;

				checkCells[i] = true; // 누른 번호가 맞았다면 checkCells[i]를 true로 바꿔준다.

				break;
				
			}
		}
		
		if(numOfHits == locationCells.length) { 
			result = "kill";
		}
		System.out.println(result); 
		return result; 
	}	
}
}}}

{{{
클래스 GameHelper1

import java.io.*;
public class GameHelper1 { 
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + " "); 
		
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) 
				return null;
		} catch (IOException e) {
			System.out.println("IOException: "+ e);
		}
		
		return inputLine; 
	}
	
}
}}}
*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

 * locationCells배열 자체의 성분을 음수로 바꿔주는 구성 

{{{
클래스 SimpleDotComTestDrive2

public class SimpleDotComTestDrive2 {
	
	public static void main (String args[]) {
		
		int numOfGuesses = 0;  
		GameHelper helper = new GameHelper();  
		
		SimpleDotCom theDotCom = new SimpleDotCom(); 
		int randomNum = (int) (Math.random()*5); 
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations); 
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number"); 
			String result = theDotCom.checkYourself(guess); 
			numOfGuesses++;
			
			if(result.equals("kill")) {
				isAlive = false; 
				System.out.println(numOfGuesses + "guesses");
			}
		}
	} 
}
}}}

{{{
클래스 SimpleDotCom2

public class SimpleDotCom2 {
	
	int[] locationCells;
	int numOfHits = 0; 
	
	public void setLocationCells (int[] locs) {
		
		locationCells = locs;
	}

	public String checkYourself (String stringGuess) {
		
		int guess = Integer.parseInt(stringGuess); 
		String result = "miss";

		for(int i = 0 ;i < locationCells.length ; i++) {
			if(guess == locationCells[i]) {
				result = "hit";  
				
				locationCells[i] = -1; // locationCells[i]의 값을 음수로 넣어주면서 맞춘 칸을 표시겸 재검사 방지
    						       
				numOfHits++;
				break;
		
			}
		}
		
		if(numOfHits == locationCells.length) { 
			result = "kill";
		}
		System.out.println(result); 
		return result; 
	}
}
}}}

{{{
클래스 GameHelper2

import java.io.*;
public class GameHelper2 { 
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + " "); 
		
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) 
				return null;
		} catch (IOException e) {
			System.out.println("IOException: "+ e);
		}
		
		return inputLine; 
	}
	
}
}}}
*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

 * 자바내의 util중 ArrayList를 이용한 구성

{{{
클래스 SimpleDotComTestDrive3

import java.util.ArrayList; // 자바 내의 util중 ArratList를 사용하도록 선언

public class SimpleDotComTestDrive3 {
	
	public static void main (String args[]) {
		
		int numOfGuesses = 0;  
		GameHelper helper = new GameHelper();  
		
		SimpleDotCom theDotCom = new SimpleDotCom(); 
		int randomNum = (int) (Math.random()*5); 
		
		ArrayList<String> locations = new ArrayList(); // ArrayList로 기존의 배열을 바꿔준다.
		location.add(String.valueOf(randomNum)); // add하게되면 ArrayList의 공간 하나가 추가되면서 값이 들어간다.
		location.add(String.valueOf(randomNum+1));
		location.add(String.valueOf(randomNum+2));					

		theDotCom.setLocationCells(locations); 
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number"); 
			String result = theDotCom.checkYourself(guess); 
			numOfGuesses++;
			
			if(result.equals("kill")) {
				isAlive = false; 
				System.out.println(numOfGuesses + "guesses");
			}
		}
	} 
}
}}}

{{{
클래스 SimpleDotCom3

import java.util.ArrayList;

public class SimpleDotCom3 {
		private ArrayList<String> locationCells; // locationCells에 대한 정보를 숨기기 위해 private로 선언함.
		
	public void setLocationCells (ArrayList<String> locs) {
		
		locationCells = locs;
	}

	public String checkYourself (String stringGuess) {
		
		int index = locationCells.indexof(stringGuess); // indexOf(Object)하게되면 Object가 들어있는 index의 수를 return 해준다.
		String result = "miss";
	
		if(index >= 0)
		{
			locationCells.remove(index);
			if(locationCells.isEmpty())
				result = "kill";
			else
				result = "hit";
		}

		System.out.println(result); 
		return result; 
	}
}
}}}

{{{
클래스 GameHelper3

import java.io.*;
public class GameHelper3 { 
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + " "); 
		
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) 
				return null;
		} catch (IOException e) {
			System.out.println("IOException: "+ e);
		}
		
		return inputLine; 
	}
	
}
}}}
*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
import java.io.*;
import java.util.*;

public class GameHelper {
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int[] grid = new int[gridSize];
        private int comCount = 0;
        
        public String getUserInput(String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length()==0)
                                return null;
                }catch(IOException e){
                        System.out.println("OException: " + e);
                }
                
                return inputLine.toLowerCase();
        }
        
        public ArrayList<String> placeDotCom(int comSize){
                ArrayList<String> alphaCells = new ArrayList<String>(); // 'f6'과 같은 좌표가 들어감
                String temp = null; // 나중에 연결하기 위한 임시 String 배열
                int[] coords = new int[comSize]; // 현재 후보 좌표
                int attempts = 0; // 시도 횟수를 세기 위한 카운터
                boolean success = false; // 적당한 위치를 찾았는지 표시하기 위한 플래그
                int location = 0; // 현재 시작 위치
                
                comCount++; // n번째 닷컴
                int incr = 1; // 수평 방향으로 증가시킬 값 설정
                if((comCount%2)==1){ // 홀수 번째 닷컴인 경우(수직으로 배치)
                        incr = gridLength; // 수직 방향으로 증가시킬 값 설정
                }
                
                while(!success & attempts<200){ // 주 검색 순환문(32)
                        location = (int)(Math.random()*gridSize); // 임의 시작 위치를 구함
                        int x = 0; // 위치시킬 닷컴의 n번째 위치
                        success = true; // 성공할 것으로 가정함
                        while(success && x<comSize){ // 닷컴이 들어갈 자리가 비었는지 확인
                                if(grid[location]==0){
                                        coords[x++] = location; // 위치 저장
                                        location += incr; // 다음 칸 확인
                                        if(location>=gridSize){ // 경계를 벗어난 경우
                                                success = false; // 실패
                                        }
                                        if(x>0 & (location % gridLength==0)){ // 경계를 벗어난 경우(오른쪽)
                                                success = false; // 실패
                                        }
                                }else{ // 이미 사용 중인 경우
                                        success = false; // 실패
                                }
                        }
                } // while문 끝
                
                int x = 0; // 위치를 알파벳 좌표로 바꿈
                int row = 0;
                int column = 0;
                
                while(x<comSize){
                        grid[coords[x]] = 1; // 기본 그리드 좌표를 '사용 중'으로 표시
                        row = (int)(coords[x]/gridLength); // 행 값을 구함
                        column = coords[x]%gridLength; // 열 값을 구함
                        temp = String.valueOf(alphabet.charAt(column)); // 숫자된 열을 알파벳으로 구함
                        
                        alphaCells.add(temp.concat(Integer.toString(row)));
                        x++;
                }
                
                return alphaCells;
        }
}
}}}

{{{
import java.util.*;

public class DotComBust { // 사용 변수 초기화
        private GameHelper helper = new GameHelper();
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>(); // DotCom객체로 이루어진 ArrayList 만들기
        private int numOfGuesses = 0;
        
        private void setUpGame(){ // 닷컴 객체 몇 개를 만들고 위치 지정
                DotCom one = new DotCom();
                one.setName("Pets.com");
                DotCom two = new DotCom();
                two.setName("eToys.com");
                DotCom three = new DotCom();
                three.setName("Go2.com");
                dotComsList.add(one);
                dotComsList.add(two);
                dotComsList.add(three);

                System.out.println("Your goal is to sink three dot coms.");
                System.out.println("Pets.com, eToys.com, Go2.com");
                System.out.println("Try to sink them all in the fewest number of guesses"); // 게임 방법 설명
                
                for (DotCom dotComToSet : dotComsList){ // 닷컴 반복
                        ArrayList<String> newLocation = helper.placeDotCom(3); // 보조 메소드 호출
                        dotComToSet.setLocationCells(newLocation); 
                } // for문 끝
        } // setUpGame 메소드 끝
        
        private void startPlaying(){
                while(!dotComsList.isEmpty()){
                        String userGuess = helper.getUserInput("Enter a guess");
                        checkUserGuess(userGuess);
                } // while문 끝
                
                finishGame();
        } // setUpGame 메소드 끝
        
        private void checkUserGuess(String userGuess){
                numOfGuesses++; // 사용자 추측 횟수 증가
                String result = "miss";
                
                for(DotCom dotComToTest : dotComsList){ // 모든 닷컴 객체에 대해 반복
                        result = dotComToTest.checkYourself(userGuess); 
                        if(result.equals("hit"))
                                break;
                        if(result.equals("kill")){
                                dotComsList.remove(dotComToTest);
                                break;
                        }
                } // for문 끝
                
                System.out.println(result);
        } // 메소드 끝
        
        private void finishGame(){
                System.out.println("All Dot Coms are dead! Your stock is now worthless");
                if(numOfGuesses<=18){
                        System.out.println("It only took you " + numOfGuesses + " guesses.");
                        System.out.println("You got out before your options sank");
                }else{
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
                        System.out.println("Fish are dancing with your options");
                }
        }
        
        public static void main (String[] args){
                DotComBust game = new DotComBust(); // 게임 객체 만들기
                game.setUpGame();
                game.startPlaying();
        } // 메소드 끝
}
}}}

{{{
import java.util.*;

public class DotCom {
        private ArrayList<String> locationCells;
        private String name;
        
        public void setLocationCells(ArrayList loc){ // 닷컴 위치 갱신 세터 메소드
                locationCells = loc;
        }
        
        public void setName(String n){ // 세터 메소드
                name = n;
        }
        
        public String checkYourself(String userInput){
                String status = "miss";
                int index = locationCells.indexOf(userInput);
                
                if(index>=0){
                        locationCells.remove(index); 
                        if(locationCells.isEmpty()){ // 모든 위치를 맞췄는지 확인
                                status = "kill";
                                System.out.println("Ouch! You sunk " + name + "   :  ("); // 닷컴이 가라앉을 때
                        }else{
                                status = "hit";
                        }
                } // if문
                
                return status;
        } // 메소드 끝
} // 클래스 끝
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

{{{
 * 상속: 공통적인 코드를 어떤 클래스에 넣은 다음, 더 구체적인 클래스에 공통적인 코드를 포함한 클래스가 상위클래스라는 것을 알려주는 것. 
         extends를 통해 연결한다.

 * 다형성: 상위클래스로 선언된 레퍼런스를 이용하여 하위클래스 객체를 참조하는 것. 
   => 이 경우, 하위 클래스내의 메소드는 사용할 수 없다.  
 
}}}

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Animal {
        String picture;
        boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise(){
        }
        
        void eat(boolean food){
        }
        
        void sleep(){
        }
        
        void roam(){
        }
}

class Feline extends Animal{
        void roam(){
        }
}

class Lion extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Tiger extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Cat extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Hippo extends Animal{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

class Canine extends Animal{
        void roam(){
        }
}

class Wolf extends Canine{
        void makeNoise(){
        }

        void eat(boolean food){
        }
}

class Dog extends Canine{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드 : 상위 클래스의 메소드를 하위 클래스에서 재정의하여 사용하는 것(ex)같은 메소드라도 예외적인 특징이 있는 경우). 
 * 오버로딩 : 이름이 같고 parameter 종류가 다른 메소드 두 개를 만드는것. 두 개는 다른 메소드로 인식된다.  

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
// 답은 1번.
public class MonsterTestDrive {
        public static void main(String[] args) {
                
                Monster [] ma = new Monster[3];
                ma[0] = new Vampire();
                ma[1] = new Dragon();
                ma[2] = new Monster();

                for(int x=0; x<3; x++){
                        ma[x].frighten(x);
                }

        }
}
}}}

{{{
class Monster{
        boolean frighten(int d){
                System.out.println("arrrgh");
                return true;
        }
} // "arrrgh"라는 문자열을 출력하고, frighten 메소드를 오버라이드함. 

class Vampire extends Monster{
        boolean frighten(int x){
                System.out.println("a bite?");
                return false;
        }
} // "a bite?"라는 문자열을 출력하고, frighten 메소드를 오버라이드함.
}}}

{{{
class Dragon extends Monster{
        boolean frighten(int degree){
                System.out.println("breath fire");
                return true;
        }
}
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스 : 인스턴스를 만들 수 없는 추상클래스로 서로 다른 클래스 간 공통부분을 정의할 때 사용한다. 인터페이스를 상속받은 클래스에서 내부적으로 메소드를 구현하는것이 가능하다.

 * 다형성 :

 * 추상 클래스 :

 * 추상 메소드 :

 * 다중 상속 : 여러 상위 클래스에서 상속받음을 의미하는 용어

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}