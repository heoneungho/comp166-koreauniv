#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_
{{{
public class BeerSong { public static void main (String args) { int beerNum = 99; String word = "bottles"; //복수형

while (beerNum > 0) {

if (beerNum == 1) { word = "bottle"; //단수형 (한 병인 경우) }

System.out.println(beerNum + " " + word + " of beer on the wall"); System.out.println(beerNum + " " + word + " of beer."); System.out.println("Take one down."); System.out.println("Pass it around."); beerNum = beerNum - 1;

if(beerNum > 0) { System.out.println(beerNum + " " + word + " of beer on the wall"); } else { System.out.println("No more bottles of beer on the wall"); } //else 문 끝 } //while 순환문 끝 } //main 클래스 끝 } //클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_
{{{
public class PhraseOMatic {
public static void main (String[] args) {

// 세 종류의 단어 목록을 만든다. 
String [] wordListOne = {"4/21","young-tigers","20,000 people"};
String [] wordListTwo = {"strong","focus-on","sharing"};
String [] wordListThree = {"tip-toe","firefighter","cold-war"};

//각 단어 목록에 단어가 몇 개씩 들어있는지 확인한다.
int oneLength = wordListOne.length;
int twoLength = wordListTwo.length;
int threeLength = wordListThree.length;

//난수 세개 발생시킨다
int rand1 = (int) (Math.random()*oneLength);
int rand2 = (int) (Math.random()*twoLength);
int rand3 = (int) (Math.random()*threeLength);

//구문 만들기
String phrase = wordListOne[rand1] + " " +
wordListTwo[rand2] + " " + wordListThree[rand3];

//구문을 출력한다
System.out.println("What we need is a " + phrase);
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 컴파일러가 파일을 주면 자바 가상머신이 그 프로그램을 실행시켜준다.
 * 컴파일러: 자바에서 바이트코드 컴파일러를 사용하여 파일을 자바 가상머신에게 준다. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_
{{{
A. 
class Exercise1b {
public static void main(String [] args) {
int x = 1;
while (x<10){
x=x+1; // x=x+1 처럼 한 행을 추가하지 않으면 while순환문이 끊임없이 계속 돌아가는 무한 순환문이 된다.
if(x>3) {
System.out.println("big x");
}
}
}
}

B.
class HJ{ // 클래스를 정의해주어야 컴파일 가능하다. 또한 클래스의 시작과 끝을 나타내는 중괄호도 잊지 말아야 한다.
public static void main(String [] args){
int x = 5;
while (x>1) {
x = x-1;
if(x<3) {
System.out.println("small x");
}
}
}
}

C.
class Exercise1b{
public static void main(String [] args) { // while순환문 코드는 반드시 클래스 안의 메소드 안에 있어야 한다. 클래스만 있어도 안되고 반드시 그 안에 메소드가 있어야 한다.
int x = 5;
while (x>1) {
x = x-1;
if(x<3) {
System.out.println("small x");
}
}
}
}

}}}
= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터)를 나타낸다. 객체에서 자신에 대해 "아는 것"
 * 메소드:객체에서 할 수 있는 일, 객체에서 자신이 하는 것 "행동"
 * 클래스:클래스는 객체가 아니다. 객체를 만들기 위한 용도, 청사진! 이다. 가상 머신에 그 유형의 객체를 만드는 방법을 알려주는 역할을 한다.
 * 테스트용 클래스:클래스에는 진짜 클래스(실제로 사용할 객체의 유형을 나타내는 클래스)고 <클래스명>TestDrive와 같은 식으로 이름이 붙는 테스트용 클래스가 있다. 테스트용클래스에서 객체를 만들고 그 객체의 변수와 메소드에 접근한다.
 

*68p Television* _채워넣기_

 * 인스턴스 변수:modelname, inch
 * 메소드:channel(),volume()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_
{{{
> GuessGame.java

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
//GuessGame 에는 Player 객체 네개를 저장하기 위한 인스턴트 변수 네개있다.

	public void startGame() {
	p1 = new Player();
	p2 = new Player();
	p3 = new Player();
	p4 = new Player();

	int guessp1 = 0;
	int guessp2 = 0;
	int guessp3 = 0;
	int guessp4 = 0;

	boolean p1isRight = false;
	boolean p2isRight = false;
	boolean p3isRight = false;
	boolean p4isRight = false;

	int targetNumber = (int) (Math.random()*10);
	System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
	
	while(true) {
	 System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

	p1.guess();
	p2.guess();
	p3.guess();
	p4.guess();

	guessp1 = p1.number;
	System.out.println("1번 선수가 찍은 숫자: " + guessp1);

	guessp2 = p2.number;
	System.out.println("2번 선수가 찍은 숫자: " + guessp2);

	guessp3 = p3.number;
	System.out.println("3번 선수가 찍은 숫자: " + guessp3);

	guessp4 = p4.number;
	System.out.println("4번 선수가 찍은 숫자: " + guessp4);

	if(guessp1 == targetNumber) {
	 p1isRight = true;
	}

	if(guessp2 == targetNumber) {
	 p2isRight = true;
	}

	if(guessp3 == targetNumber) {
	 p3isRight = true;
	}

	if(guessp4 == targetNumber) {
	 p4isRight = true;
	}

	if(p1isRight || p2isRight || p3isRight || p4isRight) {

	 System.out.println("맞춘 선수가 있습니다.");
	 System.out.println("1번 선수: " + p1isRight);
	 System.out.println("2번 선수: " + p2isRight);
	 System.out.println("3번 선수: " + p3isRight);
	 System.out.println("4번 선수: " + p4isRight);
	 System.out.println("게임 끝.");
	 break; //게임이 끝났으므로 break문으로 순환문 빠져나간다.

	} else {
	//아직 아무도 못 맞췄기 떼문에 계속해야 합니다.
	System.out.println("다시 시도해야 합니다.");
	}
      }
   }
}  

> Player.java

	public class Player {
	 int number = 0;

	public void guess() {
	 number = (int) (Math.random() * 10);
	 System.out.println("찍은 숫자: " + number);
	}
      }

>GameLauncher.java
	public class GameLauncher {
	 public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
     } 

}}}
*76p 컴파일러가 되어봅시다* _구현후 주석달기_
{{{
A. 

>TapeDeck.java
class TapeDeck{

	boolean canRecord = false;

	void playTape() {
	 System.out.Println("tape playing");
	}

	void recordTape() {
	 System.out.Println("tape recording");
	}
   }

>TapeDeckTestDrive.java
class TapeDeckTestDrive {
	public static void main(String [] args) {
		TapeDeck t = new TapeDeck();
		t.canRecord = true;
		t.playtape();

		if(t.canRecord == true) {
			t.recordTape();
		}
	}
}

B,

>DvDPlayer.java
class DVDPlayer {
	boolean canRecord = false;
	void recordDVD () {
	 System.out.println("DVD recording");
	}
	void playDVD() {
	  System.out.println("DVD playing");
	}
 }

>DVDPlayerTestDrive.java
class DVDPlayerTestDrive {
	public static void main(String [] args) {
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		if(d.canRecord == true) {
			d.recordDVD();
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
변수는 크게 원시변수(primitive variable)와 레퍼런스(objectreference)로 나눌 수 있다.
 원시변수에는 정수,부울,부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이 들어간다.
그리고 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
	String name;
	public static void main (String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[3];
		//그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		// 배열 레퍼런스를 써서 Dog객체에 접근합니다.
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";
		// myDogs[2]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[2].name);
		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
	
	public void bark() {
		System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
	public void eat() {}
	public void chaseCat() {}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A. 
class Books {
	String title;
	String author;
}

class BooksTestDrive {
	public static void main(String [] args) {
		
		Books [] myBooks = new Books[3];
		int x = 0;
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); // myBooks 의 객체를 만든다
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook"; // 책의 제목
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian"; // 책의 저자
		while(x<3) { // x가 3이 될때까지 책 세권의  제목과 저자를 나타내준다.
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}

B.
class Hobbits {
	String name;
	public static void main(String [] args) {
		Hobbits [] h = new Hobbits[3];
			int z = -1; // 배열의 인덱스는 0에서 시작해야한다.
			while (z<2) {
				z = z + 1; // z가 0부터 시작한다.
				h[z] = new Hobbits();
				h[z].name = "bilbo";
				if(z==1) { // z = 1 일때의 이름
						h[z].name = "frodo";
				}
				if (z==2) { // z = 2 일때의 이름 그리고 out
					h[z].name = "sam";
				}
				System.out.print(h[z].name + " is a ");
				System.out.println("good Hobbit name"); //출력
			}
	}
}



}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥이 이겼다.
 * 문제가 된 부분은 어딘가요?:
켄트의 메소드에서 사용한 레퍼런스 변수의 개수는 밥의 메소드에 비해 작았지만,
그의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수 없다는 문제가 있었다.
순환문을 한 바퀴 돌 때마다 그는 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버림받게 된것이다.
즉, 그 객체는 다시는 사용할 수 없었다.
따라서 기껏 객체 10개를 만들고는 하나에만 접근 할 수 있는 켄트의 메소드는 아무 쓸모가 없었다. 그래서 밥이 밥을 먹게 되었다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_
{{{
 * 캡슐화: 캡슐화(Encapsulation) 는 매우 중요하다. 캡슐화를 해놓지 않으면 아무나 데이터에 접근할 수 있다. 예를들어 레퍼런스 변수를 통해 접근 할 수 있다. 따라서 모든 인스턴스 변수에 대해 세터 메소드를 만들어야 한다.
--> 캡슐화 p.116 GoodDog 클래스 캡슐화 예제문제
class GoodDog {

	private int size;
	
	public int getSize() {
		return size;
	}
	
	public void setSize(int s) {
		size = s;
		}
	
	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size >14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class GoodDogTestDrive {
	
	public static void main(String[] args) {
		GoodDog one = new GoodDog();
		one.setSize(70);
		GoodDog two = new GoodDog();
		two.setSize(8);
		System.out.println("Dog one:" + one.getSize());
		System.out.println("Dog two:" + two.getSize());
		one.bark();
		two.bark();
	}
}

결과>
Dog one:70
Dog two:8
Wooof! Wooof!
Yip! Yip!

 * 게터와 세터: 게터(getter)와 세터(setter)의 정식 명칭은 액세서(accessor)와 뮤테이터(mutator)이다. 게터와 세터는 각각 어떤 것을 가져오고(get) 설정하는(get) 역할을 한다. 보통 인스턴스 변수의 값에 대해 그런 작업을 한다. 게터는 단지 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 쓰인다. 세터는 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수:
인스턴스 변수는 클래스 내에서 선언된다.(메소드 내에서 선언되는 것이 아니다.)
지역변수(local variable)는 메소드 내에서 선언된다. 또한 지역변수는 사용하기 전에 반드시 초기화해야한다. 
}}}
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;
	
	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {
	
	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A.
class XCopy {
	public static void main(String [] args) {
	int orig = 42; // orig 에 42 대입
	XCopy x = new XCopy(); 
	int y = x.go(orig); // y에 x.go(orig) 대입, 이때 orig 값은 42
	System.out.println(orig + " " + y); // 42 84 출력
}

int go(int arg) {
	arg = arg * 2; // 기존 orig 값인 42를 두배 하여 84 값으로 반환해준다.
	return arg;
 }
}

결과>
42 84

B.
class Clock {
	String time;
	void setTime(String t) {
		time = t;
		}

	String getTime() { // return 이 time 이므로 void 가 아닌 String이어야 한다.
		return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {
		
		Clock c = new Clock();
		
		c.setTime("1235"); // 초기 setTime 의 time t에 "1235"대입된다.
		String tod = c.getTime(); // tod 형태로 getTime 함수에서 return 되는 time을 받는다.
		System.out.println("time:"+tod);
	}
}

결과>
time:1235

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}