#summary 장유리의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {


        public static void main (String[] args) {
                int beerNum = 99;
                String word = "bottles"; // "bottles"는 복수형이다

                while (beerNum > 0) {
                        if (beerNum == 1)
                        {       word = "bottle";
                        }

                        System.out.println(beerNum + " " + word + " of beer on the wall");
                        System.out.println(beerNum + " " + word + " of beer.");
                        System.out.println("Take one down.");
                        System.out.println("Pass it around.");
                        beerNum = beerNum - 1; // 하나씩 감소한다

                        if (beerNum>0) {
                                System.out.println(beerNum + " " + word + " of beer on the wall"); } else {
                                System.out.println("No more bottles of beer on the wall");
                        }
                }
        }
}


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
        public static void main (String[] args) {

        String[] wordListOne = {"Happy", "Sad", "Angry", "nervous", "surprised","tired", "jealous", "scared", "relaxed", "terrified"}; // 문자열 배열을 만든다.

        String[] wordListTwo = {"sweet", "sour", "salty", "spicy", "smoothy", "greesy", "moistful", "soft"};

        String[] wordListThree = {"ugly", "cute", "pretty", "handsome", "eyelid", "big headed", "sharp chin", "round cheek", "pony tail"};

        int oneLength = wordListOne.length;
        int twoLength = wordListTwo.length;
        int threeLength = wordListThree.length;

        int rand1 = (int) (Math.random() * oneLength); //배열에서 임의의 숫자 뽑아냄.
        int rand2 = (int) (Math.random() * twoLength);
        int rand3 = (int) (Math.random() * threeLength);

        String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3]; // 임의로 뽑은 단어들을 합친다.

        System.out.println("What we need is a " + phrase);
        }
}
~      



}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행시킨다. 보안 관련 작업도 한다. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 그걸 건드렸는지 확인하는 작업도 한다. 
 * 컴파일러: 일일이 손으로 바이트코드를 작성하는 것은 아주 어렵고 시간이 많이 걸린다. 하지만 컴파일러 덕분에 좀 더 쉽게 코드를 작성하고 컴파일러가 바이트 코드로 해석해 주기 때문에 자바 프로그램 실행 속도도 증가하고 사용자가 사용하기 편해진다. 그리고 데이터 유형이 위반된 것도 바로 잡아주고, 접근 위반을 방지하기도 하고, 사람들이 함부로 건드리면 안되는 코드를 건드리려는 등의 일을 방지하기도 한다. 즉, 발생할 수 있는 문제점의 대부분을 미리 잡아낸다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A. 
class Exercise1b {
        public static void main(String [] args) {
                int x=1;
                while (x<10) {

                        x=x+1; // x가 증가되지 않으면 while 문이 반복되도 x의 값이 1로 고정되어서 big x가 출력되지 않는다.
                if(x>3) {
                        System.out.println("big x");
                }
                }
        }
}

B.
class X {
        public static void main(String [] args) {
                int x=5;
                while (x>1) {
                        x = x-1;
                        if (x<3) {
                                System.out.println("small x");
                        }
                }
       }

} // 클래스가 정해지지 않아 프로그램이 실행되지 않는다.

C.
public class Exercise1b {
        public static void main (String[] args) {     //메인 메소드 선언이 필요하다.
                int x = 5;
                while(x>1)
                {
                        x = x-1;
                        if(x<3)
                        {
                                System.out.println("small x");
                        }       
                }
        }
}

     
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 용도, 청사진
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: 전원, 채널, Sound 
 * 메소드: Poweron(), setchannel()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
                Player p1;
                Player p2;
                Player p3;
                Player p4;
        
                public void startGame(){
                        p1 = new Player(); // player 객체 만든다.
                        p2 = new Player();
                        p3 = new Player();
                        p4 = new Player();

                        int guessp1 = 0;
                        int guessp2 = 0;
                        int guessp3 = 0;
                        int guessp4 = 0;

                        boolean p1isRight = false;
                        boolean p2isRight = false;
                        boolean p3isRight = false;
                        boolean p4isRight = false;

                        int targetNumber = (int) (Math.random() *10);
                        System.out.println("0 over 9 under");
                        
                        while(true){
                                System.out.println("right number " + targetNumber + ".");

                        p1.guess(); // guess 메소드를 부른다.
                        p2.guess();
                        p3.guess();
                        p4.guess();

                        guessp1 = p1.number;
                        System.out.println("player 1 picked: "+guessp1);
                        
                        
                        guessp2 = p2.number;
                        System.out.println("player 2 picked: "+guessp2);

                        guessp3 = p3.number;
                        System.out.println("player 3 picked: "+guessp3);


                        guessp4 = p4.number;
                        System.out.println("player 4 picked: "+guessp4);


                        if (guessp1 == targetNumber){
                                p1isRight = true;
                        }

                        if (guessp2 == targetNumber){
                                p2isRight = true;
                        }

                        if (guessp3 == targetNumber){
                                p3isRight = true;
                        }

                        if (guessp4 == targetNumber){
                                p4isRight = true;
                        }

                        if (p1isRight || p2isRight || p3isRight || p4isRight) {

                                System.out.println("Right number!");
                                System.out.println("player 1 : "+ p1isRight);
                                System.out.println("player 2 : "+ p2isRight);
                                System.out.println("player 3 : "+ p3isRight);
                                System.out.println("player 4 : "+ p4isRight);
                                System.out.println("Game set.");

                                break;

                        } else {
                
                                System.out.println(" Try again ");
                         } // 플레이어가 뽑은 숫자가 맞으면 게임 끝 아니면 다시한다.
                        }
                     }
                }

pubilc class Player{
        int number = 0;

        public void guess() {
                number = (int) (Math.random() *10);
                System.out.println("Selected number: "+number);
        }
      } // 10이하의 숫자를 뽑는 클래스이다.

public class GameLauncher {
        public static void main (String[] args) {
                GuessGame game = new GuessGame();
                game.startGame();
        }
      }    // 게임을 시작하는 클래스이다.             

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
 A
class TapeDeck {
	boolean canRecord = false;
	void playTape() {
		System.out.println("tape playing");
	}

	void recordTape() {
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive {
	public static void main(String [] args) {

	TapeDeck t = new TapeDeck(); // 실제 객체를 만들어야 한다.
	t.canRecord = true;
	t.playTape();

	if (t.canRecord == true) {
		t.recordTape();
	}
	}
}

B
class DVDPlayer {
	boolean canRecord = false;
	void recordDVD () {
		System.out.println("DVD recording");
	}

	void playDVD() {
		System.out.println("DVD playing");
	} // 메소드가 있어야 d.playDVD();가 들어있는 행이 컴파일 된다.
}

class DVDPlayerTestDrive {
	public static void main(String [] args) {
	DVDPlayer d = new DVDPlayer ();
	d.canRecord = true;
	d.playDVD();
	if (d.canRecord == true) {
		d.recordDVD ();
	}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
원시변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다. 객체레퍼런스에는 객체에 대한 레퍼런스가 들어간다.원시변수는 변수의 실제 값을 나타내는 비트가 들어있지만, 객체 레퍼런스 변수에는 객체에 접근하는 방법을 나타내는 비트가 들어있다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
	String name;
	public static void main (String[] args) {
	Dog dog1 = new Dog();
	dog1.bark();
	dog1.name = "Bart";

	Dog[] myDogs = new Dog[3]; // Dog객체에 대해 크기가 3인 배열을 만든다.
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;

	myDogs[0].name = "Fred";
	myDogs[1].name = "Marge";

	System.out.print("마지막 개의 이름: ");
	System.out.println(myDogs[2].name);

	int x = 0;
	while(x< myDogs.length) {
		myDogs[x].bark();
		x=x+1;
	}
}

public void bark() {
	System.out.println(name + "이(가) 왈!하고 짖습니다.");
}

public void eat() {}

public void chaseCat() {}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class Books {
        String title;
        String author;
}

class BooksTestDrive {
        public static void main(String[] args) {
                
                Books[] myBooks = new Books[3];
                int x = 0;
 
                myBooks[0] = new Books;
                myBooks[1] = new Books;
                myBooks[2] = new Books;   // 배열을 선언한 다음에 각각의 myBooks에 대한 객체를 만들어야한다.
        

                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";

                while(x < 3) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }  
        }   
} 

B
class Hobbits {
	String name;

	public static void main(String [] args) {
		
		Hobbits [] h = new Hobbits[3];
		int z=-1; // 배열은 0부터 시작해야 한다.

		while(z<2) // 배열은 0부터 시작해야 한다.
		{
			z=z+1;
			h[z] = new Hobbits();
			h[z].name = "bilbo";
		if(z==1)
		{
			h[z].name="frodo";
		}
		if(z==2)
		{
			h[z].name="sam";
		}
		System.out.print(h[z].name + " is a ");
		System.out.println("good Hobbit nqme");
		}	
	}
}



}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?:토니의 매소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수 없다. 순환문을 한바퀴 돌때 마다 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버림받게 됬다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:인스턴트 변수 주변에 방어막 같은 것을 만들어 아무도 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다.
 * 게터와 세터: 게터와 세터는 각각 어떤 것을 가져오고 설정하는 역할을 한다. 게터는 그 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오는 용도로 쓰이고, 세터는 그 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하는 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언된다. 인스턴스 변수에는 항상 어떤 기본값이 들어간다. 지역 변수는 메소드 내에서 선언된다. 지역변수는 사용하기 전에 반드시 초기화 해야 한다.
 
*107p Dog* _실행_

{{{
class Dog
{
	int size;
	String name;

	void bark()
	{
		if (size>60)
		{
			System.out.println("Woof! Woof!");
		}
		else if (size>14)
		{
			System.out.println("Ruff! Ruff!");
		}
		else
		{
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive
{
	public static void main(String[] args)
	{
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;

		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class XCopy
{
	public static void main(String [] args)
	{
		int orig = 42;
		XCopy x= new XCopy();
		int y=x.go(orig);
		System.out.println(orig + " " + y);
	}

	int go(int arg)
	{
		arg = arg*2;
		return arg;
	}
} // 별 문제 없다. 결과는 42 84

B
class Clock
{
	String time;
	
	void setTime(String t)
	{
		time=t;
	}
	
	String getTime() // 게터 메소드에는 반드시 return 필요하다.
	{
		return time;
	}
}

class ClockTestDrive
{
	public static void main(String [] args)
	{
		Clock c= new Clock();

		c.setTime("12345");
		String tod= c.getTime();
		System.out.println("time : " + tod);
	}
}



}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
     익스트림 프로그래밍은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있도록 만들어진 것이다. XP는 조금씩, 자주 발표하고 사이클을 반복해서 돌리면서 개발하고, 스펙에 없는 것은 절대 집어넣지 않는다. 그리고 테스트 코드를 먼저 만들고 언저 어디서든 코드를 개선할 수 있고 모든 테스트를 마치고 발표를 한다. 모든 일을 단순하게 처리하고 조금씩 발표하여 현실적으로 부담이 덜한 프로그래밍이다.

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotCom
{
	int[] locationCells;
	int numOfHits = 0;

	public void setLocationCells(int[] locs)
	{
		locationCells = locs;
	}

	public String checkYourself(String stringGuess)
	{
		int guess = Integer.parseInt(stringGuess);
		/* String을 int로 변환해야 한다. */
		String result = "miss";
		/* 리턴할 결과를 저장할 변수 만든다. 기본값은 miss이다. */
		for(int i = 0; i< locationCells.length; i++)
		{
			if (guess == locationCells[i])
			{
				result = "hit";
				numOfHits++;
				break;
			}
		} // 순환문 끝

		if (numOfHits == locationCells.length)
		{
			result = "kill";
		}
		System.out.println(result);
			return result; 
			/* 메소드를 호출할 메소드로 결과를 리턴한다. */
	} // 메소드 끝
} // 클래스 끝

public class SimpleDotComGame {
public static void main(String[] args)
{
	int numOfGuesses = 0; // 사용자가 추측한 횟수 추측하는 변수이다.
	GameHelper helper = new GameHelper();  /* 사용자로부터 입력을 받기 위한 메소드가 들어있는 클래스 만든다. */

	SimpleDotCom theDotCom = new SimpleDotCom(); /* 닷컴 객체를 만든다.*/

	int randomNum = (int) (Math.random() * 5); 
	int[] locations = {randomNum, randomNum+1, randomNum+2}; 
	/* 첫번째 셀 위치를 정하기 위한 난수를 만들고 그 값을 써서 셀 위치 배열을 만든다 */

	theDotCom.setLocationCells(locations); // 닷컴의 위치 지정한다.
	boolean isAlive = true;

	while(isAlive == true)
	{
		String guess = helper.getUserInput("enter a number");
		/* 사용자가 입력한 String을 받아온다*/
		String result = theDotCom.checkYourself(guess);
		/* 닷컴 객체를 통해 추측한 값이 맞는지 확인한다. */
		numOfGuesses++;
		if (result.equals("kill"))
		{
			isAlive = false;
			System.out.println(numOfGuesses + " guesses");
		} // if 문 끝
	} // while 문 끝
} // main 문 끝
}

import java.io.*;
public class GameHelper
{
	public String getUserInput(String prompt)
	{
		String inputLine = null;
		System.out.print(prompt + " ");
		try
		{
			BufferedReader is = new BufferedReader ( new InputStreamReader(System.in));
		inputLine = is.readLine();
		if(inputLine.length() == 0) return null;
		}
		catch (IOException e)
		{
			System.out.println("IOException: "+ e);
		}
		return inputLine;
	}
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive1 {
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0; 
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};
                theDotCom.setLocationCells(locations); 

                boolean[] checks = {false, false, false}; // 배열의 값을 모두 false로 설정한다.
                theDotCom.setcheckCells(checks);  

                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

public class SimpleDotCom1 {
        
        int[] locationCells;
        int numOfHits = 0; 

        boolean[] checkCells; // 눌린 위치를 체크하기 위한 boolean형의 배열 선언한다.
        
        public void setLocationCells (int[] locs) {
                
                locationCells = locs;
        }

        public void setcheckCells (int[] checks) { 
                
                checkCells = checks;
        } // 체크했을때 했다는 것을 표시한다.

        public String checkYourself (String stringGuess) {
                
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss";

                for(int i = 0 ;i < locationCells.length ; i++) {
                        if(guess == locationCells[i]) {

                                if(checkCells[i] == true)  
                                        break;

                                result = "hit";  
                                numOfHits++;

                                checkCells[i] = true; // 누른 번호가 맞다면 checkCells[i]를 true로 바꿔준다.

                                break;
                                
                        }
                }
                
                if(numOfHits == locationCells.length) { 
                        result = "kill";
                }
                System.out.println(result); 
                return result; 
        }       
}

import java.io.*;
public class GameHelper1 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}
}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive2 {
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0;  
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};
                theDotCom.setLocationCells(locations); 
                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

public class SimpleDotCom2 {
        
        int[] locationCells;
        int numOfHits = 0; 
        
        public void setLocationCells (int[] locs) {
                
                locationCells = locs;
        }

        public String checkYourself (String stringGuess) {
                
                int guess = Integer.parseInt(stringGuess); 
                String result = "miss";

                for(int i = 0 ;i < locationCells.length ; i++) {
                        if(guess == locationCells[i]) {
                                result = "hit";  
                                
                                locationCells[i] = -1; // locationCells[i]의 값을 음수로 넣어주어 맞춘 칸을 표시한다.
                                                       
                                numOfHits++;
                                break;
                
                        }
                }
                
                if(numOfHits == locationCells.length) { 
                        result = "kill";
                }
                System.out.println(result); 
                return result; 
        }
}

import java.io.*;
public class GameHelper2 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}
}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList; 

public class SimpleDotComTestDrive3 {
        
        public static void main (String args[]) {
                
                int numOfGuesses = 0;  
                GameHelper helper = new GameHelper();  
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                int randomNum = (int) (Math.random()*5); 
                
                ArrayList<String> locations = new ArrayList();
                location.add(String.valueOf(randomNum)); // add하게되면 ArrayList의 공간 하나가 추가되면서 임의의 숫자값이 들어간다.
                location.add(String.valueOf(randomNum+1));
                location.add(String.valueOf(randomNum+2));                                      

                theDotCom.setLocationCells(locations); 
                boolean isAlive = true;
                
                while(isAlive == true) {
                        String guess = helper.getUserInput("enter a number"); 
                        String result = theDotCom.checkYourself(guess); 
                        numOfGuesses++;
                        
                        if(result.equals("kill")) {
                                isAlive = false; 
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        } 
}

import java.util.ArrayList;

public class SimpleDotCom3 {
                private ArrayList<String> locationCells; // locationCells에 대한 정보를 숨기기 위해 private로 선언함.
                
        public void setLocationCells (ArrayList<String> locs) {
                
                locationCells = locs;
        }

        public String checkYourself (String stringGuess) {
                
                int index = locationCells.indexof(stringGuess); // indexOf(Object)하게되면 Object가 들어있는 index의 수를 return 해준다.
                String result = "miss";
        
                if(index >= 0)
                {
                        locationCells.remove(index);
                        if(locationCells.isEmpty())
                                result = "kill";
                        else
                                result = "hit";
                }

                System.out.println(result); 
                return result; 
        }
}

import java.io.*;
public class GameHelper3 { 
        public String getUserInput(String prompt) {
                String inputLine = null; 
                System.out.print(prompt + " "); 
                
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0) 
                                return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                
                return inputLine; 
        }
        
}
}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
import java.io.*;
import java.util.*;

public class GameHelper {
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int[] grid = new int[gridSize];
        private int comCount = 0;
        
        public String getUserInput(String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length()==0)
                                return null;
                }catch(IOException e){
                        System.out.println("OException: " + e);
                }
                
                return inputLine.toLowerCase();
        }
        
        public ArrayList<String> placeDotCom(int comSize){
                ArrayList<String> alphaCells = new ArrayList<String>(); // 배열에 좌표값이 들어간다.
                String temp = null; // 나중에 연결하기 위한 임시 String 배열이다.
                int[] coords = new int[comSize]; // 현재 후보 좌표이다.
                int attempts = 0; // 시도 횟수를 세기 위한 카운터이다.
                boolean success = false; // 적당한 위치를 찾았는지 표시하기 위한 표시이다.
                int location = 0; // 현재 시작 위치
                
                comCount++; // n번째 닷컴
                int incr = 1; // 수평 방향으로 증가시킬 값 설정
                if((comCount%2)==1){ // 홀수 번째 닷컴인 경우(수직으로 배치)
                        incr = gridLength; // 수직 방향으로 증가시킬 값 설정
                }
                
                while(!success & attempts<200){ // 주 검색 순환문(32)
                        location = (int)(Math.random()*gridSize); // 임의 시작 위치를 구함
                        int x = 0; // 위치시킬 닷컴의 n번째 위치
                        success = true; // 성공할 것으로 가정함
                        while(success && x<comSize){ 
                                if(grid[location]==0){
                                        coords[x++] = location; // 위치 저장
                                        location += incr; // 다음 칸 확인
                                        if(location>=gridSize){ 
                                                success = false; 
                                        }
                                        if(x>0 & (location % gridLength==0)){ 
                                                success = false; 
                                        }
                                }else{ 
                                        success = false; 
                                }
                        }
                }
                
                int x = 0; // 위치를 알파벳 좌표로 바꾼다.
                int row = 0;
                int column = 0;
                
                while(x<comSize){
                        grid[coords[x]] = 1; // 기본 그리드 좌표를 '사용 중'으로 표시
                        row = (int)(coords[x]/gridLength); 
                        column = coords[x]%gridLength;
                        temp = String.valueOf(alphabet.charAt(column)); // 숫자된 열을 알파벳으로 구한다.
                        
                        alphaCells.add(temp.concat(Integer.toString(row)));
                        x++;
                }
                
                return alphaCells;
        }
}

import java.util.*;

public class DotComBust { 
        private GameHelper helper = new GameHelper();
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>(); // DotCom객체로 이루어진 ArrayList 만든다.
        private int numOfGuesses = 0;
        
        private void setUpGame(){ // 닷컴 객체 몇 개를 만들고 위치 지정한다.
                DotCom one = new DotCom();
                one.setName("Pets.com");
                DotCom two = new DotCom();
                two.setName("eToys.com");
                DotCom three = new DotCom();
                three.setName("Go2.com");
                dotComsList.add(one);
                dotComsList.add(two);
                dotComsList.add(three);

                System.out.println("Your goal is to sink three dot coms.");
                System.out.println("Pets.com, eToys.com, Go2.com");
                System.out.println("Try to sink them all in the fewest number of guesses");
                
                for (DotCom dotComToSet : dotComsList){
                        ArrayList<String> newLocation = helper.placeDotCom(3); 
                        dotComToSet.setLocationCells(newLocation); 
                } 
        } 
        
        private void startPlaying(){
                while(!dotComsList.isEmpty()){
                        String userGuess = helper.getUserInput("Enter a guess");
                        checkUserGuess(userGuess);
                } 
                
                finishGame();
        } 
        
        private void checkUserGuess(String userGuess){
                numOfGuesses++; // 사용자 추측 횟수 증가시킨다.
                String result = "miss";
                
                for(DotCom dotComToTest : dotComsList){ 
                        result = dotComToTest.checkYourself(userGuess); 
                        if(result.equals("hit"))
                                break;
                        if(result.equals("kill")){
                                dotComsList.remove(dotComToTest);
                                break;
                        }
                }
                
                System.out.println(result);
        }
        
        private void finishGame(){
                System.out.println("All Dot Coms are dead! Your stock is now worthless");
                if(numOfGuesses<=18){
                        System.out.println("It only took you " + numOfGuesses + " guesses.");
                        System.out.println("You got out before your options sank");
                }else{
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
                        System.out.println("Fish are dancing with your options");
                }
        }
        
        public static void main (String[] args){
                DotComBust game = new DotComBust(); // 게임 객체 만든다.
                game.setUpGame();
                game.startPlaying();
        }
}

import java.util.*;

public class DotCom {
        private ArrayList<String> locationCells;
        private String name;
        
        public void setLocationCells(ArrayList loc){
                locationCells = loc;
        }
        
        public void setName(String n){
                name = n;
        }
        
        public String checkYourself(String userInput){
                String status = "miss";
                int index = locationCells.indexOf(userInput);
                
                if(index>=0){
                        locationCells.remove(index); 
                        if(locationCells.isEmpty()){ // 모든 위치를 맞췄는지 확인한다.
                                status = "kill";
                                System.out.println("Ouch! You sunk " + name + "   :  (");
                        }else{
                                status = "hit";
                        }
                } 
                
                return status;
        } 
} 


}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 하위클래스가 상위클래스의 맴버를 물려받는다는 것. 인스턴스 변수와 메소드를 "클래스의 맴버"라고 부른다.
 * 다형성: 상위 클래스 형식이 들어갈 수 있는 모든 자리에 해당 상위클래스와 임의의 하위클래스에 속하는 객체를 마음대로 사용가능함. 

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Animal {
        String picture;
        boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise(){
        }
        
        void eat(boolean food){
        }
        
        void sleep(){
        }
        
        void roam(){
        }
}

class Feline extends Animal{
        void roam(){
        }
} // roam 메소드가 있는 Feline 클래스이다. Animal클래스(상위)의 하위클래스이다.

class Lion extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Lion 클래스이다. Feline클래스(상위)의 하위클래스이다.

class Tiger extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Tiger 클래스이다. Feline클래스(상위)의 하위클래스이다.


class Cat extends Feline{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Cat 클래스이다. Feline클래스(상위)의 하위클래스이다.


class Hippo extends Animal{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Hippo 클래스이다. Animal클래스(상위)의 하위클래스이다.

class Canine extends Animal{
        void roam(){
        }
} // roam 메소드가 있는 Canine 클래스이다. Animal클래스(상위)의 하위클래스이다.

class Wolf extends Canine{
        void makeNoise(){
        }

        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Wolf 클래스이다. Canine클래스(상위)의 하위클래스이다.

class Dog extends Canine{
        void makeNoise(){
        }
        
        void eat(boolean food){
        }
} // makeNoise 메소드와 eat 메소드가 있는 Dog 클래스이다. Canine클래스(상위)의 하위클래스이다.

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:하위 클래스에서 상위 클래스의 함수의 동작을 변경하기 위해 상위 클래스의 함수를 재정의 하는것이다. 오버로드는 특성상 한 클래스에서 몇번이고 중복 정의 할수 있지만, 오버라이드는 한 하위 클래스에서 '한번만' 정의 할 수 있다.
 * 오버로딩:비슷한 일을 하는 함수를 같은 함수이름으로 인자의 갯수를 다르게 하거나, 타입을 다르게 함으로서 구현하는 방법이다.단, 리턴형은 같아도 달라도 무관하다.  오버로딩된 메소드들은 서로 무관한 함수 취급한다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive {
        public static void main(String [] args) {
                Monster [] ma = new Monster[3];
                ma[0]= new Vampire();
                ma[1]= new Dragon();
                ma[2]= new Monster();
                
                for(int x=0; x<3; x++) {
                        ma[x].frighten(x);
                }
        }
}

class Monster {
        boolean frighten(int d) {
                System.out.println("arrrgh");
                return true;
        }

}

class Vampire extends Monster {
        boolean frighten(int x) {
                System.out.println("a bite?");
                return false;
        }
}

class Dragon extends Monster {
        boolean frighten(int degree) {
                System.out.println("breath fire");
                return true;
        }
} // Monster클래스의 하위클래스에는 Vampire클래스와 Dragon클래스가있다.
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100%추상 메소드로 구성된 것.
 * 다형성:다형성은 다양한 객체들을 하나의 코드로 처리하는 기술.
 * 추상 클래스: 추상 클래스는 객체 생성 용도로 사용하지 않는 경우에 사용한다. 변수의 타입으로 선언하는 용도와 상속의 본연의 기능으로 특정한 코드를 하위 클래스로 물려주는 기능을 활용할 때 사용한다. 
 * 추상 메소드:반드시 오버라이드 해야 하는 매소드.
 * 다중 상속:상위클래스를 두 개이상 사용하는 접근법.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:힙에서 사는 변수는 객체이다. 힙에서 사는 변수는 없어지지 않는다. 
 * 스택에서의 변수:메소드 호출과 지역변수가 산다. 지역변수가 객체에대한 레퍼런스일 경우에는 변수만 스택에 들어간다. 스택에 사는 변수는  끝나면 없어진다. 
 * 생성자:생성자는 새로운 객체를 만든는 역할을 한다. 생성자에는 객체를 생성할 때 실행되는 코드가 들어있다. 즉, 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있다.
 * 널 레퍼런스:레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 즉, 리모컨은 있는데 그로 TV를 조종할 수 없는 셈이다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에  NullPointerException이 생겨 실행이 되지 않는다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체를 지원하는 역할을 한다. 객체 안에 저장되어 있어 힙에 저장되어 있다. 객체의 상태를 저장하고 있다. 
 * 지역 변수: 객체가 어떤 행동을 할 수 있게 하는 메소드에 있다. 임시변수(temporary variable)이라고 부르기도 한다. 스택프레임에 저장되어 있다. 다른 메소드가 실행되는 동안 스택 맨 위로 올라올 때까지 아무것도 하지 않는다. 

*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.*;
class V2Radiator {
     V2Radiator(ArrayLIst list) {
          for(int  x = 0; x < 5; x++) {
               list.add(new SimUnit("V2Radiator")); //list에 SimUnit객체를 더한다.
          }
     }
}

class V3Radiator extends V2Radiator{
     V3Radiator (ArrayLIst lglist) {
          super(lglist);
          for(int g = 0; g < 10; g++) {
               lglist.add(new SimUnit("V3Radiator")); // lglist에 SimUnit객체를 더한다.
          }
     }
} 

class RetentionBot {
     RetentionBot(ArrayList rlist) {
          rlist.add(new SimUnit("Retention")); // rlist에 SimUnit객체를 더한다.
     }
}

public class TestLifeSupportSim{
     public static void main(String [] args) {
          ArrayList aList = new ArrayList();
          V2Radiator v2 = new V2Radiator(aList);
          V3Radiator v3 = new V3Radiator(aList);
          for(int z = 0; z > 20; z++) {
               RetentionBot ret = new RetentionBot(aList);
          }
     }
}

class SimUnit {
     String botType;
     SimUnit (String type){
          botType = type;
     }
     int powerUse() {
          if ("Retention".equals(botType)) {
               return 2;
          } else {
               return 4;
          }
     }
}
}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:클래스의 인스턴스 없이 메소드를 실행할 수 있다. 인스턴트 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않고, 클래스만 있어도 된다.
 * 정적 메소드를 선언하는 방법:
 * static final:static final로 선언한 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지한다. 변수를 상수로 지정하는 방법이다. 
 * 널 레퍼런스:
 * 오토 박싱:원시값과 래퍼 객체 사이의 변환을 자동으로 처리해 주는 기능이다.원시유형이 들어갈 자리에 그 유형에 해당하는 래퍼 객체를 집어넣거나, 반대로 어떤 래퍼 객체가 들어갈 자리에 원시값을 집어넣을 수 있게 해준다.
 * 정적 임포트:타이핑하기 싫어하는 사람들에게는 아주 좋은 기능ㅎ이지만, 코드를 읽기가 어려워질 수 있는 단점이 있다.

*339p Calendar* _구현후 주석달기_

{{{
import java.util.*;

public class DayTimeAccount {
        public static void main(String args[]){

                Calendar c=Calendar.getInstance();
                c.set(2012, 0, 7, 15, 40); // 시작을 2012년 1월 7일 15:40으로 설정한다.

                long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 단위로 표현된 값으로 리턴한다.
                day1 += 1000*60*60;

                c.setTimeInMillis(day1); // 한시간에 해당하는 만큼의 시간을 더하고 시각을 설정
                System.out.println("new hour"+c.get(Calendar.HOUR_OF_DAY));
                c.add(Calendar.DATE, 35); // 35일을 더함.
                System.out.println("add 35 days"+c.getTime());
                c.roll(Calendar.DATE, 35); // 35일 뒤로 넘긴다. 그치만 달은 바뀌지 않는다.
                System.out.println("roll 35 days"+c.getTime());
                c.set(Calendar.DATE,1); // 날짜를 1로 설정
                System.out.println("set to 1"+c.getTime());
        }

}
}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 인스턴스마다 하나씩 가지고 있는 변수이다.
 * 지역 변수: 클래스마다 하나씩 있는 변수이다. 이 변수를 사용하면 다른 변수에 비해 메모리가 많이 절약되는 장점이 있다.. 한 클래스에 속하는 모든 인스턴스에 의해서 공유된다. 


*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class StaticSuper
{
        static// 딱 한번만 실행되는 static 메소드이다. 
       {
                System.out.println("super static blokc");
        }
        
        StaticSuper()// 생성자이다.
        {
                System.out.println("super constructor");
        }
}

public class StaticTests extends StaticSuper{
        static int rand;
        
        static
        {
                rand = (int) (Math.random() * 6);
                System.out.println("static block " + rand);
        }
        
        StaticTests()//생성자이다.
        {
                System.out.println("in main");
                StaticTests st = new StaticTests();//StaticTests 객체를 생성한다.
        }
}
}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}