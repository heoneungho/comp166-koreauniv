#summary 자바 코딩은 참 즐거운 것 같아 >_<~ (페이지의 내용은 각 학생에 의해서 관리됩니다.)
#labels 2012190731임채원

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{


public class BeerSong { // 클래스 명
   public static void main (String[] args) { // 메인 매쏘드 선언
      int beerNum = 99; // beerNum은 정수를 받는 변수
      String word = "bottles"; // 복수형
      
      while (beerNum > 0) { // while문

             if (beerNum == 1) {
               word = "bottle";   // 단수형(한 병인 경우)
               }

      System.out.println(beerNum + " " + word + " of beer on the wall"); // 출력
      System.out.println(beerNum + " "원 + word + " of beer.");
      System.out.println("Take one down.");
      System.out.println("Pass it around.");
      beerNum = beerNum - 1;

      if (beerNum > 0) {
           //System.out.println(beerNum + " " + word + " of beer on the wall");
    	  //중복을 막기위해 주석처리를 한다.
      } else {
           System.out.println("No more bottles of beer on the wall");
      } // else문 끝
    }//while 순환문 끝
   }// main 클래스 끝
} // 클래스 끝


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main(String[] args) {
		// 세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String[] wordListOne = {"Terran", "Protoss", "Zerg"};
		String[] wordListTwo = {"is", "isn't", "maybe"};
		String[] wordListThree = {"overbalanced.", "good.", "bad."};
		
		// 각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		// 난수 세 개를 발생시킵니다.
		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);
	
		// 이제 구문을 만듭니다.
		String phrase = wordListOne[rand1] + " " +
		wordListTwo[rand2] + " " + wordListThree[rand3];
		
		// 구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}	
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
 - 프로그램(자바)을 실행시킨다.
 * 컴파일러:
 - 언어를 해석해서 실행시킨다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b {
	public static void main(String[] args) {
		int x = 1;
		while (x < 10) {
			x++; // x의 값을 변화시켜서 무한반복을 방지한다.
			if ( x > 3) {
				System.out.println("big x");
			}
		}
	}
}

class Exercise1b { // 클래스 선언이 빠졌다.
	public static void main(String[] args) {
		int x = 5;
		while ( x > 1 ) {
			x = x - 1;이
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

class Exercise1b { 
	public static void main(String[] args) { // 메소드가 빠졌다.
		int x = 5;
		while ( x > 1 ) {
			x = x - 1;이
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것을 뜻한다.
 * 메소드: 객체에서 자신이 하는 것을 뜻한다.
 * 클래스: 객체를 만들기 위한 청사진을 뜻한다.
 * 테스트용 클래스: 클래스들이 실행되게 하는 클래스를 뜻한다. (메인 메소드가 온다)
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume, power
 * 메소드: setChannel(), upVolume(), downVolume(), on(), off() 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
package game;

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}


package game;

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보렴.");
		
		while(true) {
			System.out.println("맞춰야 한 숫자는 "  + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp3 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp3);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			}  // if/else 부분 끝
		} // 순환문 끝
	} // 메소드 끝
} // 클래스 끝

package game;

public class Player {
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
package toBeCompiler;

public class TapeDeck {
	
	boolean canRecord = false;
	
	void playTape() {
		System.out.println("tape playing");
	}
	
	void recordTape() {
		System.out.println("tape recording");
	}
}

package toBeCompiler;

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		
		TapeDeck t = new TapeDeck(); // 레퍼런스 변수 t가 필요합니다.
		t.canRecord = true;
		t.playTape();
	
	
	if (t.canRecord == true) {
		t.recordTape();
		}
	}
}

// ---------------------------------------------------------------

package toBeCompiler2;

public class DVDPlayer {
	boolean canRecord = false;
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
	
	void playDVD() { // playDVD를 정의해 준다.
		System.out.println("DVD playing"); 
	}
}

package toBeCompiler2;

class DVDPlayerTestDrive {
	public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD(); // playDVD();를 정의해 줘야합니다!
		
	if(d.canRecord == true) {
		d.recordDVD();
		}
	}
}



}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수는 정수, 부울, 부동소수점과 같은 기초적인 값이 들어가는 반면 레퍼런스변수는 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

package makedogwaff;

public class Dog {
    String name;
    public static void main(String[] args) {
        Dog dog1 = new Dog();
        dog1.bark(); // 아직 dog1에 이름이 할당 되지 않았습니다. null 값처리.
        dog1.name = "저글링";
        
        Dog[] myDogs = new Dog[5]; // 이름을 넣을 배열을 만든다.
        myDogs[0] = new Dog();
        myDogs[1] = new Dog();
        myDogs[2] = new Dog();
        myDogs[3] = new Dog();
        myDogs[4] = dog1;


        myDogs[0].name = "히드라";
        myDogs[1].name = "맹독충";
        myDogs[2].name = "일벌레";
        myDogs[3].name = "울트라";
       
        System.out.print("마지막 개의 이름은 ");
        System.out.println(myDogs[4].name);
        
        int x = 0;
        while (x < myDogs.length) {
            myDogs[x].bark();
            x = x+1;
        } // 모든 개들을 짖게 하자.
    }
    public void bark() {
        System.out.println(name + " 이(가) 꾸에에엑!하고 짖습니다.");
    } // 개들을 짖게하는 매소드다.
    
    public void eat() { }
    public void chaseCat() { }
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

package toBeCompiler;

public class Books { // Books 클래스입니다.
	String title;
	String author;
	// 두 가지 문자열을 받는 군요!
}

package toBeCompiler;

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books [] myBooks = new Books[3];
		for(int x = 0; x < myBooks.length; x++) {
			myBooks[x] = new Books();
		} // myBooks에 각각 Books()를 생성해 줍니다.
			
		myBooks[0].title = "자바의 포도";
		myBooks[1].title = "위대한 자바";
		myBooks[2].title = "자바 요리책";
		
		myBooks[0].author = "임요벙";
		myBooks[1].author = "콩지노";
		myBooks[2].author = "벼수달";
		
		int y = 0; // x를 위에서 썼으니 다른 변수를 이용하도록 합시다.
		
		while (y < 3) { // 반복문으로 출력을 한다!
			System.out.print(myBooks[y].title);
			System.out.print(" by ");
			System.out.println(myBooks[y].author);
			y = y + 1;
		}
	}
}

//------------------------------------------------------------------------------

package toBeCompiler2;

public class Hobbits {
	
		String name;
		
		public static void main(String[] args) {
			Hobbits [] h = new Hobbits[3];
			int z = -1; // 변수 z를 적당히 수정한다.
			
			while ( z < 2 ) { // 반복문의 조건에 의해 하나하나 출력하도록 변수 z의 값을 재 조정합니다.
				z = z + 1;
				h[z] = new Hobbits();
				h[z].name = "강건마";
				if ( z == 1 ) { 
					h[z].name = "마영웅";
				}
				if ( z == 2) { 
					h[z].name = "지대호";
				}
				System.out.print(h[z].name + " 은 ");
				System.out.println("좋은 학생들의 이름이다?");
			}
		}
}


}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 토니
 * 문제가 된 부분은 어딘가요?: 토니는 ca[0], ca[1], ..., ca[9]의 메모리를 전부 할당 했지만, 켄트는 refc를 계속 초기화 시켰습니다. 결국 최종 결과물은 refc 하나인 셈입니다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 다른 사람이 변수를 함부로 바꾸지 못하도록 private를 이용해서 보호하는 작업.
 * 게터와 세터: 게터는 값을 받고, 세터는 값을 돌려줍니다.
 * 인스턴스 변수 vs 지역 변수: 인스턴트 변수는 클래스내에서 선언 되는 변수인 반면 지역변수는 사용전에 반드시 초기화 해야하고 메소드 내에서 선언된다.
 
*107p Dog* _실행_

{{{
package dogBarksBySize;

public class Dog {
	int size;
	String name;
	
	void bark() { // 개가 짖는데...
		if (size > 60) { // 큰 싸이즈
			System.out.println("왈! 왈!");
		} else if (size > 14) { // 중간 싸이즈
			System.out.println("멍! 멍!");
		} else { // 작은 싸이즈를 나타냅니다!
			System.out.println("깨갱! 깨갱!");
		}
	}
}

package dogBarksBySize;

public class DogTestDrive {
	public static void main(String[] args) {
	// 각각의 개들에게 싸이즈를 주는 작업입니다.
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
	// 짖어보렴.
		one.bark();
		two.bark();
		three.bark();
	}
	
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
 package toBeCompiler;

public class XCopy {
	public static void main(String[] args) {
		
		int orig = 42;
		
		XCopy x = new XCopy();
		
		int y = x.go(orig); // go라는 함수에 orig를 매개변수로 넣어서 y에 받습니다.
		
		System.out.println(orig + " " + y); // y는 orig의 2배이니... 
		// 출력은 42 84가 되겠지요
	}
	
	int go(int arg) {
		
		arg = arg * 2;
		
		return arg;
	}

}
//--------------------------------------------------------------

package toBeCompiler2;

public class Clock {
	String time;
	
	void setTime (String t) {
		time = t;
	}
	String getTime () { //time은 String이니 반환값도 같아야한다.
		return time; 
	}
}

package toBeCompiler2;

public class ClockTestDrive {
	public static void main(String[] args) {
		
		Clock c = new Clock ();
		
		c.setTime("1245");
		String tod = c.getTime(); // tod에 시간을 받는다.
		System.out.println("time: " + tod); // 출력한다.
	}
	
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 소프트웨어 개발 방법론 분야다. "조금씩, 하지만 자주 발표", "사이클을 반복해서 돌리면서 개발", "스펙에 없는 것은 넣지 않는다" 등등의 규칙이 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

package dotComGame;

import java.io.*; // System.in을 사용하기 위해 임포트함.

public class GameHelper {

  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + "  ");
     try { // 예외처리
       BufferedReader is = new BufferedReader(
	 new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println("IOException: " + e);
     }
     return inputLine;
  }
}

// ------------------------------------------------------------------------

package dotComGame;

public class SimpleDotCom {

		int[] locationCells; // 배열을 만든다.
		int numOfHits = 0;
		
		public void setLocationCells(int[] locs) {
			locationCells = locs;
		}

		// 닷컴이 맞는지 안맞는지에 대한 판별을 하는 메쏘드
		public String checkYourself (String stringGuess) {
			int guess = Integer.parseInt(stringGuess);
			String result = "miss";
			for(int i = 0; i < locationCells.length; i++) {
				if (guess == locationCells[i]) {
					result = "hit";
					numOfHits++;
					break;
				}
			} // 순환문 끝
			
			if (numOfHits == locationCells.length) {
				result = "kill";
			}
			System.out.println(result);
				return result;
		} // 메소드 끝
} // 클래스 

//--------------------------------------------------------------

package dotComGame;

public class SimpleDotComGame {
	public static void main(String[] args) {
		
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); // 새로운 게임헬퍼 객체를 만든다.
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5);
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
package dotComGamePatch1;

import java.io.*;

public class GameHelper {

  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + "  ");
     try {
       BufferedReader is = new BufferedReader(
	 new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println("IOException: " + e);
     }
     return inputLine;
  }
}
//-----------------------------------------------------------
package dotComGamePatch1;

public class SimpleDotCom {

		int[] locationCells;
		boolean[] hitCells; // 참 거짓을 판별할 새로운 행렬이다.
		int numOfHits = 0;
		
		public void setLocationCells(int[] locs) {
			locationCells = locs;
		}
		
		public void setHitCells(boolean[] hits) {
			hitCells = hits;
		}
		
		public String checkYourself (String stringGuess) {
			int guess = Integer.parseInt(stringGuess);
			String result = "miss";
			for(int i = 0; i < locationCells.length; i++) {
			
				
				if ((guess == locationCells[i])) {
					if (hitCells[i] == true) {
						break;
					} // 맞은 상태라면 빠져나옵니다.
					result = "hit";
					numOfHits++;
					hitCells[i] = true; // 맞았으면 true로 바뀜.
					
					break;
				}
			} // 순환문 끝
			
			if (numOfHits == locationCells.length) {
				result = "kill";
			}
			System.out.println(result);
				return result;
		} // 메소드 끝
} // 클래스 

//--------------------------------------------------------------

package dotComGamePatch1;

public class SimpleDotComGame {
	public static void main(String[] args) {
		
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5);
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean[] hits = {false, false, false}; // 초기값은 false다.
		theDotCom.setHitCells(hits); // 새로운 배열
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

package dotComGamePatch2;

import java.io.*;

public class GameHelper {

  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + "  ");
     try {
       BufferedReader is = new BufferedReader(
	 new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println("IOException: " + e);
     }
     return inputLine;
  }
}

//----------------------------------------------------

package dotComGamePatch2;

public class SimpleDotCom {

		int[] locationCells;
		int numOfHits = 0;
		
		public void setLocationCells(int[] locs) {
			locationCells = locs;
		}
		
		public String checkYourself (String stringGuess) {
			int guess = Integer.parseInt(stringGuess);
			String result = "miss";
			for(int i = 0; i < locationCells.length; i++) {
			
				
				if (guess == locationCells[i]) {
					result = "hit";
					numOfHits++;
					locationCells[i] = -1; // 값을 -1으로 바꿉니다.
					
					break;
				}
			} // 순환문 끝
			
			if (numOfHits == locationCells.length) {
				result = "kill";
			}
			System.out.println(result);
				return result;
		} // 메소드 끝
} // 클래스 

//----------------------------------------------------------------

package dotComGamePatch2;

public class SimpleDotComGame {
	public static void main(String[] args) {
		
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5);
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
package dotComGamePatch3;

import java.util.ArrayList;

public class DotCom {

		private ArrayList<String> locationCells;
		
		// int numOfHits = 0;
		// (없어도 됩니다)
		
		public void setLocationCells(ArrayList<String> loc) {
			locationCells = loc;
		}
		
		public String checkYourself (String userInput) {
		
			String result = "miss";
			
			int index = locationCells.indexOf(userInput);
			
			if (index >= 0) {
				
				locationCells.remove(index);
				
				if (locationCells.isEmpty() ) {
					result = "kill";
				} else {
					result = "hit";
				} // if문 끝
				
			} // 바깥쪽 if문 끝
			
		System.out.println(result);
		return result;
	} // 메소드 끝
} // 클래스 끝

//---------------------------------------------------------------------------------

package dotComGamePatch3;

import java.io.*;

public class GameHelper {

  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + "  ");
     try {
       BufferedReader is = new BufferedReader(
	 new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println("IOException: " + e);
     }
     return inputLine;
  }
}

//----------------------------------------------------------------------------------

package dotComGamePatch3;

import java.util.ArrayList;

public class SimpleDotComGame {
	public static void main(String[] args) {
		
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		DotCom theDotCom = new DotCom();
		int randomNum = (int) (Math.random() * 5);
		
		ArrayList<String> locations = new ArrayList();
		locations.add(String.valueOf(randomNum));
		locations.add(String.valueOf(randomNum+1));
		locations.add(String.valueOf(randomNum+2));
		
		theDotCom.setLocationCells(locations);
		
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}
		}
	}
}
}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

// 나중에

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 하위클래스가 상위클래스에게 상속(확장) 받으면 하위클래스에서도 상위클래스에서 했던 것들을 할 수 있다.
 * 다형성: 다형성을 이용하면 레퍼런스와 객체가 다른 유형이어도 된다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{
package polymorphism;

public class Animal {
	String picture;
	String food;
	int hunger;
	int[] boundaries;
	int[] location;
	
	public void makeNoise(){}
	public void eat(){}
	public void sleep(){}
	public void roam(){}
}

//-----------------------------------------------

package polymorphism;

public class Feline extends Animal {
	public void roam() {}
}

//------------------------------------------------

package polymorphism;

public class Hippo extends Animal {
	public void makeNoise() {}
	public void eat() {}
}

//------------------------------------------------

package polymorphism;

public class Canine extends Animal{
	public void roam() {}
}

//-------------------------------------------------

package polymorphism;

public class Lion extends Feline{
	public void makeNoise() {}
	public void eat() {}
}

//--------------------------------------------------

package polymorphism;

public class Tiger extends Feline{
	public void makeNoise() {}
	public void eat() {}
}

//----------------------------------------------------

package polymorphism;

public class Cat extends Feline{
	public void makeNoise() {}
	public void eat() {}
}

//----------------------------------------------------

package polymorphism;

public class Wolf extends Feline{
	public void makeNoise() {}
	public void eat() {}
}

//----------------------------------------------------

package polymorphism;

public class Dog extends Feline{
	public void makeNoise() {}
	public void eat() {}
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 하위클래스에서 같은 반환값의 형태, 입력값의 형태, 이름의 메소드를 쓰는 것
 * 오버로딩: 하위클래스에서 이름은 같지만 반환값의 형태, 입력값의 형태는 다를 수도 있는 것

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

package ToBeCompiler;

public class MonsterTestDrive {
	public static void main(String[] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++) {
			ma[x].frighten(x);
			// ma[0].frighten(0)
			// ma[1].frighten(1)
			// ma[2].frighten(2) 이 실행되는 것이다.
		}
	}
}

class Monster {
	boolean frighten (int d) {
		System.out.println("arrrgh");
		return true;
	}
}

// Monster에게 상속받았고 지금 상태를 보면 오버라이딩을 해야 적절하다.
// 즉, 반환 유형(boolean)과 입력값(int) 유형이 같아야한다.

class Vampire extends Monster {
	boolean frighten (int x) {
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster {
	boolean frighten (int degree) {
		System.out.println("breath fire");
		return true;
	}
}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 자바에서의 다중 상속 불가를 해결하기 위해 만든 추상 클래스만을 갖는 형태의 클래스. (추상 클래스와 비슷하다)
 * 다형성: 다형성을 이용하면 레퍼런스와 객체가 다른 유형이어도 된다.
 * 추상 클래스: 가장 하위에 있는 클래스가 아닌 클래스. 확장하기 위한 클래스이다.
 * 추상 메소드: 반드시 오버라이드 시켜서 써야하는 메소드. 추상 클래스 안에 있어야한다.
 * 다중 상속: 자바에서 불가능한 상속형태인데 한 클래스가 여러 개의 클래스에서 동시에 상속 받는 것을 뜻한다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 객체들이 모여있다. 가비지 컬렉션 기능이 있다.
 * 스택에서의 변수:  매소드 호출과 지역 변수가 사는 곳.
 * 생성자: public 이름 (변수1, 변수2, ...) {}처럼 메소드가 만들어 질 때 참조하는 것. 
 * 널 레퍼런스: 아무것도 가르치지 않는 것을 나타내는 레퍼런스다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체와 함께 힙에 있으며, 도중에 초기화 되거나 강제로 제거되지 않는다면 객체가 사라질 때 같이 사라진다. 
 * 지역 변수: 메소드 안에 존재하며, 전산 순서에 따라 스택에 쌓이며 순차적으로 사라진다.

*302p 5분 미스터리* _구현후 주석달기_

{{{ 
package fiveminMystery;

import java.util.*;

class V2Radiator {
	V2Radiator (ArrayList list) {
		for(int x=0; x<5; x++) {
			list.add(new SimUnit ("V2Radiator"));
		}
	}
}

class V3Radiator /*extends V2Radiator*/ {
	V3Radiator (ArrayList lglist) {
		// super(lglist);
		for(int g=0; g<10; g++) {
			lglist.add(new SimUnit("V3Radiator"));
		}
	}
}

class RetentionBot {
	RetentionBot (ArrayList rlist) {
		rlist.add(new SimUnit("Retention"));
	}
}

public class TestLifeSupportSim {
	public static void main(String[] args) {
		ArrayList aList = new ArrayList();
		V2Radiator v2 = new V2Radiator(aList);
		V3Radiator v3 = new V3Radiator(aList);
		for(int z=0; z<20; z++) {
			RetentionBot ret = new RetentionBot(aList);
		}
	}
}

class SimUnit {
	String botType;
	SimUnit(String type) {
		botType = type;
	}
	int powerUse() {
		if("Retention".equals(botType)) {
			System.out.println("Used 2 energy!!!"); // 에너지를 얼마나 소모했는지를 표현해줍니다.
			return 2;
		} else {
			System.out.println("Used 4 energy!!!"); // 에너지를 얼마나 소모했는지를 표현해줍니다.
			return 4;
		}
	}
}

// 결과적으로 aList에 V2R이 5개, V2R이 5개, V3R이 10개, Retention이 10개 쌓입니다. 
// (5+5+10)*4 + 10*2 = 120의 에너지를 소모하게 된 것입니다. 
// 고로 V3Radiator가 상V2Radiator를 상속한데에서 온 문제입니다. 
// 상속받지 않으면 사라가 의도한대로 코딩을 할 수 있습니다. 
}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 클래스의 인스턴스없이 메소드를 실행할 수 있는 메소드.
 * 정적 메소드를 선언하는 방법:  앞에 static을 붙인다.
 * static final: static final로 선언된 변수는 상수다.
 * 널 레퍼런스: 아무것도 가르치지 않는 것을 나타내는 레퍼런스다.
 * 오토 박싱: 원시유형을 컬렉션에 집어넣거나, 컬렉션에서 꺼낼 때, 거의 언제나 원시 유형이 들어갈 자리에 그 유형에 해당하는 래퍼 객체를 집어넣거나, 반대로 어떤 래퍼 객체가 들어갈 자리에 원시값을 집어넣을 수 있게하준다.
 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 활용해서 타이핑을 더 적게 해보자는 것.

*339p Calendar* _구현후 주석달기_

{{{
package calendar;

import java.util.*;

public class CalendarUsage {
	public static void main(String[] args) {
		Calendar c = Calendar.getInstance();
		
		c.set(1992,4,27,18,15);
		// 1992년 5월 27일 18시 15분
		long day1 = c.getTimeInMillis();
		// 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현.
		day1 += 1000 * 60 * 60;
		// 밀리초단위로 한시간을 나타냅니다.
		c.setTimeInMillis(day1);
		// 한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
		System.out.println("새 시간 " + c.get(c.HOUR_OF_DAY));
		c.add(c.DATE, 35);
		// 35일을 더합니다.
		System.out.println("35일 후 " + c.getTime());
		// 35일 후 결과값 출력.
		c.roll(c.DATE, 35);
		// 35일을 더하되, 달은 변경하지 않습니다.
		System.out.println("35일을 굴리면 " + c.getTime());
		// 35일 굴리고 결과값 출력.
		c.set(c.DATE, 1);
		// 날짜를 1로 설정.
		System.out.println("1일로 설정 " + c.getTime());
		 // 날짜를 1로 설정하고 결과값 출력.
	}
}
}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 정적변수는 절차위주의 프로그래밍 썼던 비효율적인 변수 할당 방법이므로 바람직하지 않다. 
 * 정적 변수: 하지만 정적변수는 이미 자바 환경 자체에 녹아들어가 있고 때에 따라서는 정적 변수를 쓰는 것이 편리할 때도 있으므로 정적변수를 매도해서만은 안된다.

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
package toBeCompiler;

public class StaticSuper {
	static { // 실행하자마자 바로 초기화
		System.out.println("super static block");
	}
	
	StaticSuper() { // 생성자 메소드에 ()를 넣어줍니다.
		System.out.println("super constructor");
	}
}

//----------------------------------------

package toBeCompiler;

public class StaticTests extends StaticSuper {
	static int rand; 
	
	static { // 실행하자마자 바로 초기화
		rand = (int) (Math.random() * 6);
		System.out.println("static block " + rand);
	}
	
	StaticTests() {
		System.out.println("constructor");
	}
	
	public static void main(String[] args) {
		System.out.println("in main");
		StaticTests st = new StaticTests();
	}
	
}

// 고로 출력 결과는
// super static block
// static block 0
// in main
// super constructor
// constructor
// 가 된다.
}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{
package exception;

public class Test01 {
	public static void main(String[] args) {
		
		// 앞뒤 상황 생략
		
		public void takeRisk() throws BadException {
			if (abandonAllHope) {
				throw new BadException();
			}
		}
		
		public void crossFingers() {
			try {
				anObject.takeRisk(); // 오류가 발생할 수도 있는 행동
			} catch (BadException ex) {
				System.out.println("Aaargh!"); // 그 때 예외 상황을 발생시키고 출력할 것.
				ex.printStackTrance();
			}
		}
		
	}
}
}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{
package soundApp;

import javax.sound.midi.*;

public class MiniMiniMusicApp {

		public static void main(String[] args) {
			MiniMiniMusicApp mini = new MiniMiniMusicApp(); // 미니미니뮤직앱 생성 >_<
			mini.play(); // 실행
		} // main 메소드 끝
		
		public void play() {
			
			try {
				Sequencer player = MidiSystem.getSequencer(); // 시퀀서를 받아서 엽니다.
				player.open();
				
				Sequence seq = new Sequence(Sequence.PPQ, 4);
				
				
				Track track = seq.createTrack(); // 시퀀서에 트랙을 요청
				
				// 트랙에 미디이벤트를 집어넣습니다.
				ShortMessage a = new ShortMessage(); 
				a.setMessage(144, 1, 44, 100);
				MidiEvent noteOn = new MidiEvent(a, 1);
				track.add(noteOn);
				
				ShortMessage b = new ShortMessage();
				b.setMessage(128, 1, 44, 100);
				MidiEvent noteOff = new MidiEvent(b, 16);
				track.add(noteOff);
				
				player.setSequence(seq); // 시퀀서에 시퀀스를 보냅니다.
				
				player.start(); // CD의 재생 버튼을 누르는 것과 비슷!
			
			} catch (Exception ex) {
				ex.printStackTrace();
			}

		} // play 메소드 끝
} // 클래스 

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{
package soundApp2;

import javax.sound.midi.*;

public class MiniMusicCmdLine {

		public static void main(String[] args) {
			MiniMusicCmdLine mini = new MiniMusicCmdLine(); // 미니미니뮤직앱 생성 >_<
			if (args.length < 2) {
				System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
			} else {
				int instrument = Integer.parseInt(args[0]); // 악기선택
				int note = Integer.parseInt(args[1]); // 음 높이선택
				mini.play(instrument, note); // 실행
			}
		} // main 끝
		
		public void play(int instrument, int note) {
			
			try {
				
				Sequencer player = MidiSystem.getSequencer(); // 시퀀서를 받아서 엽니다.
				player.open();
				Sequence seq = new Sequence(Sequence.PPQ, 4);
				Track track = seq.createTrack(); // 시퀀서에 트랙을 요청
				
				MidiEvent event = null; // 무엇을 할지,  언제 할지 결정함.
				
				ShortMessage first = new ShortMessage();
				first.setMessage(192, 1, instrument, 0);
				MidiEvent changeInstrument = new MidiEvent(first,1);
				track.add(changeInstrument);
				
				// 트랙에 미디이벤트를 집어넣습니다.
				ShortMessage a = new ShortMessage(); 
				a.setMessage(144, 1, 44, 100);
				MidiEvent noteOn = new MidiEvent(a, 1);
				track.add(noteOn);
				
				ShortMessage b = new ShortMessage();
				b.setMessage(128, 1, 44, 100);
				MidiEvent noteOff = new MidiEvent(b, 16);
				track.add(noteOff);
				player.setSequence(seq); // 시퀀서에 시퀀스를 보냅니다.
				player.start(); // CD의 재생 버튼을 누르는 것과 비슷!
			
			} catch (Exception ex) {
				ex.printStackTrace();
			}

		} // play 메소드 끝
} // 클래스

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
package firstGUI;

import javax.swing.*;

public class SumpleGui1 {
	public static void main(String[] args) {
		
		JFrame frame = new JFrame();
		JButton button = new JButton("click me");
		// 프레임과 버튼을 만든다. (버튼 생성자에 버튼에 표시할 텍스트를 전달)
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// 창을 닫을 때 프로그램을 종료시킴.
		frame.getContentPane().add(button);
		// 버튼을 프레임의 내용 틀(content pane)에 추가한다.		
		frame.setSize(300,300);
		// 프레임의 크기 지정(픽셀단위)
		frame.setVisible(true);
		// 화면에 표시하도록 설정.
	}
}
}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
package secondGUI;

import javax.swing.*;
import java.awt.event.*;

public class SimpleGui1B 
implements ActionListener /*인터페이스를 구현*/ {
	JButton button;
	
	public static void main(String[] args) {
		SimpleGui1B gui = new SimpleGui1B();
		gui.go();
	}
	
	public void go() {
		
		JFrame frame = new JFrame();
		button = new JButton("click me");
		
		button.addActionListener(this); //버튼에 등록.
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().add(button);
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event) {
		button.setText("I've been clicked!"); // 이벤트 발생
	}
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{
package thirdGUI;

import javax.swing.*;
import java.awt.*;

class MyDrawPanel extends JPanel{
	public void paintComponent (Graphics g) {
		Graphics2D g2d = (Graphics2D) g;
		
		int red = (int) (Math.random() * 256);
		int green = (int) (Math.random() * 256);
		int blue = (int) (Math.random() * 256);
		Color startColor = new Color(red, green, blue);
		
		red = (int) (Math.random() * 256);
		green = (int) (Math.random() * 256);
		blue = (int) (Math.random() * 256);
		Color endColor = new Color(red, green, blue);
		
		GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
		// 시작점, 시작점, 시작 색, 끝점, 끝점, 끝나는 색
		g2d.setPaint(gradient); // 그라디언트
		g2d.fillOval(70,70,100,100); // 색 채우기
	}
}
//-----------------------------------------------
package thirdGUI;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {

	JFrame frame;
	
	public static void main(String[] args) {
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
	}
	
	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton button = new JButton("Change colors");
		button.addActionListener(this);
		
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, button);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.setSize(300,300);
		// 버튼은 남쪽에 타원은 중앙에
		frame.setVisible(true);
	}
	
	public void actionPerformed (ActionEvent event) {
		frame.repaint(); // 버튼을 클릭하면 repaint()를 호
	}	
}
}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{
package fourthGUI;

import javax.swing.*;
import java.awt.*;

class MyDrawPanel extends JPanel{
	public void paintComponent (Graphics g) {
		Graphics2D g2d = (Graphics2D) g;
		
		int red = (int) (Math.random() * 256);
		int green = (int) (Math.random() * 256);
		int blue = (int) (Math.random() * 256);
		Color startColor = new Color(red, green, blue);
		
		red = (int) (Math.random() * 256);
		green = (int) (Math.random() * 256);
		blue = (int) (Math.random() * 256);
		Color endColor = new Color(red, green, blue);
		
		GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
		// 시작점, 시작점, 시작 색, 끝점, 끝점, 끝나는 색
		g2d.setPaint(gradient); // 그라디언트
		g2d.fillOval(70,70,100,100); // 색 채우기
	}
}
//-----------------------------------------------------
package fourthGUI;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class TwoButtons {
	
	JFrame frame;
	JLabel label;
	
	public static void main(String[] args) {
		TwoButtons gui = new TwoButtons ();
		gui.go();
	}
	
	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton labelButton = new JButton("Change Label");
		labelButton.addActionListener(new LabelListener());
		
		JButton colorButton = new JButton("Change Circle");
		colorButton.addActionListener(new ColorListner());
		
		label = new JLabel("I'm a label");
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.getContentPane().add(BorderLayout.EAST, labelButton);
		frame.getContentPane().add(BorderLayout.WEST, label);
		
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	
	class LabelListener implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			label.setText("Ouch!");
		}
	}
	
	class ColorListner implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			frame.repaint();
		}
	}
}

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{
package animation;
import javax.swing.*;
import java.awt.*;


public class SimpleAnimation {

    int x = 70;
    int y = 70; // 메인 GUI 클래스에 원의 x,y 좌표 저장

    public static void main (String[] args) {
       SimpleAnimation gui = new SimpleAnimation ();
       gui.go();
   }

   public void go() {
       JFrame frame = new JFrame();
       frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

       MyDrawPanel drawPanel = new MyDrawPanel();       

       frame.getContentPane().add(drawPanel);
       frame.setSize(300,300);
       frame.setVisible(true);


       for (int i = 0; i < 130; i++) {

          x++;
          y++;

          drawPanel.repaint();
  
          try {
            Thread.sleep(50);
          } catch(Exception ex) { }
       }
    
   }// go() 메소드 끝끝


    class MyDrawPanel extends JPanel {
    
       public void paintComponent(Graphics g) {
          g.setColor(Color.white);
          g.fillRect(0,0,this.getWidth(), this.getHeight());

          g.setColor(Color.green);
          g.fillOval(x,y,40,40);
끝
       }
    } // 내부 클래스 끝
} // 외부 클래스 끝
}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{
package musicVideo;

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

  // this one plays random music with it, but only because there is a listener.

public class MiniMusicPlayer3 {

    static JFrame f = new JFrame("My First Music Video");
    static MyDrawPanel ml;

    public static void main(String[] args) {
           MiniMusicPlayer3 mini = new MiniMusicPlayer3();
           mini.go();
     }
   
 
     public  void setUpGui() {
       ml = new MyDrawPanel();
       f.setContentPane(ml);
       f.setBounds(30,30, 300,300);
       f.setVisible(true);
    }
 

    public void go() {
       setUpGui();

       try {

         // make (and open) a sequencer, make a sequence and track

         Sequencer sequencer = MidiSystem.getSequencer();         
         sequencer.open();
        
         sequencer.addControllerEventListener(ml, new int[] {127});
         Sequence seq = new Sequence(Sequence.PPQ, 4);
         Track track = seq.createTrack();     

         // now make two midi events (containing a midi message)

      int r = 0;
      for (int i = 0; i < 60; i+= 4) {

          r = (int) ((Math.random() * 50) + 1);
         
          track.add(makeEvent(144,1,r,100,i));
        
          track.add(makeEvent(176,1,127,0,i));
         
          track.add(makeEvent(128,1,r,100,i + 2));
       } // end loop
        
          // add the events to the track            
          // add the sequence to the sequencer, set timing, and start

          sequencer.setSequence(seq);
 
          sequencer.start();
          sequencer.setTempoInBPM(120);
      } catch (Exception ex) {ex.printStackTrace();}
  } // close go


   public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
          MidiEvent event = null;
          try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
            
          }catch(Exception e) { }
          return event;
       }



 class MyDrawPanel extends JPanel implements ControllerEventListener {
      
      // only if we got an event do we want to paint
      boolean msg = false;

      public void controlChange(ShortMessage event) {
         msg = true;       
         repaint();         
      }

      public void paintComponent(Graphics g) {
       if (msg) {
            
         Graphics2D g2 = (Graphics2D) g;

         int r = (int) (Math.random() * 250);
         int gr = (int) (Math.random() * 250);
         int b = (int) (Math.random() * 250);

         g.setColor(new Color(r,gr,b));

         int ht = (int) ((Math.random() * 120) + 10);
         int width = (int) ((Math.random() * 120) + 10);

         int x = (int) ((Math.random() * 40) + 10);
         int y = (int) ((Math.random() * 40) + 10);
         
         g.fillRect(x,y,ht, width);
         msg = false;

       } // if문 끝
     } // 메소드 끝
   }  // 내부 클래스 끝

} // 클래스 닫기
}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{
package beatBox;

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {

    JPanel mainPanel;
    ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", 
       "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", 
       "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", 
       "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", 
       "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명 String 배열로 저장합니다.
    int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
    		// 실제 드럼 '건반'을 나타냅니다. 드럼 채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다.
           // 35 - 베이스, 42 - 건반....

    public static void main (String[] args) {
        new BeatBox().buildGUI();
    }
  
    public void buildGUI() {
        theFrame = new JFrame("Cyber BeatBox");
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout);
        background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
        				// 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간 생성.

        checkboxList = new ArrayList<JCheckBox>();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton("Start");
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);         
          
        JButton stop = new JButton("Stop");
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton("Tempo Up");
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton("Tempo Down");
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i < 16; i++) {
           nameBox.add(new Label(instrumentNames[i]));
        }
        
        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);

        theFrame.getContentPane().add(background);
          
        GridLayout grid = new GridLayout(16,16);
        grid.setVgap(1);
        grid.setHgap(2);
        mainPanel = new JPanel(grid);
        background.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i < 256; i++) {                    
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);            
        } // end loop

        setUpMidi();

        theFrame.setBounds(50,50,300,300);
        theFrame.pack();
        theFrame.setVisible(true);
    } // close method


    public void setUpMidi() {
      try {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequence = new Sequence(Sequence.PPQ,4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
        
      } catch(Exception e) {e.printStackTrace();}
    } 

    public void buildTrackAndStart() {
      int[] trackList = null; // 박자에 대한 값.
    
      sequence.deleteTrack(track);
      track = sequence.createTrack(); // 초기화

        for (int i = 0; i < 16; i++) { // 열 16개를 모두 초기화
          trackList = new int[16];
 
          int key = instruments[i];   

          for (int j = 0; j < 16; j++ ) {         
              JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));
              if ( jc.isSelected()) { // 주크박스가 선택되었으면 건반값을 집어넣는다.
                 trackList[j] = key;
              } else { // 선택되지 않았으면 연주하지 않는다.
                 trackList[j] = 0;
              }                    
           } // 안 for문 끝
         
           makeTracks(trackList); // 16개에 대해 모두 실행
           track.add(makeEvent(176,1,127,0,16));  
       } // 밖 for문 끝

       track.add(makeEvent(192,9,1,0,15));      
       try {
           sequencer.setSequence(sequence); 
	     sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); // 루프 반복 횟수를 지정하기 위한 메소드.                   
           sequencer.start();
           sequencer.setTempoInBPM(120);
       } catch(Exception e) {e.printStackTrace();} // 연주
    } // buildTrackAndStart 메소드 끝
            
           
    public class MyStartListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            buildTrackAndStart();
        }
    } // 내부 클래스 끝

    public class MyStopListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            sequencer.stop();
        }
    } // 내부 클래스 끝

    public class MyUpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
	      float tempoFactor = sequencer.getTempoFactor(); 
            sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도를 빠르게
        }
     } // 내부 클래스 끝

     public class MyDownTempoListener implements ActionListener {
         public void actionPerformed(ActionEvent a) {
	      float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도를 느리게
        }
    } // 내부 클래스 끝

    public void makeTracks(int[] list) {        
       
       for (int i = 0; i < 16; i++) {
          int key = list[i];

          if (key != 0) {
             track.add(makeEvent(144,9,key, 100, i));
             track.add(makeEvent(128,9,key, 100, i+1));
          }
       }
    }
        
    public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
끝
        } catch(Exception e) {e.printStackTrace(); }
        return event;
    }

} // 클래스 

        
}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}