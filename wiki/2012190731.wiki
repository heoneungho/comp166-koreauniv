#summary 자바 코딩은 참 즐거운 것 같아 >_<~ (페이지의 내용은 각 학생에 의해서 관리됩니다.)

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{


public class BeerSong { // 클래스 명
   public static void main (String[] args) { // 메인 매쏘드 선언
      int beerNum = 99; // beerNum은 정수를 받는 변수
      String word = "bottles"; // 복수형
      
      while (beerNum > 0) { // while문

             if (beerNum == 1) {
               word = "bottle";   // 단수형(한 병인 경우)
               }

      System.out.println(beerNum + " " + word + " of beer on the wall"); // 출력
      System.out.println(beerNum + " " + word + " of beer.");
      System.out.println("Take one down.");
      System.out.println("Pass it around.");
      beerNum = beerNum - 1;

      if (beerNum > 0) {
           //System.out.println(beerNum + " " + word + " of beer on the wall");
    	  //중복을 막기위해 주석처리를 한다.
      } else {
           System.out.println("No more bottles of beer on the wall");
      } // else문 끝
    }//while 순환문 끝
   }// main 클래스 끝
} // 클래스 끝


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main(String[] args) {
		// 세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String[] wordListOne = {"Terran", "Protoss", "Zerg"};
		String[] wordListTwo = {"is", "isn't", "maybe"};
		String[] wordListThree = {"overbalanced.", "good.", "bad."};
		
		// 각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		// 난수 세 개를 발생시킵니다.
		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);
	
		// 이제 구문을 만듭니다.
		String phrase = wordListOne[rand1] + " " +
		wordListTwo[rand2] + " " + wordListThree[rand3];
		
		// 구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}	
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
 - 프로그램(자바)을 실행시킨다.
 * 컴파일러:
 - 언어를 해석해서 실행시킨다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b {
	public static void main(String[] args) {
		int x = 1;
		while (x < 10) {
			x++; // x의 값을 변화시켜서 무한반복을 방지한다.
			if ( x > 3) {
				System.out.println("big x");
			}
		}
	}
}

class Exercise1b { // 클래스 선언이 빠졌다.
	public static void main(String[] args) {
		int x = 5;
		while ( x > 1 ) {
			x = x - 1;이
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

class Exercise1b { 
	public static void main(String[] args) { // 메소드가 빠졌다.
		int x = 5;
		while ( x > 1 ) {
			x = x - 1;이
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것을 뜻한다.
 * 메소드: 객체에서 자신이 하는 것을 뜻한다.
 * 클래스: 객체를 만들기 위한 청사진을 뜻한다.
 * 테스트용 클래스: 클래스들이 실행되게 하는 클래스를 뜻한다. (메인 메소드가 온다)
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume, power
 * 메소드: setChannel(), upVolume(), downVolume(), on(), off() 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
package game;

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}


package game;

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보렴.");
		
		while(true) {
			System.out.println("맞춰야 한 숫자는 "  + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp3 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp3);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			}  // if/else 부분 끝
		} // 순환문 끝
	} // 메소드 끝
} // 클래스 끝

package game;

public class Player {
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
package toBeCompiler;

public class TapeDeck {
	
	boolean canRecord = false;
	
	void playTape() {
		System.out.println("tape playing");
	}
	
	void recordTape() {
		System.out.println("tape recording");
	}
}

package toBeCompiler;

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		
		TapeDeck t = new TapeDeck(); // 레퍼런스 변수 t가 필요합니다.
		t.canRecord = true;
		t.playTape();
	
	
	if (t.canRecord == true) {
		t.recordTape();
		}
	}
}

// ---------------------------------------------------------------

package toBeCompiler2;

public class DVDPlayer {
	boolean canRecord = false;
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
	
	void playDVD() { // playDVD를 정의해 준다.
		System.out.println("DVD playing"); 
	}
}

package toBeCompiler2;

class DVDPlayerTestDrive {
	public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD(); // playDVD();를 정의해 줘야합니다!
		
	if(d.canRecord == true) {
		d.recordDVD();
		}
	}
}



}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수는 정수, 부울, 부동소수점과 같은 기초적인 값이 들어가는 반면 레퍼런스변수는 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

package makedogwaff;

public class Dog {
    String name;
    public static void main(String[] args) {
        Dog dog1 = new Dog();
        dog1.bark(); // 아직 dog1에 이름이 할당 되지 않았습니다. null 값처리.
        dog1.name = "저글링";
        
        Dog[] myDogs = new Dog[5]; // 이름을 넣을 배열을 만든다.
        myDogs[0] = new Dog();
        myDogs[1] = new Dog();
        myDogs[2] = new Dog();
        myDogs[3] = new Dog();
        myDogs[4] = dog1;


        myDogs[0].name = "히드라";
        myDogs[1].name = "맹독충";
        myDogs[2].name = "일벌레";
        myDogs[3].name = "울트라";
       
        System.out.print("마지막 개의 이름은 ");
        System.out.println(myDogs[4].name);
        
        int x = 0;
        while (x < myDogs.length) {
            myDogs[x].bark();
            x = x+1;
        } // 모든 개들을 짖게 하자.
    }
    public void bark() {
        System.out.println(name + " 이(가) 꾸에에엑!하고 짖습니다.");
    } // 개들을 짖게하는 매소드다.
    
    public void eat() { }
    public void chaseCat() { }
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

package toBeCompiler;

public class Books { // Books 클래스입니다.
	String title;
	String author;
	// 두 가지 문자열을 받는 군요!
}

package toBeCompiler;

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books [] myBooks = new Books[3];
		for(int x = 0; x < myBooks.length; x++) {
			myBooks[x] = new Books();
		} // myBooks에 각각 Books()를 생성해 줍니다.
			
		myBooks[0].title = "자바의 포도";
		myBooks[1].title = "위대한 자바";
		myBooks[2].title = "자바 요리책";
		
		myBooks[0].author = "임요벙";
		myBooks[1].author = "콩지노";
		myBooks[2].author = "벼수달";
		
		int y = 0; // x를 위에서 썼으니 다른 변수를 이용하도록 합시다.
		
		while (y < 3) { // 반복문으로 출력을 한다!
			System.out.print(myBooks[y].title);
			System.out.print(" by ");
			System.out.println(myBooks[y].author);
			y = y + 1;
		}
	}
}

//------------------------------------------------------------------------------

package toBeCompiler2;

public class Hobbits {
	
		String name;
		
		public static void main(String[] args) {
			Hobbits [] h = new Hobbits[3];
			int z = -1; // 변수 z를 적당히 수정한다.
			
			while ( z < 2 ) { // 반복문의 조건에 의해 하나하나 출력하도록 변수 z의 값을 재 조정합니다.
				z = z + 1;
				h[z] = new Hobbits();
				h[z].name = "강건마";
				if ( z == 1 ) { 
					h[z].name = "마영웅";
				}
				if ( z == 2) { 
					h[z].name = "지대호";
				}
				System.out.print(h[z].name + " 은 ");
				System.out.println("좋은 학생들의 이름이다?");
			}
		}
}


}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 토니
 * 문제가 된 부분은 어딘가요?: 토니는 ca[0], ca[1], ..., ca[9]의 메모리를 전부 할당 했지만, 켄트는 refc를 계속 초기화 시켰습니다. 결국 최종 결과물은 refc 하나인 셈입니다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 다른 사람이 변수를 함부로 바꾸지 못하도록 private를 이용해서 보호하는 작업.
 * 게터와 세터: 게터는 값을 받고, 세터는 값을 돌려줍니다.
 * 인스턴스 변수 vs 지역 변수: 인스턴트 변수는 클래스내에서 선언 되는 변수인 반면 지역변수는 사용전에 반드시 초기화 해야하고 메소드 내에서 선언된다.
 
*107p Dog* _실행_

{{{
package dogBarksBySize;

public class Dog {
	int size;
	String name;
	
	void bark() { // 개가 짖는데...
		if (size > 60) { // 큰 싸이즈
			System.out.println("왈! 왈!");
		} else if (size > 14) { // 중간 싸이즈
			System.out.println("멍! 멍!");
		} else { // 작은 싸이즈를 나타냅니다!
			System.out.println("깨갱! 깨갱!");
		}
	}
}

package dogBarksBySize;

public class DogTestDrive {
	public static void main(String[] args) {
	// 각각의 개들에게 싸이즈를 주는 작업입니다.
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
	// 짖어보렴.
		one.bark();
		two.bark();
		three.bark();
	}
	
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
 package toBeCompiler;

public class XCopy {
	public static void main(String[] args) {
		
		int orig = 42;
		
		XCopy x = new XCopy();
		
		int y = x.go(orig); // go라는 함수에 orig를 매개변수로 넣어서 y에 받습니다.
		
		System.out.println(orig + " " + y); // y는 orig의 2배이니... 
		// 출력은 42 84가 되겠지요
	}
	
	int go(int arg) {
		
		arg = arg * 2;
		
		return arg;
	}

}
//--------------------------------------------------------------

package toBeCompiler2;

public class Clock {
	String time;
	
	void setTime (String t) {
		time = t;
	}
	String getTime () { //time은 String이니 반환값도 같아야한다.
		return time; 
	}
}

package toBeCompiler2;

public class ClockTestDrive {
	public static void main(String[] args) {
		
		Clock c = new Clock ();
		
		c.setTime("1245");
		String tod = c.getTime(); // tod에 시간을 받는다.
		System.out.println("time: " + tod); // 출력한다.
	}
	
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}