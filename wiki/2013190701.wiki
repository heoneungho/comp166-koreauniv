#summary 이미현의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {
     public static void main (String[] args) {
          int beerNum = 99;
          String word = "bottles"; //복수형

     while (beerNum > 0) {

     if (beerNum == 1) {
          word = "bottle"; //단수형(한병인 경우)
     }

     System.out.println(beerNum + " " + word + " of beer on the wall");
     System.out.println(beerNum + " " + word + " of beer.");
     System.out.println("Pass it around");
     beerNum = beerNum -1;

     if (beerNum > 0) {
          if(beerNum ==1) {
               word = "bottle";
          }
          System.out.println(beerNum + " " + word + " of beer on the wall");
          }else {
          System.out.println("No more bottles of beer on the wall");
               } //else문 끝
          }//while순환문 끝
     }//main 클래스 끝
}//클래스 끝


}}}
*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main(String[] args) {

	String[] FruitList = {"Apple","Banana","Watermelon","Strawberry","Pear"};

	String[] AnimalList = {"Elephant", "Lion", "Tiger", "Dolphin", "Cat"};

	String[] ColorList = {"Red", "Green", "Blue", "Yellow", "White"};

	int oneLength = FruitList.length;
	int twoLength = AnimalList.length;
	int threeLength = ColorList.length;

	int rand1 = (int)(Math.random()*oneLength);
	int rand2 = (int)(Math.random()*twoLength);
	int rand3 = (int)(Math.random()*threeLength);
	
	String phrase = FruitList[rand1] + " " + AnimalList[rand2] + " " + ColorList[rand3];

	System.out.println("What we need is a " + phrase);

	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행 후, 바이트 코드가 만들어지고 실행되기 전까지 외부에서의 접근을 확인하는 작업을 수행함. 

 * 컴파일러: 자바 언어를 해석, 동적 바인딩을 지원, 실행 시 오류를 막아줌, 클래스 및 메소드의 보안을 담당.


*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Exercise1b {
        public static void main(String [] args) {
	int x=1;
	while (x<10){
		x=x+1;
		if(x>3) {
			System.out.println("big x");
			}
		}
	}
}


B
class Exercise1b {
	public static void main(String []args) {
	int x = 5;
	while(x>1){
		x=x-1;
		if (x<3){
			System.out.println("small x");
			}
		}
	}
}

C
class Exercise1b {
	public static void main(String [] args) {
	int x=5;
	while(x>1) {
		x=x-1;
		if(x>3) {
			System.out.println("small x");
			}
		}
	}
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 용도, 청사진
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스. <클래스명>TestDrive와 같은 이름이 붙는다. 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트하는 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume
 * 메소드: Upchannel(), Downchannel(), Upvolume(), Downvolume()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startgame () {
		p1=new player();
		p2=new player();
		p3=new player();
		p4=new player();
		
		int guessp1=0;
		int guessp2=0;
		int guessp3=0;
		int guessp4=0;
		
		boolean p1isRight=false;
		boolean p2isRight=false;
		boolean p3isRight=false;
		boolean p4isRight=false;
		
		int targetNumber=(int)(Math.random()*10);
		System.out.println("0이상 9이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는 "+targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1=p1.number;
			System.out.println("1번 선수가 찍은 숫자:" + guessp1);
			
			guessp2=p2.number;
			System.out.println("2번 선수가 찍은 숫자:" + guessp2);
			
			guessp3=p3.number;
			System.out.println("3번 선수가 찍은 숫자:" + guessp3);
			
			guessp4=p4.number;
			System.out.println("4번 선수가 찍은 숫자:" + guessp4);
			
			if(guessp1==targetNumber){
				p1isRight=true;
			}
			
			if(guessp2==targetNumber){
				p2isRight=true;
			}
			
			if(guessp3==targetNumber){
				p3isRight=true;
			}
			
			if(guessp4==targetNumber){
				p4isRight=true;
			}
			
			if(p1isRight || p2isRight || p3isRight|| p4isRight) {
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수:" + p1isRight);
				System.out.println("2번 선수:" + p2isRight);
				System.out.println("3번 선수:" + p3isRight);
				System.out.println("4번 선수:" + p4isRight);
				System.out.println("게임 끝.");
				break;
			} else {
				System.out.println("다시 시도해야합니다.");
			} // if/else 부분끝
		} //순환문 끝
	} // 메소드 끝
} // 클래스 끝

public class Player {
	int number=0;
	
	public void guess() {
		number=(int)(Math.random()*10);
		System.out.println("찍은 숫자:" + number);
	}
}

public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startgame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class TapeDeck {
	
	boolean canRecord = false;
	
	void playTape() {
		System.out.println("tape playing");
	}
	
	void recordTape() {
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive {
	public static void main(String [] args) {
		TapeDeck t = new Tapedeck();
		t.canRecord=true;
		t.playTape();
		
		if(t.canRecord == true) {
			t.recordTape();
		}
	}
}

B

class DVDPlayer {
	
	boolean canRecord = false;
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
	
	void playDVD() {
		System.out.println("DVD playing");
	}
}

class DVDPlayerTestDrive {
	public static void main(String [] args) {
		
		DVDPlayer d = new DVDPlayer ();
		d.canRecord = true;
		d.playDVD();
		
		if(d.canRecord == true) {
			d.recordDVD();
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수에는 정수,부울,부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이 들어갑니다. 레퍼런스변수는 힙에 들어있는 객체를 건드릴 수 있는 방법을 나타내는 비트입니다. 
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
        String name;
        public static void main (String[] args) {
                Dog dog1 = new Dog();
                dog1.bark() ;
                dog1.name = "Bill" ;
                
                Dog[] myDogs = new Dog[8];
                myDogs[0] = new Dog() ;
                myDogs[1] = new Dog() ;
                myDogs[2] = new Dog() ;
                myDogs[3] = new Dog() ;
                myDogs[4] = new Dog() ;
                myDogs[5] = new Dog() ;
                myDogs[6] = new Dog() ;
                myDogs[7] = dog1;
        
                //배열 레퍼런스를 써서 Dog객체에 접근합니다.
                myDogs[0].name = "Amy";
                myDogs[1].name = "Teemo";
                myDogs[2].name = "Penta";
                myDogs[3].name = "Roy";
                myDogs[4].name = "Fido";
                myDogs[5].name = "Goerge" ;
                myDogs[6].name = "Bella";
                //myDogs[7] 개의 이름이 뭐였지?
                System.out.print("마지막 개의 이름: ");
                System.out.println(myDogs[7].name);
                
        
                //이제 순환문을 써서 배열에 들어있는
                   //모든 개가 짖도록 합시다.
                int x = 0;
                while(x < myDogs.length) {
                        myDogs[x].bark();
                        x = x + 1;
                }
        }
        public void bark() {
                System.out.println(name + "이(가) 왈! 하고 짖습니다.");
        }
        public void eat() { }
        public void chaseCat() { }
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Books {
        String title ;
        String author ;
}

class BooksTestDrive {
        public static void main(String [] args) {
        
                Books [] myBooks = new Books[3] ;
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books(); //Books라는 객체 생성
                int x = 0;
                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";
        
                while(x<3) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}

B
class Hobbits {
        
        String name ;
        
        public static void main(String [] args) {
        
                Hobbits [] h = new Hobbits[3];
                int z = 0 ;

                while(z<3) {//이름의 수가 3이므로 3으로 바꿈
        
                        h[z] = new Hobbits();
                        h[z].name = "bilbo";
                        if(z==1) {
                                h[z].name = "frodo";
                        }
                        if(z==2) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.println("good Hobbit name");
                        z=z+1;//맨앞에 있으면 0번째가 의미가 없으므로                }
        }
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 방법은 메모리를 약간 절약할 수는 있었지만, 매번 순환문을 돌 때마다 새로운 값으로 초기화되서 밥의 방법보다 효용성이 없다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 외부에 노출되어있는 변수를 보호하기 위하여 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다. 
 * 게터와 세터: 게터는 게터가 가져오기로 한 값을 리턴값 형태로 받아오기 위한 용도 / 세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도 
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언됨 / 지역변수는 메소드 내에서 선언되며, 사용하기 전에 반드시 초기화 해야함.
 
*107p Dog* _실행_

{{{
class Dog {
        int size ;
        String name;

        void bark() {
                if(size > 60) {
                        System.out.println("Wooof! Wooof!");
                } else if (size > 14) {
                        System.out.println("Ruff! Ruff!");
                } else {
                        System.out.println("Yip! Yip!");
                }
        }
}

class DogTestDrive {
        
        public static void main(String [] args) {
                Dog one = new Dog();
                one.size = 70;
                Dog two = new Dog();
                two.size = 8;
                Dog three = new Dog();
                three.size = 35;
        
                one.bark();
                two.bark();
                three.bark();
        }
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class XCopy {
        
        public static void main(String []args) {
        
                int orig = 42;
        
                XCopy x = new XCopy(); // XCopy유형의 객체 x선언

                int y = x.go(orig);//객체x에서 go를 호출하고 이때 orig값을 보낸후 메소드를 실행해 y에 그값을 리턴
        
                System.out.println(orig + " " + y );
        }
        
        int go(int arg) { //함수를 int값으로 리턴을 받게됨
        
                arg=arg*2;
                
                return arg;//arg를 리턴
        }
} //결과 : 42 84 즉 고칠 부분 없음.

B

class Clock {
        String time;
        
        void setTime(String t) {
                time = t;
        }
        
        String getTime() { //time을 리턴받는 게터이고 받을 time은 String이므로 String으로 선언
                return time;
        }
}

class ClockTestDrive {
        public static void main(String [] args) {
        
                Clock c = new Clock();
                
                c.setTime("1245");
                String tod = c.getTime();
                System.out.println("time :  "  + tod);
        }
} // 결과 time : 1245
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 프로그래머들이 코딩을 할때에 테스트 코드를 작성하도록함과 동시에 테스트를 기반으로 프로젝트를 완성시켜 나가도록 하는 프로그래밍 방법. 다음과 같은 방법을 따른다. 
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class simpledotcomtestdrive {
        
    public static void main(String[] args)  {
        int numofGuesses = 0;
        GameHelper helper = new GameHelper();
        
        simpledotcom thedotcom = new simpledotcom();
        
        int randomNum = (int)(Math.random()*5);
        
        int[] locations = {randomNum, randomNum+1, randomNum+2};
        thedotcom.setLocationCells(locations);
        boolean isAlive = true;
        
        while(isAlive == true)  {
                String guess = helper.getUserInput("enter a number");
                String result = thedotcom.checkYourself(guess);
                numofGuesses++;
                
                if(result.equals("kill"))       {
                        isAlive = false;
                        
                        System.out.println(numofGuesses + " guesses");
                }
        }
    }
}



public class simpledotcom {

        int[] locationCells;
        int numOfHits = 0; // number of answer that you correct the target.

public void setLocationCells (int[] locs)       {
        locationCells = locs;
}

public String checkYourself (String stringGuess)        {
        int guess = Integer.parseInt(stringGuess); // string 변수를 int형으로
        String result = "miss";
        for(int i=0; i < locationCells.length; i++)     {
                if(guess == locationCells[i])   {
                        result = "hit";
                        numOfHits++;
                        break;
                }
        }

        if (numOfHits == locationCells.length)  {
                result = "kill";
        }

        System.out.println(result);
        
        return result;
        }       
}
             


import java.io.*;

public class GameHelper {
        public String getUserInput(String prompt)       {
                String inputLine = null;
                
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        
                        if(inputLine.length() == 0 )
                                return null;
                }       catch (IOException e)   {
                        System.out.println("IOException: " + e);
                }
                
                return inputLine;
        }
}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

public class DotcomFirstOption
{
                public static void main(String[] args) 
                {
                        int numOfGuesses = 0;
                        GameHelper helper = new GameHelper();
                        
                        SimpleDotCom theDotCom = new SimpleDotCom();
                        int randomNum = (int) (Math.random() * 5);
                        int[] locations = {randomNum, randomNum + 1,randomNum + 2};
                        theDotCom.setLocationCells(locations);
                        boolean isAlive = true;
                        
                        while(isAlive == true)
                        {
                                String guess = helper.getUserInput("enter a number");
                                String result = theDotCom.checkYourself(guess);
                                numOfGuesses++;
                                
                                if(result.equals("kill"))
                                {
                                        isAlive = false;
                                        System.out.println(numOfGuesses + " guesses");
                                }
                        }
                        
                }

        }

public class SimpleDotCom
{
        int[] locationCells;
        int numOfHits = 0;
        boolean[] hitCells = {false, false, false};//hitCells 배열을 선언하고 모두 false로 초기화해줍니다.
        
        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == locationCells[i]&& hitCells[i] == false)
                        {
                        //guess와 locationCells가 같고 맞춘 셀이 아닐때에만
                                result = "hit";
                                hitCells[i] = true;//hitCells을 true로 설정해줍니다
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}

import java.io.*;
//가져오기를 선언해줍니다. System.in을 사용하기 위함입니다.

public class GameHelper 
{
        public String getUserInput(String prompt)
        {
                String inputLine = null;
                System.out.println(prompt + " ");
                try
                {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0)
                                return null;
                        
                }
                catch (IOException e)
                {
                        System.out.println("IOException: " + e);
                        
                }
                return inputLine;
        }
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

//다른 클래스들은 동일합니다.

public class SimpleDotCom 
{
        int[] locationCells;
        int numOfHits = 0;
        
        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == -1)//만약에 사용자가 입력한 숫자가 -1이면 반복문을 빠져나갑니다.
                                break;
                        else if(guess == locationCells[i])
                        {
                                result = "hit";
                                locationCells[i] = -1;//맞췄을 경우 배열의 값을 -1로 바꿔줍니다.
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}


}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

//다른 클래스는 모두 같습니다.

import java.util.ArrayList;

public class DotCom 
{
        private ArrayList<String> locationCells;
        //private int numOfHits;
        //없어도 됩니다.
        
        //배열 대신 string이 들어가는 ArrayList를 사용합니다.
        
        public void setLocationCells(ArrayList<String> loc)
        {
                locationCells = loc;
        }
        
        public String checkYourself(String userInput)//새로 바뀐 인자명입니다.
        {
                String result = "miss";
                
                int index = locationCells.indexOf(userInput);
                //사용자가 추측한 위치가 ArrayList에 들어있는지 확인합니다. 들어있으면 인덱스 번호가, 그렇지 않으면 -1이 리턴됩니다.
                if(index >= 0)//인덱스가 0 이상이면
                {
                        locationCells.remove(index);//제거
                
                        if(locationCells.isEmpty())//목록이 비어있다면 닷컴이 죽었다는 것을 알 수 있다.
                                retult = "kill";        
                        else
                                result = "hit";
                }//바깥쪽 if문 끝
                
                return result;
        }//메소드 끝
}//클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

import java.util.*;

public class DotCom
{
        private ArrayList<String> locationCells;//DotCom의 인스턴스 변수 -셀위치
        private String name;//DotCom의 인스턴스 변수  -DotCom의 이름

        public void setLocationCells(ArrayList<String> loc)
        {
                locationCells = loc;//DotCom의 위치를 갱신합니다.
        }
        
        public void setName(String n)
        {
                name = n;//이름을 설정합니다
        }
        
        public String checkYourself(String userInput)
        {
                String status = "miss";//처음에 miss로 초기화합니다.
                int index = locationCells.indexOf(userInput);
                //ArrayList의 indexOf()메소드를 사용하여  사용자가 추측한 위치가 ArrayList에 들어있으면 인덱스를 그렇지 않으면 -1을 리턴합니다.
                if(index >= 0)
                {
                        locationCells.remove(index);
                        //ArrayList의 remove 메소드를 써서 그 항목을 지웁니다.
                        if(locationCells.isEmpty())//isEmpty를 써서 모든 위치를 맞췄는지 확인합니다.
                        {
                                status = "kill";
                                System.out.println("Ouch! You sunk " + name + "    : ( ");
                                //DotCom이 가라앉았다고 알려줍니다.
                        }
                        else
                        {
                                status = "hit";//아니면 hit
                        }
                }//if문 끝

        return status;
        }
        //miss or hit or kill을 리턴합니다.
}

import java.util.*;

public class DotComBust 
{
        private GameHelper helper = new GameHelper();//GameHelper객체를 생성합니다.
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();//DotCom객체로 이루어진 ArrayList를 만듭니다.
        private int numOfGuesses = 0;//추측한 숫자를 나타내는 변수를 선언하고 0으로 초기화합니다.
        
        private void setUpGame()//닷컴 객체 몇 개를 만들고 위치를 지정합니다.
        {
                DotCom one = new DotCom();
                one.setName("Pets.com");
                DotCom two = new DotCom();
                two.setName("eToys.com");
                DotCom three = new DotCom();
                three.setName("Go2.com");
                dotComsList.add(one);
                dotComsList.add(two);
                dotComsList.add(three);
                //DotCom 객체 세 개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다.
                
                System.out.println("Your goal is to sink three dot coms.");
                System.out.println("Pets.com, eToys.com, Go2.com");
                System.out.println("Try to sink them all in the fewest number of guesses");
                //사용자에게 간단한 게임 방법을 설명합니다.
                
                for(DotCom dotComToSet : dotComsList)//목록에 있는 각 DotCom에 대해 반복합니다.
                {
                        ArrayList<String> newLocation = helper.placeDotCom(3);
                        //DotCom의 위치를 지정하기 위한 보조 메소드를 호출합니다.
                        dotComToSet.setLocationCells(newLocation);
                        //이 DOtCom 객체의 세터 메소드를 호출하여 방금 보조 메소드에서 받아온 위치를 지정합니다.
                        
                }//for 순환문 끝
        }//setUpgame 메소드 끝
        
        private void startPlaying()
        {
                while(!dotComsList.isEmpty())//dotComsList가 비어있지 않으면 계속 반복합니다.
                {
                        String userGuess = helper.getUserInput("Enter a guess");
                        //사용자의 입력을 받습니다.
                        checkUserGuess(userGuess);
                        //checkUserGuess 메소드를 호출합니다.
                        
                }//while문 끝
                finishGame();
        }//startPlaying 메소드 끝

        private void checkUserGuess(String userGuess)
        {
                numOfGuesses++;//메소드가 호출되면 사용자 추측 횟수를 증가시킵니다.
                String result = "miss";//miss라고 가정합니다.
                
                for(DotCom dotComToTest : dotComsList)//목록의 모든 DotCom 객체에 대해 반복합니다.
                {
                        result = dotComToTest.checkYourself(userGuess);
                        //DotCom 객체에 사용자가 입력한 위치가 맞는지 또는 객체가 죽었는지 물어봅니다.
                        if(result.equals("hit"))//결과가 hit 이라면
                        {
                                break;//순환문을 빠져나옵니다.
                        }
                        if(result.equals("kill"))//결과가 kill이라면
                        {
                                dotComsList.remove(dotComToTest);//DotCom 목록에서 빼고
                                break;//순환문을 빠져나옵니다.
                        }
                }//for 문 끝
        }//checkUserGuess 메소드 끝
        
        private void finishGame()//게임 결과를 알려주는 메시지를 출력합니다.
        {
                System.out.println("All Dot Coms are dead! Your stock is now worthless");
                if(numOfGuesses <= 18)
                {
                        System.out.println("It only took you " + numOfGuesses + " guesses.");
                        System.out.println("You got out before your options sank");
                }
                else
                {
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
                        System.out.println("Fish are dancing with your options");
                }
        }

        public static void main(String[] args)
        {
                DotComBust game = new DotComBust();//DotComBust 객체를 만듭니다.
                game.setUpGame();//게임 객체에 게임을 설정하라는 명령을 내립니다.
                game.startPlaying();
                //게임 객체에서 주 게임 진행 순환문을 돌리라는 명령을 내립니다
        }

}


import java.io.*;
import java.util.*;

public class GameHelper
{
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int[] grid = new int[gridSize];
        private int comCount = 0;
        
        public String getUserInput(String prompt)
        {
                String inputLine = null;
                System.out.println(prompt +" ");
                try
                {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0)
                                return null;    
                }
                catch(IOException e)
                {
                        System.out.println("IOException: " + e);
                }
        
                return inputLine.toLowerCase();
                
        }
        
        public ArrayList<String> placeDotCom(int comSize)
        {
                ArrayList<String> alphaCells = new ArrayList<String>();//F6과 같은 좌표가 들어감
                String temp = null;//나중에 연결하기 위한 임시 String배열
                int[] coords = new int[comSize];//현재 후보 좌표
                int attempts = 0;//시도 횟수를 세기 위한 카운터
                boolean success = false;//적당한 위치를 찾았느지 표시하기 위한 플래그
                int location = 0;//현재 시작 위치
                
                comCount++;//n번째 닷컴
                int incr = 1;//수평 방향으로 증가시킬 값 설정
                if((comCount % 2)==1)//홀수 번째 닷컴인 경우
                {
                        incr = gridLength;//수직 방향으로 증가시킬 값 결정
                }
                
                while(!success & attempts++ < 200)//주 검색 순환문(32)
                {
                        location = (int) (Math.random() * gridSize);//임의 시작 위치를 구함
                        //System.out.print(" try " + location);
                        
                        int x = 0;//위치시킬 닷컴의 n번째 위치
                        success = true;//성공할 것으로 가정함
                        while(success && x < comSize)//닷컴이 들어갈 자리가 비었는지 확인
                        {
                                if(grid[location] == 0)//아직 사용하지 않았으면
                                {
                                        coords[x++] = location;//위치 저장
                                        location += incr;//다음 칸 확인
                                        if(location >= gridSize)//경계를 벗어난 경우
                                                success = false;//실패
                                        if(x > 0 & (location % gridLength == 0))//경계를 벗어난 경우(오른쪽)
                                                success = false;//실패
                                        else//이미 사용중인 경우
                                                //System.out.print(" used " + location)
                                                success = false;//실패
                                }
                        }
                        
                }//while 끝

        int x = 0;//위치를 알파벳 좌표로 바꿈
        int row = 0;
        int column = 0;
        
        while(x < comSize)
        {
                grid[coords[x]] = 1;//기본 그리드 좌표를 사용중 으로 표시
                row = (int) (coords[x] / gridLength);//행 값을 구함
                column = coords[x]&gridLength;//열 값을 구함
                temp = String.valueOf(alphabet.charAt(column));//숫자가 된 열을 알파벳으로 변환
                
                alphaCells.add(temp.concat(Integer.toString(row)));
                x++;
                //System.out.println("   coord  " + x + " = "  + alphaCells.get(x-1));
                //DotCom의 위치를 알려주는 메소드
                                
        }
        
        return alphaCells;
        }
        
}

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상속을 이용한다는 것은 공통적인 코드를 어떤 클래스에 넣은 다음, 다른 더 구체적인 클래스에 공통적인(더 추상적인)클래스가 상위클래스라는 것을 알려준다는 것. 즉 하위클래스가 상위클래스로부터 상속받는다, 하위클래스가 상위클래스를 확장한다고 얘기한다.
 * 다형성: 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다. 

*208p 클래스 계층 구조* _클래스로 구현_

{{{

class Animal
{
        String picture;
        Boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise()
        {
                //소리를 낼 때의 행동
        }

        void eat()
        {
                //그 동물이 음식을 접했을 때의 행동
        }

        void sleep()
        {
                //그 동물이 잠들어 있을 때의 행동
        }

        void roam()
        {
                //그 동물이 먹거나 자고 있지 않을 때의 행동
        }

}
class Feline extends Animal//Feline은 Animal을 상속받습니다.
{
        void roam()
        {
                //roam을 오버라이드합니다.
        }
}

class Canine extends Animal//Canine은 Animal을 상속받습니다.
{
        void roam()
        {
                //roam을 오버라이드합니다.
        }
}

class Lion extends Feline//Lion은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Tiger extends Feline//Tiger은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}



class Cat extends Feline//Cat은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Hiippo extends Animal//Hippo는 Animal을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Wolf extends Canine//Wolf는 Canine를 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Dog extends Canine//Dog는 Canine를 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 인자를 받지 않으며 부울 값을 리턴하는 것. 즉 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야함.
 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것. 오버로드된 메소드는 다형성과는 전혀 관계가 없다. 

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
1.
public class MonsterTestDrive {
	public static void main(String []args) {
		Monster [] ma= new Monster[3];
		ma[0]=new Vampire();
		ma[1]=new Dragon();
		ma[2]=new Monstere();
		for(int x=0;,x<3;x++) {
			ma[x].fighten(x);
		}
	}
}

class Monster {
	boolean frighten(int d) {
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster {
	boolean frighten (int x) {
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster {
	boolean frighten (int degree) {
		System.out.println("breath fire");
		return true;
	}
}

1번코드는 제대로 작동.
}}}

{{{
2.
public class MonsterTestDrive {
	public static void main(String []args) {
		Monster [] ma= new Monster[3];
		ma[0]=new Vampire();
		ma[1]=new Dragon();
		ma[2]=new Monstere();
		for(int x=0;,x<3;x++) {
			ma[x].fighten(x);
		}
	}
}

class Monster {
	boolean frighten(int x) {
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster {
	boolean frighten (int f) {
		System.out.println("a bite?");
		return 1; //Vampire의 리턴유형이 int여서 컴파일이 안됨
	}
}

class Dragon extends Monster {
	boolean frighten (int degree) {
		System.out.println("breath fire");
		return true;
	}
}
//컴파일이 안됨!
}}}

{{{
3.
public class MonsterTestDrive {
	public static void main(String []args) {
		Monster [] ma= new Monster[3];
		ma[0]=new Vampire();
		ma[1]=new Dragon();
		ma[2]=new Monstere();
		for(int x=0;,x<3;x++) {
			ma[x].fighten(x);
		}
	}
}

class Monster {
	boolean frighten(int x) {
		System.out.println("arrrgh");
		return false;
	}
}

class Vampire extends Monster {
	boolean frighten (int x) {
		System.out.println("a bite?");
		return true;
	}
}

class Dragon extends Monster {
	boolean frighten (int degree) {
		System.out.println("breath fire");
		return true;
	}
} //vampire클래스에서 monster 클래스의 frighten() 메소드를 오버라이드를 하지않아서
arrrgh
breath fire
arrrgh
라는 결과가 나온다.
}}}

{{{
4.
public class MonsterTestDrive {
	public static void main(String []args) {
		Monster [] ma= new Monster[3];
		ma[0]=new Vampire();
		ma[1]=new Dragon();
		ma[2]=new Monstere();
		for(int x=0;,x<3;x++) {
			ma[x].fighten(x);
		}
	}
}

class Monster {
	boolean frighten(int z) {
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster {
	boolean frighten (byte b) //int가 아닌 byte로 인자를 받아서 {
		System.out.println("a bite?");
		return true;
	}
}

class Dragon extends Monster {
	boolean frighten (int degree) {
		System.out.println("breath fire");
		return true;
	}
}

//vampire클래스에서 monster 클래스의 frighten() 메소드를 오버라이드를 하지않아서
arrrgh
breath fire
arrrgh
라는 결과가 나온다.
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100% 추상클래스. 자바에서 정말 필수불가결한 부분. 
 * 다형성: '여러형태'를 의미. 
 * 추상 클래스: 클래스 선언시 앞에 abstract만 붙이면 됨. 추상클래스란, 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스를 의미. 반드시 확장해야하는 클래스를 의미. 
 * 추상 메소드: 반드시 오버라이드해야하는 메소드를 의미. 중괄호없이 세미콜론을 써서 선언을 끝냄. 추상 메소드를 만들 때는 클래스도 반드시 추상클래스여야함. 
 * 다중 상속: 상위클래스를 두 개 사용하는 접근법. 하지만 여기에는 '죽음의 다이아몬드'라고 알려져 있는 문제가 있다. 

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객체가 사는 곳이다. 인스턴스 변수는 객체 안에 살기 때문에 즉 인스턴스 변수가 힙 안에 살고 있는 것이다.
 * 스택에서의 변수: 스택은 메소드 호출과 지역 변수가 사는 곳이다. 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스, 즉 리모컨)만 스택에 들어간다. 객체 자체는 힙 안에 있습니다. (메소드 매개변수도 지역 변수에 포함)
 * 생성자: 객체를 생성할 때 실행되는 코드가 들어있다. 즉 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있다. 우리가 직접 만들지 않아도 된다.
 * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException 이 생긴다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체를 지원하는 역할을 하며 항상 객체와 함께 하나. 객체에 상태가 없으면 쓸모가 없는데 그 상태가 바로 인스턴스변수에 저장된 값이다. 객체와 함께 힙에 산다. 정확히는 객체 안에 삼. 객체가 가비지 컬렉터에 의해 처리된다면 인스턴스 변수도 없어지고 만다. 
 * 지역 변수: 객체가 중요한데 행동이 없으면 쓸모가 없다. 거기서 행동이란 것은 메소드에 들어있는 알고리즘이며 이 알고리즘을 작동시키려면 메소드에 지역변수가 있어야 한다. 지역 변수는 인스턴스 변수에 비해서 수명이 짧다. 지역 변수는 자신의 프레임이 스택 맨 위로 올라갈 때 까지 아무것도 하지 않는다. 인스턴스가 변수가 들어있는 객체를 지역 변수에서만 참조할 수도 있다

*302p 5분 미스터리* _구현후 주석달기_

{{{

import java.util.*;
class V2Radiator
{
        V2Radiator(ArrayList<SimUnit> list)
        {
                for(int x = 5; x < 5 ; x++)
                {
                        list.add(new SimUnit("V2Radiator"));//list에 SimUnit 객체를 더합니다.
                }
        }
}

class V3Radiator //extends V2Radiator
{
        V3Radiator(ArrayList<SimUnit> lglist)
        {
                //super(lglist);
                for(int g = 0; g < 10 ; g++)
                {
                        lglist.add(new SimUnit("V3Radiator"));//lglist에 SimUnit객체를 더합니다.
                }
        }
}

class RetentionBot
{
        RetentionBot(ArrayList<SimUnit> rlist)
        {
                rlist.add(new SimUnit("Rention"));//rlist에 SimUnit객체를 더합니다.
        }
}

public class TestLifeSupportSim 
{
        public static void main(String[] args)
        {
                ArrayList<SimUnit> aList = new ArrayList<SimUnit>();//ArrayList를 만듭니다.
                V2Radiator v2 = new V2Radiator(aList);//V2Radiator객체 생성.
                V3Radiator v3 = new V3Radiator(aList);//V3Radiator객체 생성.
                for(int z = 0 ; z < 20 ; z++)
                {
                        RetentionBot ret = new RetentionBot(aList);//RententionBot객체 생성.
                }
        }
}

class SimUnit
{
        String botType;//문자열 선언
        SimUnit(String type)
        {
                botType = type;//대입
        }
        int powerUse()
        {
                if("Retention".equals(botType))
                {
                        return 2;                       
                }
                else
                {
                        return 4;
                }
        }
}

/* 톰은 V2Radiator 클래스의 생성자에서 ArraylList를 받아들인다는 점에 주목하였다. V3Radiator를 호출할 때마다 super()을 통해 V2Radiator 생성자를 호출할 때 ArrayList를 전달하게 됩니다.
따라서 불필요하게 V2Radiator의 SimUnit다섯 개가 추가로 만들어집니다. 톰이 맞았다면 총 전력 소모량이 사라가 예상한 비율대로 100이 아니라 120이 된다고 예상했을 것입니다. 
모든 Bot 클래스에서 SimUnit을 만들기 때문에 SimUnit 클래스에 SimUnit이 생성될 때마다 메시지를 출력하는 생성자를 만들면 문제를 더 빨리 찾을 수 있습니다.*/

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않은 메소드. 클래스만 있어도 가능. 정적메소드를 호출할 때는 클래스명을 사용.
 * 정적 메소드를 선언하는 방법: static 이라는 키워드를 사용하면 클래스의 인스턴스 없이 메소드를 실행할 수 있다.
 * static final: final로 지정한 변수는 일단 초기화되고나면 절대 그 값을 바꿀 수 없다. 즉 static final 로 선언한 변수는 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지한다. 상수의 변수명은 모두 대문자로 쓴다.
 * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException 이 생긴다. (9장 참조)
 * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능.
 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 정적 임포트를 활용하여 타이핑을 적게 해보자는 개념. 잘못 사용하면 코드의 가독성이 크게 떨어질 수 있음.

*339p Calendar* _구현후 주석달기_

{{{
import java.util.*;
public class Calendercheck
{
        public static void main(String[] args)
        {
                Calender c = Calender.getInstance();
                c.set(2004,0,7,15,40);//시각을 2004년 1월 7일 15:40 으로 설정
                long day1 = c.getTimeInMillis();//1970년 1월1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴
                day1 += 1000 * 60 * 60;
                c.setTimeInMillis(day1);//한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
                System.out.println("new hour" + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35);//35일을 더합니다.
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35);//35일 뒤로 넘깁니다. 하지만 달은 바뀌지 않습니다.
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1);//날짜를 1로 설정합니다.
                System.out.println("set to 1 " + c.getTime());
                
        
        }
}

}}}

*342p 집중토론* _요약_ //지역변수라고 되있길래 정적변수로 수정하고 했어요~

 * 인스턴스 변수: 인스턴스마다 하나씩 있다.
 * 정적 변수: 상수. 인스턴스마다 하나씩 있는 게 아니고 클래스마다 하나씩 있다.(메모리 절약). 한 클래스에 속하는 모든 인스턴스에 의해서 공유된다. 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class StaticSuper{

	static { //ststic 메소드. 딱 한번 실행됨.
	System.out.println("super static block");
	}

	StaticSuper() { //StaticSuper는 생성자이므로 반드시 ()가 있어야함.
	System.out.println("super constructor");
	}
}

public class StaticTests extends StaticSuper { //StaticTests 는 StaticSuper을 확장함.

	static int rand; //static 변수.

	static { //static 메소드.
	rand=(int_ (Math.random()*6);
	System.out.println("static block " + rand);
	}

	StaticTests(){ //생성자.
	System.out.println("constructor");
	{

	public static void main(String [] args) {
	System.out.println("in main");
	StaticTests st = new StaticTests (); //StaticTests 객체 생성.
	}
}
}}}
컴파일 결과
{{{
%java StaticTests
super static block
static block 3
in main
super constructor
constructor
}}}
= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}