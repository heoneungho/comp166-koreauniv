#summary 이성호천재
#labels i

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong// 클래스 선언
  {
  public static void main (String[] args) // 메소드 선언
    {
    int beerNum = 99; // 맥주의 수를 99개로 설정
    String word = "bottles"; // 복수형
       while(beerNum > 0) // 맥주가 하나 이상일때
      {
      System.out.println(beerNum + " " + word + " of beer on the wall");
      System.out.println(beerNum + " " + word + " of beer.");
      System.out.println("Take one down.");
      System.out.println("Pass it around."); // 출력
      beerNum = beerNum -1; // 와일문을 한바퀴 돌때마다 맥주갯수 하나씩 감소

      if(beerNum == 1) // 맥주의 갯수가 하나일때
       {
      word = "bottle"; // 단수병(한병인 경우)
      } // 이 if문의 위치를 바꿔주어야 아래쪽 에서도 갯수가 1일때부터 단수로 적용

       if(beerNum > 0) // 갯수가 하나 이상일때
      {
      System.out.println(beerNum + " " + word + " of beer on the wall");
      }
      else // 갯수가 0개일떄
       {
      System.out.println("No more bottles of beer on the wall");
      } // else문 끝
       } // while 순환문 끝
    } // main 클래스 끝
  } // 클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
  public static void main ( String[] args) {
  // 세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
  String[] wordListOne = {"dog", "cat", "eagle", "tiger", "elephant"};
  String[] wordListTwo = {"first", "second", "third", "fourth", "fifth"};
  String[] wordListThree = {"love", "like", "become", "hate", "favor"};

  // 각 단어 목록에 단어가 몇개씩 들어있는지 확인합니다.
  int oneLength = wordListOne.lengh;
  int twoLength = wordListTwo.lengh;
  int threeLength = wordListThree.lengh;

  // 난수 세 개를 발생시킵니다.
  int rand1 = (int) (Math.random() * oneLength);
  int rand2 = (int) (Math.random() * twoLength);
  int rand3 = (int) (Math.random() * threeLength);

  // 이제 구문을 만듭니다.
  String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

  //구문을 출력합니다.
  System.out.println("What we need is a " + phrase);
  }
  }
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
1. 프로그램을 실행시킨다. 

2. 보안 관련 작업을 처리한다.

3. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 건드렸는지 확인한다.
 * 컴파일러:
1. 파일을 준다.

2. 문법이 맞았는지 틀렸는지 확인한다.

3. 변수에 이상한 유형의 데이터를 저장하지 못하게 한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

A
{{{
class Exercise1b // 클래스 선언
  {
  public static void main(String [] args) // 메소드 선언
  {
  int x = 1 ; // x를 1로 선언
  while(x<10) // x가 10보다 작을때
  {
    x = x + 1 // while문 한바퀴 돌때마다 x가 1씩 증가, 무한순환을 막아줌.
    if(x>3) // x가 3보다 클때
     {
    System.out.println("big x"); // 출력
     }
  }
  }
  }
}}}

B
{{{
class Exercise1b // 클래스를 정의하지 않으면 컴파일할 수 없다.
  {
  public static void main(String [] args) // 메소드 선언
  {
  int x = 5; // x를 5로 선언
  while (x > 1) // x가 1보다 클동안
  {
    x = x - 1; // while문 한바퀴 돌때 x가 1씩 줄어든다
    if(x < 3) // x가 3보다 작을때
    {
    System.out.println("small x"); // 출력
    }
  }
  }
  }
}}}

C
{{{
class Exercise1b // 클래스 선언
  {
  public static void main(String [] args) // while문이 메소드 안에 있지 않으면 컴파일 되지 않는다.
  {
  int x = 5; // x를 5로 선언
  while ( x > 1) // x가 1보다 클 동안
  {
  x = x - 1; // x가 1씩 줄어든다
  if ( x < 3) // 만약 x가 3보다 작다면
  {
  System.out.println("small x"); // 출력
  }
  }
  }
  }
}}}

= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터)를 나타낸다.
 * 메소드: 객체에서 할 수 있는 일.
 * 클래스: 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할.
 * 테스트용 클래스: 클래스를 테스트하기 위한 코드.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume
 * 메소드: channelup(), channeldown(), volumeup(), volumedown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자 : " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자 : " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자 : " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자 : " + guessp4);
			
			if(guessp1 == targetNumber){
				p1isRight = true;
			}
			
			if(guessp2 == targetNumber){
				p2isRight = true;
			}
			
			if(guessp3 == targetNumber){
				p3isRight = true;
			}
			
			if(guessp4 == targetNumber){
				p4isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight){
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수 : " + p1isRight);
				System.out.println("2번 선수 : " + p2isRight);
				System.out.println("3번 선수 : " + p3isRight);
				System.out.println("4번 선수 : " + p4isRight);
				System.out.println("게임 끝.");
				break;
				
			}else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			} // if/else 부분 끝
		} // 순환문 끝		
	} // 메소드 끝
} // 클래스  끝

public class Player {
	int number = 0; // 찍은 숫자를 저장할 변수
	
	public void guess(){
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자 : " + number);
	}
}

public class GameLauncher {
	public static void main (String[] args){
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class TapeDeck { // 클래스 선언
	boolean canRecord = false; // 참거짓변수 지정
	void playTape() { // 메소드 선언
		System.out.println("tape playing"); // 출력
	}
	void recordTape() { // 메소드 선언
		System.out.println("tape recording"); // 출력
	}
}

class TapeDeckTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		TapeDeck t = new TapeDeck(); // 템플릿(클래스)가 있으니 실제 객체를 만들어야 한다.
		t.canRecord = true; // 참거짓변수에 참을 입력
		t.playTape(); // t 라는것에 대해 playTape 메소드를 실행한다.
		
		if(t.canRecord == true) { // 만약 ~라면
			t.recordTape(); // t 라는것에 대해 recordTape 메소드를 실행한다.
		}
	}
}

B

class DVDPlayer { // 클래스 선언
	boolean canRecord = false; // 참거짓변수 지정
	void recordDVD() { // 메소드 선언
		System.out.println("DVD recording"); // 출력
	}
	void playDVD() { // 메소드 선언, 아래의 d.palyDVD를 컴파일 시키기 위해 필요
		System.out.println("DVD playing"); // 출력
	}
}

class DVDPlayerTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		DVDPlayer d = new DVDPlayer(); // 실제 객체를 만든다.
		d.canRecord = true; // 변수에 참을 입력
		d.playDVD(); // d 라는 것에 대해 playDVD메소드 실행
		if (d.canRecord == true) { // 만약 ~라면
			d.recordDVD(); // d 라는 것에 대해 recordDVD메소드 실행
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
- 원시변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다. 그리고 객체 레퍼런스에는 개체에 대한 레퍼런스가 들어간다.


*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
public class Dog {
	String name;
	public static void main (String[] args){
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[10];
		//  그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = new Dog();
		myDogs[3] = new Dog();
		myDogs[4] = new Dog();
		myDogs[5] = new Dog();
		myDogs[6] = new Dog();
		myDogs[7] = new Dog();
		myDogs[8] = new Dog();
		myDogs[9] = dog1;
		
		// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
		myDogs[0].name = "성호";
		myDogs[1].name = "정곤";
		myDogs[2].name = "서연";
		myDogs[3].name = "승태";
		myDogs[4].name = "채원";
		myDogs[5].name = "진범";
		myDogs[6].name = "능호";
		myDogs[7].name = "규원";
		myDogs[8].name = "영";
		
		//myDogs[9]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름 : ");
		System.out.println(myDogs[2].name);
		
		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x + 1;
		}
	}

	public void bark() {
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class Books { // 클래스 선언
	String title; // 문자열 선언
	String author; // 문자열 선언
}
class BooksTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		Books [] myBooks = new Books[3]; // 3칸짜리 배열을 만든다.
		int x = 0;
		myBooks[0] = new Books(); //객체를 만든다.
		myBooks[1] = new Books(); //
		myBooks[2] = new Books(); //
		myBooks[0].title = "The Grapes of Java"; // 타이틀을 새긴다.
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob"; // 작가를 새긴다.
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		while ( x < 3) {
			System.out.print(myBooks[x].title); // 출력한다
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1; // 다음책으로 넘긴다.
		}	
	}
}

B

class Hobbits { // 클래스 선언
	String name; // 문자열 선언
	public static void main(String [] args) { // 메소드 선언
		Hobbits [] h = new Hobbits[3]; // 3칸짜리 배열을 만든다
		int z = -1; // z 의 값 선언,  배열의 인덱스는 0부터 시작하므로 아래칸을 맞추기 위해
				while(z < 2) { // ~하는동안
					z = z + 1; // z 값이 하나씩 증가
					h[z] = new Hobbits(); // 객체를 하나씩 만들어준다.
					h[z].name = "bilbo"; // 모든 객체의 이름을  bilbo 로 해둔다.
					if (z == 1) {
						h[z].name = "frodo"; // 객체의 이름을 바꾼다.
					}
					if (z == 2) {
						h[z].name = "sam"; // 객체의 이름을 바꾼다.
					}
					System.out.print(h[z].name + " is a "); // 출력
					System.out.println("good Hobbit name");
				}
	}
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 것은 순환문을 한바퀴 돌 때마다 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체를 버리게 된다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 객체의 인스턴스 변수 주변에 방어막 같은 것을 만들어서 아무도 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다.
 * 게터와 세터: 게터는 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰이고 세터는 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.
 * 인스턴스 변수 vs 지역 변수:  인스턴스 변수는  클래스 내에서 선언되고 지역 변수는 메소드 내에서 선언된다. 지역 변수는 사용하기 전에 반드시 초기화 해야 한다.
 
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;
	
	void bark(){
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}
class DogTestDrive {
	
	public static void main (String[] args) {
		Dog one = new Dog ();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class XCopy { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		int orig = 42; // orig 에 값을 대입한후 선언한다.
		XCopy x = new XCopy(); // 객체를 만든다후 선언한다
		int y = x.go(orig); // y 에 값을 대입한다.
		System.out.println(orig + " " + y); // 출력
	}
	int go(int arg){ // go 함수를 만든다.
		arg = arg * 2;
		return arg; // 원래값에 2를 곱한값을 돌려보낸다.
	}
}
// 컴파일이 실행 된다. 자바에서는 값으로 전달하므로, 원래 orig 의 값은 바뀌지 않는다.

B

class Clock{ // 클래스 선언
	String time; // 문자열 선언
	void setTime(String t){ // 메소드 선언
		time = t; // t를 time 에 대입
	}
	String getTime(){ // time 시간을  밖으로 내보낸다. 
		return time; // 게터 메소드에는 반드시 리턴유형이 있어야 한다.
	}
}
class ClockTestDrive{ // 클래스 선언
	public static void main(String [] args){ // 메소드 선언
		Clock c = new Clock(); // 객체를 만든다.
		c.setTime("1245"); // 시간을 넣는다.
		String tod = c.getTime(); //  tod 값에 getTime값을 넣는다.
		System.out.println("time; " + tod); // 출력
	}
}
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
1. 조금씩, 하지만 자주 발표한다.

2. 사이클을 반복해서 돌리면서 개발한다.

3. 스펙에 없는 것은 절대 집어넣지 않는다.

4. 테스트 코드를 먼저 만든다.

5. 항상 정규 일과 시간에만 작업한다.

6. 기회가 생기는 족족 언제 어디서든 코드를 개선한다.

7. 모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다.

8. 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만든다.

9. 모든 일을 단순하게 처리한다.

10. 두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업한다.


*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
import java.io.*;
public class GameHelper{
	public String getUserInput(String prompt){ // 유저가 입력하는 메소드
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); // 저장했다가 빼가는 버퍼
			inputLine = is.readLine();
			if(inputLine.length() == 0) return null;
		} catch(IOException e){ // 예외발생하면 캐치부분으로 가라.
			System.out.println("IOException: " + e);
		}
		return inputline;
	}
}

public String checkYourself(String stringGuess){
	int guess = Integer.parseInt(stringGuess); // String 을 int 로 변환합니다.
	String result = "miss"; // 리턴할 결과를 저장할 변수를 만듭니다. 기본값은 "miss"로 집어넣습니다.
																	//  즉, 못 맞추는 것을 기본으로 가정합니다.
	for(int cell : locationCells){ // 배열에 들어있는 각 원소(객체의 각 위치 셀)에 대해 반복합니다.
		if (guess == cells){ // 사용자가 추측한 값을 배열에 들어있는 원소(셀)와 비교합니다.
			result = "hit"; // 맞음
			numOfHits++;
			break; // 순환문을 빠져나옵니다. 다른 셀은 확인하지 않아도 됩니다.
		}
	}
	if(numOfHits == locationCells.length){
		result = "kill"; // 순환문 밖으로 나왔습니다. 하지만 그 객체가 죽었는지(세 번 맞았는지) 확인해 보고, 그 경우에는 result라는 String을 "kill"로 바꿉니다.
	}
	System.out.println(result); // 사용자에게 결과를 보여줍니다 ("hit"나 "kill"로 바뀌지 않았다면 "miss"가 출력됩니다.).
	return result; // 이 메소드를 호출한 메소드로 결과를 리턴합니다.
}

public class SimpleDotcomTestDrive{
    public static void main(String[] args){
        SimpelDotCom dot = new SimpleDotCom(); // Simple DotCom클래스의 인스턴스를 만듭니다.

        int[] locations = {2, 3, 4}; // 닷컴의 위치를 나타내기 위한  int 배열을 만듭니다.(0에서 6까지의 숫자 가운데 연속된 정수 세 개)
        dot.setLocationCells(locations); // 닷컴에 대해 세터 메소드를 호출합니다.

        String userGuess = "2"; // 사용자가 추측한 위치 역할을 할 가짜 값을 만듭니다.
        String result = dot.checkYourself(userGuess); // 닷컴 객체에 대해 checkYourself()메소드를 호출하고 그 메소드에 가짜 값을 전달합니다.
                }
}

public class SimpleDotCom{
	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs){ // 위치를 설정하는 메소드입니다.
		locationCells = locs;
	}
	
	public String checekYourself(String stringGuess){ // 입력한 stringGuess를 checkYourself에 넘깁니다.
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length;i++){
			if (guess == locationCells[i]){
				result = "hit"; // 맞았을 때
				numOfgits++;
				break;
		}
	}
	
	if(numOfHits == locationCells.length){ // Hits 수와 LocationCells의 길이가 같을때
		result = "kill"; // 결과값은 kill
	}
	System.out.println(result);
	return result;
}
	
public static void main(String[] args){
	int numOfGuesses = 0; // 사용자가 추측한 횟수를 추적하기 위한 변수를 만듭니다.
	GameHelper helper = new GameHelper(); // 일단 사용자로부터 입력을 받기 위한 메소드가 들어있는 특별한 클래스가 있다고 생각합시다.
	
	SimpleDotCom theDotCom = new SimpleDotCom(); // 닷컴 객체를 만듭니다.
	int randomNum = (int)(Math.random() * 5); // 첫번째 셀 위치를 정하기 위한 난수를 만들고 그 값을 써서 셀 위치 배열을 만듭니다.
	
	int[] locations = {randomNum, randomNum+1, randomNum+2};
	theDotCom.setLocationCells(locations); // 닷컴의 위치를 지정합니다.(배열 사용)
	boolean isAlive = true; // 닷컴이 살아있는 지 추적하기 위한 부울 변수를 만들고
	
	while(isAlive == true){ // 아직 살아있으면 계속 반복합니다.
		String guess = helper.getUserInput("enter a number"); // 사용자가 입력한  String 을 받아옵니다.
		String result = theDotCom.checkYourself(guess); // 닷컴 객체를 통해 추측한 값이 맞는지 확인합니다. 리턴된 결과는 String에 저장합니다.
		numOfGuesses++; // 추측 횟수를 증가시킵니다.
		if(result.equals("kill")){ // "kill"이면 isAlove를 false로 설정합니다.(이렇게 해야 순환문을 벗어날 수 있습니다.)
			isAlive = false; // 그리고 사용자가 추측한 횟수를 출력합니다.
			System.out.println(numOfGuesses + " guesses");
		}
	}
}
}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
import java.io.*;public class GameHelper { // 게임헬퍼 클래스
        public String getUserInput (String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                        try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length() == 0)
                                 return "a";
                } catch(IOException e){
                        System.out.println("IOException: " + e);
                }
                return inputLine;
                }
        }

public class SimpleDotComTestDrive {
        public static void main(String[] args){
                                                int numOfGuesses=0;
                                GameHelper helper = new GameHelper();
                                SimpleDotCom theDotCom = new SimpleDotCom();
                                int randomNum = (int) (Math.random() * 5);
                                int[] locations = {randomNum, randomNum+1, randomNum+2};
                                boolean[] hitCells = new boolean[3]; // 새로 배열을 만들어 줍니다. 불린배열로 만듭니다.
                                theDotCom.sethitCells(hitCells);
                                theDotCom.setLocationCells(locations); // 닷컴 클래스로 새로만든 배열을 배열을 넘겨줍니다
                                boolean isAlive = true;
                                                while(isAlive == true){
                                                        String guess = "a";
                                                        while(guess == "a") // 입력값이 없는 경우를 대비하여 getUserInput 메소드에서의 리턴값에 따라 다시 입력값을 받도록 함
                                                        {
                                                        guess = helper.getUserInput("enter a number");
                                                        }
                                                        String result = theDotCom.checkYourself(guess);
                                                        numOfGuesses++;
                                                        if(result.equals("kill")){
                                                                isAlive = false;
                                                                System.out.println(numOfGuesses + "guesses");
                                                        }
                                                }
        }
}

public class SimpleDotCom{
        int[] locationCells;
        boolean[] hitCells = new boolean[3];
                int numOfHits = 0;
                public void setLocationCells(int[] locs){
                                locationCells = locs;
                }
                public void sethitCells(boolean[] shc){ //새로 만든 메소드로 불린 배열을 받아옵니다
                        hitCells = shc;
                }
                public String checkYourself(String stringGuess){
                        int guess = Integer.parseInt(stringGuess);
                        String result = "miss";
                        for(int i = 0; i < locationCells.length; i++){
                                if(guess == locationCells[i] && hitCells[i]!=true){ //이미 맞춘 배열인지 확인합니다
                                result = "hit";
                                numOfHits++;
                                hitCells[i] = true; // 맞춘 배열이기때문에 불린 값을 트루로 바꿔줍니다
                                break;
                        }
                        }
                        if (numOfHits == locationCells.length){
                        result = "kill";
                        }
                        System.out.println(result);
                        return result;
                        }
}
}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
import java.io.*;
class GameHelper{ // 게임헬퍼 클래스 선언
        public String getUserInput(String prompt){
                String inputLine=null;
                System.out.print(prompt+" ");
                try{
                        BufferedReader is=new BufferedReader(new InputStreamReader(System.in));
                        inputLine=is.readLine();
                        if(inputLine.length()==0) return null;
                }catch(IOException e){
                        System.out.println("IOexception: "+e);
                }
                return inputLine;

        }
}

public class SimpleDotCom { // 닷컴 클래스 선언
        int[] locationCells;
        int numOfHits=0;
                public void setLocationCells(int[] locs){
                locationCells=locs;
        }
        public String checkYourself(String stringGuess){ // 히트상태인지 체크한다
                int guess=Integer.parseInt(stringGuess);
                String result="miss";
                for(int i=0;i<locationCells.length;i++){
                        if(guess==locationCells[i]){
                                result="hit";
                                locationCells[i]=-1;
                                numOfHits++;
                                break;
                        }
                }
                if(numOfHits==locationCells.length)result="kill";
                System.out.println(result);
                return result;
        }
}

class SimpleDotComTestDrive{ // 테스트클래스 선언
        public static void main(String [] args){
                int numOfGuesses=0;
                                GameHelper helper= new GameHelper();
                                SimpleDotCom theDotCom = new SimpleDotCom(); // 닷컴객체 생성
                                int randomNum= (int)(Math.random()*5);
                                int [] locations={randomNum,randomNum+1,randomNum+2};
                                theDotCom.setLocationCells(locations);
                                boolean isAlive=true;
                                while(isAlive==true){
                                        String guess = helper.getUserInput("enter a number");
                                        String result= theDotCom.checkYourself(guess);
                                        numOfGuesses++;
                                if(result.equals("kill")){
                                        isAlive=false;
                                        System.out.println(numOfGuesses + "guesses");
                                }
                                }
        }
}
}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList;

public class GameHelper {
    public String getUserInput (String prompt){
            String inputLine = null;
            System.out.print(prompt + " ");
                    try{
                    BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                    inputLine = is.readLine();
                    if (inputLine.length() == 0)
                             return "a";
            } catch(IOException e){
                    System.out.println("IOException: " + e);
            }
            return inputLine;
            }
    }
class SimpleDotComTestDrive{
	public static void main(String[] args)  {
		SimpleDotCom dot= new SimpleDotCom();
		int[] locations = {2,3,4};
		dot.setLocationCells(locations);
		String userGuess = "2";
		String result = dot.checkYourself(userGuess);
		}
	}

public class DotCom {
	private ArrayList<String> locationCells;
	public void setLocationCells(ArrayList<String> loc){
		locationCells = loc;
		}
	public String checkYourself(String userInput){
		String result = "miss";
		int index = locationCells.indexOf(userInput); // 사용자가 추측한 위치가 들어있는지 확인. 있으면 배열수 없으면 -1
		if (index >= 0) {
			locationCells.remove(index);
			if(locationCells.isEmpty()){ // 목록이 비면 닷컴이 가라앉았다.
				result = "kill";
				}
			else{
				result = "hit";
				}
			} 
		return result;
		}
	}

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
import java.io.*;
import java.util.*;

class GameHelper{ // GameHelper 클래스 선언.
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int [] grid = new int[gridSize];
	private int comCount = 0;
	public String getUserInput(String prompt)
			throws IOException{
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length()==0)
				return null;
			}catch(IOException e) {
				System.out.println("OException: " + e);
				}
		return inputLine.toLowerCase();
		}
	
	public ArrayList<String>placeDotCom(int comSize){
		ArrayList<String> alphaCells = new ArrayList<String>(); 
	String [] alphacoords = new String[comSize];
	String temp = null;                // 나중에 연결하기 위한 임시 String 배열을 생성합니다.
	int [] coords = new int[comSize];                // 현재 후보 좌표입니다
	.                int attempts = 0;                // 시도 횟수를 세기위한 카운터입니다.
	boolean success = false;                // 적당한 위치를 찾았는지 표시하기 위한 플래그입니다.
	int location = 0;                // 현재 시작 위치를 0으로 설정합니다.
	comCount++;     
	int incr = 1;  // 수직방향으로 증가시킬 값을 설정합니다. 
	if ((comCount % 2) == 1)                         // 홀수 번째 닷컴인 경우(수직으로 배치합니다.)  
		{
			incr = gridLength; // 수직 방향으로 증가시킬 값을 설정합니다.
		}
	while ( !success & attempts++ < 200)             
	{
			location = (int) (Math.random() * gridSize);  // 임의의 시작위치를 정한다.  
			System.out.print("try" + location);                        int x = 0;                      
			success = true;                      
			while (success && x < comSize)                              
				{
				if (grid[location] == 0)
				}
				{
					coords[x++] = location;                                      
						{
						success = false;
						}
					if (x>0 & (location % gridLength == 0))  		
					{
						success = false;
						// 실패.
						}
					} else {
						System.out.print("used "+location);
						success = false;
						//실패. 
						}
					} 
	}
	
	int x = 0;                // 위치를 알파벳 좌표로 바꿉니다.
	int row = 0; 
	int column = 0;        
	System.out.println(" |n");     
	while (x < comSize)       
	{                    
		grid[coords[x]] = 1;                        // 기본 그리드 좌표를 사용합니다.  
		row = (int) (coords[x] / gridLength);                        // 행 값을 구합니다.   
		column = coords[x] % gridLength;                        // 열 값(숫자)을 구합니다.           
		temp = String.valueOf(alphabet.charAt(column));                        // 숫자로 된 열을 알파벳으로 변환합니다.
		alphaCells.add(temp.concat         
				(Integer.toString(row)));   
		x++;              
		System.out.print(" coord " + x + " = " +   
		alphaCells.get(x-1));                        // 닷컴의 위치를 알려주는 코드입니다.   
		}               
	System.out.println(" d2|n?");      
	return alphaCells;  
	}
}

class DotCom{       
	private ArrayList<String> locationCells;  
	private String name;        // DotCom의 인스턴스 변수 
	// - 셀위치가 들어있는 ArrayList     
	//  - DotCom의 이름    
	public void setLocationCells(ArrayList<String> loc)       
	{       
		locationCells = loc;   
		}        // DotCom의 위치를 갱신하는 세터 메소드
	// placeDotCom()메소드에서 제공하는 무작위로 만든  위치 
	public void setname(String n) 
	{            
		name = n;  
		}        // 기초적인 세터 메소드입니다.  
	public String checkYourself(String userInput)    
	{                
		String status = "miss";   
		int index = locationCells.indexOf(userInput);                /* ArrayList의 indexOf()메소드를 쓰고 있습니다. 사용자가 추측한                  위치가 ArrayList에 들어있으면 indexOf()에서                  그 항목의 인텟스를 리턴합니다.                 그렇지 않으면 -1을 리턴합니다. */
		if(index >=0)          
		{                    
			locationCells.remove(index);                        // ArrayList의 remove메소드를  써서 그 항목을 지웁니다.   
			if (locationCells.isEmpty())                                // isEmpty()메소드를 써서 모든 위치를 맞췄는지 확인합니다.   
                    {                          
				status = "kill";                     
				System.out.println("Ouch! You sunk" +   name + " : ( ");       
				// 닷컴이 가라 앉았음을 알려줍니다.          
				}else {                 
					status = "hit"; 
					}              
			} // if문 종료.               
		return status;       
		// 'miss','hit'또는 'kill'을 리턴합니다.
		} // method 종료.} // class 종료.
	
	class DotComBust {        // 사용할 변수를 선언하고 초기화 합니다.    
		private GameHelper helper;  
		private ArrayList<DotCom> dotComsList;   
		private int numOfGuesses;        /* DotCom객체로 이루어진  ArrayList를 만듭니다.   
		     (즉 DotCom[]이 DotCom객체들이 들어있는 배열을 뜻하는 것과         마찬가지로  ArrayList (DotCom)을 DotCom객체들이 들어        있는 ArrayList라고 생각하면 됩니다.) */ 
		public DotComBust()  {
			helper = new GameHelper();  
			dotComsList = new ArrayList<DotCom>();   
			numOfGuesses = 0;  
			}   
		private void setUpGame()        // 우선 닷컴 객체 몇 개를 만들고 위치를 지정합니다.    
		{             
			DotCom one = new DotCom();    
			one.setname("Pets.com");         
			DotCom two = new DotCom();   
			two.setname("eToys.com");        
			DotCom three = new DotCom();    
			three.setname("Go2.com");             
			dotComsList.add(one);          
			dotComsList.add(two);             
			dotComsList.add(three);    
			// DotCom 객체세개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다. 
			System.out.println("Your goal is to sink three " +  "dot coms.");   
			System.out.println("Pets.com, eToys.com, Go2.com");    
			System.out.println("Try to sink them all in " +  "the fewest number of guesses");  
			// 사용자에게 간단한 게임 방법을 설명합니다.          
			for (DotCom dotComToset : dotComsList)              
				// 목록에 있는 각 DotCom에 대해 반복합니다.         
				{             
				ArrayList<String> newLocation = helper.placeDotCom(3);  
				// DotCom의 위치를 지정하기 위한 보조 메소드를 호출합니다.    
				dotComToset.setLocationCells(newLocation);      
				// 이 DotCom 객체의 세터메소드를 호출하여 방금 보조 메소드에서  받아온 위치를 지정합니다.   
				} // for문 종료.     
			} // setUpgame method 종료.    
		private void startPlaying() throws IOException       
		{             
			while (!dotComsList.isEmpty())                        // DotCom목록이 비어있지 않으면 (1은 부정(NOT)을 의미 합니다. dotComList.isEmpty() == false와 똑같습니다.)  
				{                 
				String userGuess       
				= helper.getUserInput("Enter a guess");   
				// 사용자 입력을 받습니다             
				checkUserGuess(userGuess);          
				// checkUserGuess 메소드를 호출합니다.      
				} // while문 종료.             
			finishGame();             
			// finishGame() 메소드를 호출합니다
        } // startPlaying method 종료.
		private void checkUserGuess(String userGuess) 
		{
			numOfGuesses++;        
			// 사용자가 추측한 횟수를 증가시킵니다.        
			String result = "miss";          
			// 따로 바꾸지 않으면'miss'라고 가정합니다.
			for (DotCom dotComToTest : dotComsList) 
				// 목록에 들어있는모든 DotCom객체에 대해 반복합니다.     
				{                   
				result = dotComToTest.checkYourself(userGuess);  
				// DotCom 객체에 사용자가 입력한 위치가 맞는지 또는  그 객체가 죽었는지 물어봅니다.      
				if (result.equals("hit"))                
				{                       
					break;                      
					// 순환문에서 일찍빠져나옵니다. 더 이상 확인하지 않아도 됩니다.   
					} 
				if (result.equals("kill")) 
				{  
					dotComsList.remove(dotComToTest); 
               		break;                    
				}      
				}             
			System.out.println(result);           
			}  
		private void finishGame()     
		{            
			System.out.println("All Dots are dead! Your " + "stock is now worthless");      
			if (numOfGuesses<=18)      
			{                     
				System.out.println("It only took you" +  numOfGuesses + "Guesses.");   
				System.out.println("You got out before your  " +  "  options sank");    
				}else {         
					System.out.println("Took you long enough. " +  numOfGuesses + "guess.");     
					System.out.println("Fish are dancing with " +  " your options");           
					} // 게임결과를 알려주는 메시지  
			} 
	
	public static void main(String[] args)throws IOException{ // 메인클래스 선언         
			DotComBust game = new DotComBust();         
			game.setUpGame();        
			game.startPlaying();        
		} 
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상위클래스로부터 인스턴스 변수와 메소드를 하위클래스에게 넘겨주는 것을 상속이라고 한다.
 
 * 다형성:  부모의 레퍼런스 변수가 자식을 가르키도록 하는 것

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Animal{
 char picture;
 int food
 int boudaries;
 int location;
 boolean hunger;
 void sound(){ }
 void eat(){ }
 void sleep(){ }
 void roam(){ }
}
class Feline extends Animal{
 void roam(){ }
 void sleep(){ }
}
class Hippo extends Animal{
 void sound(){ }
 void eat(){ }
}
class Lion extends Feline{
 void sound(){ }
 void eat(){ }
}
class Tiger extends Feline{
 void sound(){ }
 void eat(){ }
}
class Cat extends Feline{
 void sound(){ }
 void eat(){ }
}
class Canine extends Animal{
 void roam(){ }
}
class Wolf extends Canine{
 void sound(){ }
 void eat(){ }
}
class Dog extends Canine{
 void sound(){ }
 void eat(){ }
}
}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:하위클래스에서 메소드의 역할을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것.
 * 오버로딩:이름이 같고 인자목록이 다른 메소드 두개를 만드는 것

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive{
	public static void main(String [] args){
		Monster [] ma = new Monster[3]; // ma 배열을 생성합니다.
		ma[0] = new Vampire();
		ma[1] = new Monster();
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++){ // 메소드를 생성합니다.
			ma[x].frighten(x);
		}
	}
}

class Monster{ // 놀랐을 때 하는 행동
	boolean frighten(int d){
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster{ // 뱀파이어가 몬스터를 확장한다.
	boolean frighten(int x){
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster{ // 드래곤이 몬스터를 확장한다.
	boolean frighten(int degree){
		System.out.println("breath fire");
		return true;
	}
}
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:서로 다른 상속트리에 들어있는 클래스에서 공통적인 인터페이스를 구현할수 있게 하는것.
 * 다형성:상위클래스 유형을 메소드의 인자나 리턴유형 또는 배열유형으로 쓸 수 있게 만드는 능력
 * 추상 클래스:아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스
 * 추상 메소드:반드시 오버라이드해야 하는 메소드
 * 다중 상속:상위 클래스를 두개 사용하는것

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:인스턴스 변수
 * 스택에서의 변수:지역변수
 * 생성자:객체를 생성할 때 실행되는 코드가 들어있다.
 * 널 레퍼런스:프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에 자동적으로 기본값이 지정되는 것. 여기서 객체에 대한 레퍼런스의 기본값
 
*298p 집중토론* _요약_

 * 인스턴스 변수:

- 객체를 지원하는 역할

- 객체와 함께 힙에서 산다.

 * 지역 변수:

- 메소드에 들어있는 알고리즘을 작동시키기 위해 꼭 필요하다.

*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.*;
class V2Radiator{
	V2Radiator(ArrayList list){
		for(int x=0; x<5; x++){
			list.add(new SimUnit("V2Radiator"));
		}
	}
}

class V3Radiator extends V2Radiator{
	V3Radiator(ArrayList lglist){
		super(lglist);
		for(int g=0; g<10; g++){
			lglist.add(new SimUnit("V3Radiator"));
		}
	}
}

class RetentionBot{
	RetentionBot(ArrayList rlist){
		rlist.add(new SimUnit("Retention"));
	}
}

public class TestLifeSupportSim{
	public static void main(String [] args){
		ArrayList aList = new ArrayList();
		V2Radiator v2 = new V2Radiator(aList);
		V3Radiator v3 = new V3Radiator(aList);
		for(int z=0; z<20; z++){
			RetentionBot ret = new RetentionBot(aList);
			System.out.println(z+1 + "unit");
		}
	}
}

class SimUnit{
	String botType;
	SimUnit(String type){
		botType = type;
	}
	int powerUse(){
		if("Retention".equals(botType)){
			return 2;
		}else{
			return 4;
		}
	}
}
}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않다. 클래스만 있어도 된다.
 * 정적 메소드를 선언하는 방법:선언할 때 static를 붙인다.
 * static final:클래스가 로딩되어있는 동안 계속 똑같은 값을 유지
 * 널 레퍼런스:프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에 자동적으로 기본값이 지정되는 것. 여기서 객체에 대한 레퍼런스의 기본값
 * 오토 박싱:원시값과 객체 사이의 경계를 없애는 것
 * 정적 임포트:정적 클래스, 정적 변수, enum 값 등을 사용할때 타이핑을 적게 하기위해 미리 입력시켜 놓은것

*339p Calendar* _구현후 주석달기_

{{{
import java.util.*;
public class Calender{
        public static void main(String[] args){
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40); // 시각을 2004년 1월 7일 15:40으로 설정
                   long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴
                   day1 += 1000*60*60;
                c.setTimeInMillis(day1); // 한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시간을 갱신합니다.
                System.out.println("new hour " + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35); // 35일을 더합니다.
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35); // 35일 뒤로 넘깁니다.
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1); // 날짜를 더하는게 아닙니다. 날짜를 1로 설정
                   System.out.println("set to 1 " + c.getTime());
}
}
}}}
 
*342p 집중토론* _요약_

 * 인스턴스 변수:정적변수는 상수에 불과하다. 프로시저 위주의 프로그래밍이다.
 * 지역 변수: 메모리를 절약시킨다. 객체의 자연적인 상태의 한 부분이고, 효율적이다.

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class StaticSuper{ // 클래스 선언

  static{
    System.out.println("super static block");
  }

  StaticSuper{
    System.out.println(
      "super constructor");
  }
}

public class StaticTests extends StaticSuper{ // 클래스 확장
  static int rand;

  static{
    rand = (int) (Math.random() * 6);
    System.out.println("static block " + rand);
  }

  staticTests(){
    System.out.println("constructor");
  }

  public static void main(String [] args){ // 메인메소드
    System.out.println("in main");
    StaticTests st = new StaticTests();
  }
}
}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{
public void takeRisk() throws BadException{ // 예외를 선언하는 과정
  if(abandonAllHope){
    throw new BadException(); // 새로운 Exception 객체를 만들고 던진다.
  }
}

public void crossFingers(){
  try{
    anObject.takeRisk();
  }
  catch(BadException ex){
    System.out.println("Aaargh!");
    ex.printStackTrace(); // 예외상황을 해결할 수 없다면 적어도 스택 트레이스를 출력하는 정도는 해 줘야 한다.
  }
}
}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{
import javax.sound.midi.*; // 미디패키지를 반드시 불러와야 합니다.

public class MiniMiniMusicApp{
	
		public static void main(String[] args){
			MiniMiniMusicApp mini = new MiniMiniMusicApp();
			mini.play();
		}
		
		public void play(){
			try{
				Sequencer player = MidiSystem.getSequencer(); // Sequencer을 받아서 엽니다.
				player.open();
				
				Sequence seq = new Sequence(Sequence.PPQ,4);
				
				Track track = seq.createTrack(); // Sequence에 Track을 요청합니다.
				
				ShortMessage a = new ShortMessage(); // Track에 MidiEvent를 집어넣습니다.
				a.setMessage(144,1,44,100);
				MidiEvent noteOn = new MidiEvent(a, 1);
				track.add(noteOn);
				
				ShortMessage b = new ShortMessage();
				b.setMessage(128, 1, 44, 100);
				MidiEvent noteOff = new MidiEvent(b, 16);
				track.add(noteOff);
				
				player.setSequence(seq); // Sequencer에 Sequence를 보냅니다.
				
				player.start(); // Sequencer의 start()메소드를 호출합니다.
			}catch(Exception ex){
				ex.printStackTrace();
			}
		}
}
}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}