#summary 이성호천재

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong// 클래스 선언
  {
  public static void main (String[] args) // 메소드 선언
    {
    int beerNum = 99; // 맥주의 수를 99개로 설정
    String word = "bottles"; // 복수형
       while(beerNum > 0) // 맥주가 하나 이상일때
      {
      System.out.println(beerNum + " " + word + " of beer on the wall");
      System.out.println(beerNum + " " + word + " of beer.");
      System.out.println("Take one down.");
      System.out.println("Pass it around."); // 출력
      beerNum = beerNum -1; // 와일문을 한바퀴 돌때마다 맥주갯수 하나씩 감소

      if(beerNum == 1) // 맥주의 갯수가 하나일때
       {
      word = "bottle"; // 단수병(한병인 경우)
      } // 이 if문의 위치를 바꿔주어야 아래쪽 에서도 갯수가 1일때부터 단수로 적용

       if(beerNum > 0) // 갯수가 하나 이상일때
      {
      System.out.println(beerNum + " " + word + " of beer on the wall");
      }
      else // 갯수가 0개일떄
       {
      System.out.println("No more bottles of beer on the wall");
      } // else문 끝
       } // while 순환문 끝
    } // main 클래스 끝
  } // 클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
  public static void main ( String[] args) {
  // 세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
  String[] wordListOne = {"dog", "cat", "eagle", "tiger", "elephant"};
  String[] wordListTwo = {"first", "second", "third", "fourth", "fifth"};
  String[] wordListThree = {"love", "like", "become", "hate", "favor"};

  // 각 단어 목록에 단어가 몇개씩 들어있는지 확인합니다.
  int oneLength = wordListOne.lengh;
  int twoLength = wordListTwo.lengh;
  int threeLength = wordListThree.lengh;

  // 난수 세 개를 발생시킵니다.
  int rand1 = (int) (Math.random() * oneLength);
  int rand2 = (int) (Math.random() * twoLength);
  int rand3 = (int) (Math.random() * threeLength);

  // 이제 구문을 만듭니다.
  String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

  //구문을 출력합니다.
  System.out.println("What we need is a " + phrase);
  }
  }
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
1. 프로그램을 실행시킨다. 

2. 보안 관련 작업을 처리한다.

3. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 건드렸는지 확인한다.
 * 컴파일러:
1. 파일을 준다.

2. 문법이 맞았는지 틀렸는지 확인한다.

3. 변수에 이상한 유형의 데이터를 저장하지 못하게 한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

A
{{{
class Exercise1b // 클래스 선언
  {
  public static void main(String [] args) // 메소드 선언
  {
  int x = 1 ; // x를 1로 선언
  while(x<10) // x가 10보다 작을때
  {
    x = x + 1 // while문 한바퀴 돌때마다 x가 1씩 증가, 무한순환을 막아줌.
    if(x>3) // x가 3보다 클때
     {
    System.out.println("big x"); // 출력
     }
  }
  }
  }
}}}

B
{{{
class Exercise1b // 클래스를 정의하지 않으면 컴파일할 수 없다.
  {
  public static void main(String [] args) // 메소드 선언
  {
  int x = 5; // x를 5로 선언
  while (x > 1) // x가 1보다 클동안
  {
    x = x - 1; // while문 한바퀴 돌때 x가 1씩 줄어든다
    if(x < 3) // x가 3보다 작을때
    {
    System.out.println("small x"); // 출력
    }
  }
  }
  }
}}}

C
{{{
class Exercise1b // 클래스 선언
  {
  public static void main(String [] args) // while문이 메소드 안에 있지 않으면 컴파일 되지 않는다.
  {
  int x = 5; // x를 5로 선언
  while ( x > 1) // x가 1보다 클 동안
  {
  x = x - 1; // x가 1씩 줄어든다
  if ( x < 3) // 만약 x가 3보다 작다면
  {
  System.out.println("small x"); // 출력
  }
  }
  }
  }
}}}

= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터)를 나타낸다.
 * 메소드: 객체에서 할 수 있는 일.
 * 클래스: 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할.
 * 테스트용 클래스: 클래스를 테스트하기 위한 코드.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume
 * 메소드: channelup(), channeldown(), volumeup(), volumedown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자 : " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자 : " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자 : " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자 : " + guessp4);
			
			if(guessp1 == targetNumber){
				p1isRight = true;
			}
			
			if(guessp2 == targetNumber){
				p2isRight = true;
			}
			
			if(guessp3 == targetNumber){
				p3isRight = true;
			}
			
			if(guessp4 == targetNumber){
				p4isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight){
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수 : " + p1isRight);
				System.out.println("2번 선수 : " + p2isRight);
				System.out.println("3번 선수 : " + p3isRight);
				System.out.println("4번 선수 : " + p4isRight);
				System.out.println("게임 끝.");
				break;
				
			}else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			} // if/else 부분 끝
		} // 순환문 끝		
	} // 메소드 끝
} // 클래스  끝

public class Player {
	int number = 0; // 찍은 숫자를 저장할 변수
	
	public void guess(){
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자 : " + number);
	}
}

public class GameLauncher {
	public static void main (String[] args){
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class TapeDeck { // 클래스 선언
	boolean canRecord = false; // 참거짓변수 지정
	void playTape() { // 메소드 선언
		System.out.println("tape playing"); // 출력
	}
	void recordTape() { // 메소드 선언
		System.out.println("tape recording"); // 출력
	}
}

class TapeDeckTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		TapeDeck t = new TapeDeck(); // 템플릿(클래스)가 있으니 실제 객체를 만들어야 한다.
		t.canRecord = true; // 참거짓변수에 참을 입력
		t.playTape(); // t 라는것에 대해 playTape 메소드를 실행한다.
		
		if(t.canRecord == true) { // 만약 ~라면
			t.recordTape(); // t 라는것에 대해 recordTape 메소드를 실행한다.
		}
	}
}

B

class DVDPlayer { // 클래스 선언
	boolean canRecord = false; // 참거짓변수 지정
	void recordDVD() { // 메소드 선언
		System.out.println("DVD recording"); // 출력
	}
	void playDVD() { // 메소드 선언, 아래의 d.palyDVD를 컴파일 시키기 위해 필요
		System.out.println("DVD playing"); // 출력
	}
}

class DVDPlayerTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		DVDPlayer d = new DVDPlayer(); // 실제 객체를 만든다.
		d.canRecord = true; // 변수에 참을 입력
		d.playDVD(); // d 라는 것에 대해 playDVD메소드 실행
		if (d.canRecord == true) { // 만약 ~라면
			d.recordDVD(); // d 라는 것에 대해 recordDVD메소드 실행
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
- 원시변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다. 그리고 객체 레퍼런스에는 개체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
public class Dog {
	String name;
	public static void main (String[] args){
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[10];
		//  그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = new Dog();
		myDogs[3] = new Dog();
		myDogs[4] = new Dog();
		myDogs[5] = new Dog();
		myDogs[6] = new Dog();
		myDogs[7] = new Dog();
		myDogs[8] = new Dog();
		myDogs[9] = dog1;
		
		// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
		myDogs[0].name = "성호";
		myDogs[1].name = "정곤";
		myDogs[2].name = "서연";
		myDogs[3].name = "승태";
		myDogs[4].name = "채원";
		myDogs[5].name = "진범";
		myDogs[6].name = "능호";
		myDogs[7].name = "규원";
		myDogs[8].name = "영";
		
		//myDogs[9]의 이름이 뭐였지?
		System.out.print("마지막 개의 이름 : ");
		System.out.println(myDogs[2].name);
		
		// 이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x + 1;
		}
	}

	public void bark() {
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A

class Books { // 클래스 선언
	String title; // 문자열 선언
	String author; // 문자열 선언
}
class BooksTestDrive { // 클래스 선언
	public static void main(String [] args) { // 메소드 선언
		Books [] myBooks = new Books[3]; // 3칸짜리 배열을 만든다.
		int x = 0;
		myBooks[0] = new Books(); //객체를 만든다.
		myBooks[1] = new Books(); //
		myBooks[2] = new Books(); //
		myBooks[0].title = "The Grapes of Java"; // 타이틀을 새긴다.
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob"; // 작가를 새긴다.
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		while ( x < 3) {
			System.out.print(myBooks[x].title); // 출력한다
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1; // 다음책으로 넘긴다.
		}	
	}
}

B

class Hobbits { // 클래스 선언
	String name; // 문자열 선언
	public static void main(String [] args) { // 메소드 선언
		Hobbits [] h = new Hobbits[3]; // 3칸짜리 배열을 만든다
		int z = -1; // z 의 값 선언,  배열의 인덱스는 0부터 시작하므로 아래칸을 맞추기 위해
				while(z < 2) { // ~하는동안
					z = z + 1; // z 값이 하나씩 증가
					h[z] = new Hobbits(); // 객체를 하나씩 만들어준다.
					h[z].name = "bilbo"; // 모든 객체의 이름을  bilbo 로 해둔다.
					if (z == 1) {
						h[z].name = "frodo"; // 객체의 이름을 바꾼다.
					}
					if (z == 2) {
						h[z].name = "sam"; // 객체의 이름을 바꾼다.
					}
					System.out.print(h[z].name + " is a "); // 출력
					System.out.println("good Hobbit name");
				}
	}
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:
 * 문제가 된 부분은 어딘가요?:

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
 * 게터와 세터:
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;
	
	void bark(){
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}
class DogTestDrive {
	
	public static void main (String[] args) {
		Dog one = new Dog ();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();
	}
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}