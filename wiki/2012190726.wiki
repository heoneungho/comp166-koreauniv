#summary 카카마카카마카카카카카카마
#labels 2012190726김경민

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public class BeerSong {  //클래스 명 설정
	public static void main(String[] args) {  //메인 클래스 시작
		int beerNum = 99;  //정수형 변수 beerNum을 설정, 99대입
		String word = "bottles";   //복수형
		
		while (beerNum > 0) {  //while 순환문 시작

			if (beerNum == 1){  //beerNum이 1일 경우,
				word = "bottle";        //단수형(한 병인 경우)
			}
			
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");  //이상 출력문.
			beerNum = beerNum - 1;  //beerNum에서 1을 뺀다.
			
			if (beerNum > 0) {  //beerNum이 0 초과 일 경우,
		 	   //System.out.println(beerNum + " " + word + " of beer on the wall");
                             //원래 있었던 문장이 중복되는 오류를 막기 위해 주석 처리, 혹은 출력문을 제거한다.
			} else {
			  	System.out.println("No more bottles of beer on the wall");
			} 		//else 문 끝
		}			//while 순환문 끝
	}			//main 클래스 끝
}			 //클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
	public static void main(String[] args) {
		
		//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String[] wordListOne = {"경민", "채원", "영현", "정곤", "능호"};
		String[] wordListTwo = {"will", "want to", "should", "must"};
		String[] wordListThree = {"sleep", "study hard", "go to home", "go to school"};
		
		//각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		//난수 세 개를 발생시킵니다.
		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);
		
		//이제 구문을 만듭니다.
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];
		
		//구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 기본적으로 파일을 실행시키는 역할을 함. 컴파일러가 잡아내지 못한 오류, 보안 등을 체크하기도 한다.

 * 컴파일러: 언어를 해석해서 파일을 주는 것이 주역할. 오류, 보안 등을 체크한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class Exercise1b1{ //클래스 명이 모두 같아서 임의로 Exercise1b1로 설정.
	public static void main(String[] args) {
		int x = 1;
		while (x < 10) {
			if (x > 3) {
				System.out.println("big x");
			}
			x = x + 1; //원래 코드에서 무한 루프였던 것을 고치기 위해 반복문 한 번 마다 x를 증가 시켜준다.
		}
	}
}

class Exercise1b2 { //클래스 이름 선언이 빠졌으므로 추가해준다.
	public static void main(String[] args) {
		int x = 5;
		while (x > 1) {
			x = x - 1;
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

class Exercise1b3 { //클래스 명이 모두 같아서 임의로 Exercise1b3로 설정.
	public static void main(String[] args) { //main 메소드를 추가해준다.
		int x = 5;
		while (x > 1) {
			x = x - 1;
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(객체에 관해 아는 것)를 나타낸다.
 * 메소드: 객체에서 할 수 있는 일.
 * 클래스: 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 메인 메소드가 들어가며 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Channel, Volume, Power
 * 메소드: setChannel(), upChannel(), downChannel(), upVolume(), downVolume(), powerOn(), powerOff()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; //게임이 끝났으므로 break 문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			} //if/else 부분 끝				
		} //순환문 끝
	} //메소드 끝
} //클래스 끝

public class Player {
	int number = 0; // 찍은 숫자를 저장할 변수
	
	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

package tapedeck;

public class TapeDeck {
	boolean canRecord = false;
	
	void playTape() {
		System.out.println("tape playing");
	}
	
	void recordTape() {
		System.out.println("tape recording");
	}
}

package tapedeck;

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		
		TapeDeck t = new TapeDeck(); //t라는 객체가 설정되어 있지 않으므로 t라는 TapeDeck 객체를 만들어 줍니다.
		
		t.canRecord = true;
		t.playTape();
		
		if (t.canRecord == true){
			t.recordTape();
		}
	}
}


  B

package dvd;

public class DVDPlayer {
	
	boolean canRecord = false;
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
	
	void playDVD() {  // playDVD 메소드를 설정해야 메인 메소드에서 사용할 수 있습니다.
		System.out.println("DVD playing");
	}

}

package dvd;

public class DVDPlayerTestDrive {
	public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		
		if (d.canRecord == true) {
			d.recordDVD();
		}
	}

}


}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

 원시변수는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어가고,
 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
	String name;
	public static void main(String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "경민";
		
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[10];
		// 그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		myDogs[3] = new Dog();
		myDogs[4] = new Dog();
		myDogs[5] = new Dog();
		myDogs[6] = new Dog();
		myDogs[7] = new Dog();
		myDogs[8] = new Dog();
		myDogs[9] = new Dog();

	// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
	myDogs[0].name = "발발이";
	myDogs[1].name = "멍멍이";
	myDogs[3].name = "점박이";
	myDogs[4].name = "진돗개";
	myDogs[5].name = "시츄";
	myDogs[6].name = "영현";
	myDogs[7].name = "채원";
	myDogs[8].name = "영훈";
	myDogs[9].name = "긔요미";
	
	//myDogs[2]의 이름이 뭐였지?
	System.out.print("마지막 개의 이름: ");
	System.out.println(myDogs[2].name);
	
	//이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
	int x = 0;
	while(x < myDogs.length) {
		myDogs[x].bark();
		x = x + 1;
		}
	}
	
	public void bark() {
		System.out.println(name + "이(가) 왈왈멍멍으르릉킁킁! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

public class Books {
	String title;
	String author;
}

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books [] myBooks = new Books[3];
		int x = 0;
		
		myBooks[0] = new Books(); // Books 배열의 객체들을 만들어 줘야 한다.
		myBooks[1] = new Books();
		myBooks[2] = new Books();
		
		myBooks[0].title = "the Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		
		while (x < 3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}


  B

public class Hobbits {

	String name;
	
	public static void main(String[] args) {
		
		Hobbits [] h = new Hobbits[3];
		int z = 0;
		
		while (z < 3) { // 조건이 "z < 4" 였던 것을 "z < 3"으로 바꿔 배열의 갯수와 같은 횟수만큼 순환문이 실행되도록 합니다.

			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if (z == 1) {
				h[z].name = "frodo";
			}
			if (z == 2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + "is a ");
			System.out.println("good Hobbit name");
			z = z + 1; // while문 가장 앞에 있던 것을 가장 뒤로 가져옵니다.
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 절약할 수 있지만 순환문을 돌때마다 변수에 다른 값이 들어가기 때문에 전에 저장했던 값을 버리는 결과를 얻게 되는 문제를 발생시킨다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 노출되어 있는 변수들을 보호하기 위해서 private를 사용해 함부로 변경하지 못하도록 하는것.

 * 게터와 세터:
 - 게터 : 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰임.
 - 세터 : 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰임.

 * 인스턴스 변수 vs 지역 변수:
 - 인스턴스 변수 : 클래스 내에서 선언된다.
 - 지역 변수 : 메소드 내에서 선언된다, 사용 전 반드시 초기화해야 한다.
 
*107p Dog* _실행_

{{{

package dogbark;

public class Dog {
	int size;
	String name;
	
	void bark() {
		if (size > 60){
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}  //사이즈에 따라 개가 짖는 소리를 다르게 정한다.
	}
}

package dogbark;

public class DogTestDrive {
	
	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;  //개 3마리를 만들고 사이즈를 각각 다르게 설정.
		
		one.bark();
		two.bark();
		three.bark();
	}
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

public class XCopy {
	
	public static void main(String[] args) {
		
		int orig = 42;
		
		XCopy x = new XCopy(); // XCopy의 객체 x 생성
		
		int y = x.go(orig); // y 값에 orig 값(42)을 go 메소드에 넣어 얻은 값을 넣음
		
		System.out.println(orig + " " + y);
	}
	
	int go(int arg) { // go 메소드
		
		arg = arg * 2;
		
		return arg; // arg 값을 메인 메소드의 x.go(orig) 반환한다.로
	}
} // 출력값 : 42 84


  B

package compiler2;

public class Clock {
	String time;
	
	void setTime(String t){
		time = t;
	}
	
	String getTime(){  //void를 사용할 경우 return값을 설정할 수 없기 때문에 time의 변수형인 String으로 설정해야 한다.
		return time;
	}
}

package compiler2;

public class ClockTestDrive {
	public static void main(String[] args) {
		
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time:" + tod);
	}
} // 출력값 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

 - 테스트 대상을 만들기 전에 테스트 코드를 먼저 만드는 소프트웨어 개발 방법.
 - "프로그래머들이 정말 원하는 방법", 90년대 말 등장
 - 조금씩, 하지만 자주 발표한다, 사이클을 반복해서 돌리면서 개발한다, 테스트 코드를 먼저 만든다 등의 규칙이 있다. 

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

package simpledotcom;

public class SimpleDotComGame {
	public static void main(String[] args) { //main 메소드가 들어있는 클래스
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); //새로운 게임을 불러온다.
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); //randomNum에 0과 4사이의 임의의 정수값을 가져온다.
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) { //숫자를 입력하여 맞고 틀리고를 판별.
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

package simpledotcom;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) { //로케이션을 설정.
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) { //사용자가 쓴 숫자가 맞았는지를 체크한다.
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		} //순환문 끝
		
		if (numOfHits == locationCells.length) { //3개를 모두 맞췄으면 kill이라 띄운다.
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} //메소드 끝
} //클래스 끝

package simpledotcom;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

package simpledotcom2;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom2;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	boolean[] hitCells; //맞춘 지를 true/false로 확인시켜줄 새로운 배열 
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
    public void setHitCells(boolean[] hits) {
            hitCells = hits;
    }
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i] && hitCells[i] == false) {
				result = "hit";
				hitCells[i] = true; //맞았을 경우 2번째 행렬의 그 위치를 true로 바꾼다.
				numOfHits++;
				break;
			}
		} 
		
		if (numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} 
}

package simpledotcom2;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); 
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
   boolean[] hits = {false, false, false}; // 초기값은 false로 설정한다.
   theDotCom.setHitCells(hits); // 새로운 배열을 만든다.
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} 
		} 
	} 
} 

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

package simpledotcom3;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom3;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) { 
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				locationCells[i] = -1; // 맞춘 곳의 locationCells값을 -1로 바꿉니다.
				break;
			}
		} //순환문 끝
		
		if (numOfHits == locationCells.length) { 
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} //메소드 끝
} //클래스 끝

package simpledotcom3;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); 
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

package simpledotcom4;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom4;

import java.util.ArrayList;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
		
		DotCom theDotCom = new DotCom();
		int randomNum = (int) (Math.random() * 5); 
	
		ArrayList<String> locations = new ArrayList(); //ArrayList를 만듭니다.
		locations.add(String.valueOf(randomNum)); //해당 값들을 넣습니다.
		locations.add(String.valueOf(randomNum+1));
		locations.add(String.valueOf(randomNum+2));
		
   theDotCom.setLocationCells(locations); //locations의 위치를 정합니다.
		
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

package simpledotcom4;

import java.util.ArrayList;

public class DotCom {
	
	private ArrayList<String> locationCells;
	// private int numOfHits; (없어도 됩니다)
	
	public void setLocationCells(ArrayList<String> loc) {
		locationCells = loc;
	}
	
	public String checkYourself(String userInput) {
		
		String result = "miss";
		int index = locationCells.indexOf(userInput);
		
		if(index >= 0) {
			locationCells.remove(index);
			
			if(locationCells.isEmpty()) { //locationCells가 모두 사라져 비었을 경우,
				result = "kill";
			} else {
				result = "hit";
			} //if문 끝
		} // 바깥쪽 if문 끝
		System.out.println(result);
		return result;
	} //메소드 끝
} //클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}