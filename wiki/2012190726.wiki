#summary 카카마카카마카카카카카카마
#labels 2012190726김경민

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public class BeerSong {  //클래스 명 설정
	public static void main(String[] args) {  //메인 클래스 시작
		int beerNum = 99;  //정수형 변수 beerNum을 설정, 99대입
		String word = "bottles";   //복수형
		
		while (beerNum > 0) {  //while 순환문 시작

			if (beerNum == 1){  //beerNum이 1일 경우,
				word = "bottle";        //단수형(한 병인 경우)
			}
			
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");  //이상 출력문.
			beerNum = beerNum - 1;  //beerNum에서 1을 뺀다.
			
			if (beerNum > 0) {  //beerNum이 0 초과 일 경우,
		 	   //System.out.println(beerNum + " " + word + " of beer on the wall");
                             //원래 있었던 문장이 중복되는 오류를 막기 위해 주석 처리, 혹은 출력문을 제거한다.
			} else {
			  	System.out.println("No more bottles of beer on the wall");
			} 		//else 문 끝
		}			//while 순환문 끝
	}			//main 클래스 끝
}			 //클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
	public static void main(String[] args) {
		
		//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
		String[] wordListOne = {"경민", "채원", "영현", "정곤", "능호"};
		String[] wordListTwo = {"will", "want to", "should", "must"};
		String[] wordListThree = {"sleep", "study hard", "go to home", "go to school"};
		
		//각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		//난수 세 개를 발생시킵니다.
		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);
		
		//이제 구문을 만듭니다.
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];
		
		//구문을 출력합니다.
		System.out.println("What we need is a " + phrase);
	}
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 기본적으로 파일을 실행시키는 역할을 함. 컴파일러가 잡아내지 못한 오류, 보안 등을 체크하기도 한다.

 * 컴파일러: 언어를 해석해서 파일을 주는 것이 주역할. 오류, 보안 등을 체크한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class Exercise1b1{ //클래스 명이 모두 같아서 임의로 Exercise1b1로 설정.
	public static void main(String[] args) {
		int x = 1;
		while (x < 10) {
			if (x > 3) {
				System.out.println("big x");
			}
			x = x + 1; //원래 코드에서 무한 루프였던 것을 고치기 위해 반복문 한 번 마다 x를 증가 시켜준다.
		}
	}
}

class Exercise1b2 { //클래스 이름 선언이 빠졌으므로 추가해준다.
	public static void main(String[] args) {
		int x = 5;
		while (x > 1) {
			x = x - 1;
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

class Exercise1b3 { //클래스 명이 모두 같아서 임의로 Exercise1b3로 설정.
	public static void main(String[] args) { //main 메소드를 추가해준다.
		int x = 5;
		while (x > 1) {
			x = x - 1;
			if (x < 3) {
				System.out.println("small x");
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(객체에 관해 아는 것)를 나타낸다.
 * 메소드: 객체에서 할 수 있는 일.
 * 클래스: 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 메인 메소드가 들어가며 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Channel, Volume, Power
 * 메소드: setChannel(), upChannel(), downChannel(), upVolume(), downVolume(), powerOn(), powerOff()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random() * 10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break; //게임이 끝났으므로 break 문으로 순환문을 빠져나갑니다.
			} else {
				// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
				System.out.println("다시 시도해야 합니다.");
			} //if/else 부분 끝				
		} //순환문 끝
	} //메소드 끝
} //클래스 끝

public class Player {
	int number = 0; // 찍은 숫자를 저장할 변수
	
	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

package tapedeck;

public class TapeDeck {
	boolean canRecord = false;
	
	void playTape() {
		System.out.println("tape playing");
	}
	
	void recordTape() {
		System.out.println("tape recording");
	}
}

package tapedeck;

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		
		TapeDeck t = new TapeDeck(); //t라는 객체가 설정되어 있지 않으므로 t라는 TapeDeck 객체를 만들어 줍니다.
		
		t.canRecord = true;
		t.playTape();
		
		if (t.canRecord == true){
			t.recordTape();
		}
	}
}


  B

package dvd;

public class DVDPlayer {
	
	boolean canRecord = false;
	
	void recordDVD() {
		System.out.println("DVD recording");
	}
	
	void playDVD() {  // playDVD 메소드를 설정해야 메인 메소드에서 사용할 수 있습니다.
		System.out.println("DVD playing");
	}

}

package dvd;

public class DVDPlayerTestDrive {
	public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		
		if (d.canRecord == true) {
			d.recordDVD();
		}
	}

}


}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

 원시변수는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어가고,
 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
	String name;
	public static void main(String[] args) {
		// Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "경민";
		
		// 이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[10];
		// 그리고 개를 몇 마리 집어넣습니다.
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		myDogs[3] = new Dog();
		myDogs[4] = new Dog();
		myDogs[5] = new Dog();
		myDogs[6] = new Dog();
		myDogs[7] = new Dog();
		myDogs[8] = new Dog();
		myDogs[9] = new Dog();

	// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
	myDogs[0].name = "발발이";
	myDogs[1].name = "멍멍이";
	myDogs[3].name = "점박이";
	myDogs[4].name = "진돗개";
	myDogs[5].name = "시츄";
	myDogs[6].name = "영현";
	myDogs[7].name = "채원";
	myDogs[8].name = "영훈";
	myDogs[9].name = "긔요미";
	
	//myDogs[2]의 이름이 뭐였지?
	System.out.print("마지막 개의 이름: ");
	System.out.println(myDogs[2].name);
	
	//이제 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합시다.
	int x = 0;
	while(x < myDogs.length) {
		myDogs[x].bark();
		x = x + 1;
		}
	}
	
	public void bark() {
		System.out.println(name + "이(가) 왈왈멍멍으르릉킁킁! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

public class Books {
	String title;
	String author;
}

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books [] myBooks = new Books[3];
		int x = 0;
		
		myBooks[0] = new Books(); // Books 배열의 객체들을 만들어 줘야 한다.
		myBooks[1] = new Books();
		myBooks[2] = new Books();
		
		myBooks[0].title = "the Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		
		while (x < 3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}


  B

public class Hobbits {

	String name;
	
	public static void main(String[] args) {
		
		Hobbits [] h = new Hobbits[3];
		int z = 0;
		
		while (z < 3) { // 조건이 "z < 4" 였던 것을 "z < 3"으로 바꿔 배열의 갯수와 같은 횟수만큼 순환문이 실행되도록 합니다.

			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if (z == 1) {
				h[z].name = "frodo";
			}
			if (z == 2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + "is a ");
			System.out.println("good Hobbit name");
			z = z + 1; // while문 가장 앞에 있던 것을 가장 뒤로 가져옵니다.
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 절약할 수 있지만 순환문을 돌때마다 변수에 다른 값이 들어가기 때문에 전에 저장했던 값을 버리는 결과를 얻게 되는 문제를 발생시킨다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 노출되어 있는 변수들을 보호하기 위해서 private를 사용해 함부로 변경하지 못하도록 하는것.

 * 게터와 세터:
 - 게터 : 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로 쓰임.
 - 세터 : 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰임.

 * 인스턴스 변수 vs 지역 변수:
 - 인스턴스 변수 : 클래스 내에서 선언된다.
 - 지역 변수 : 메소드 내에서 선언된다, 사용 전 반드시 초기화해야 한다.
 
*107p Dog* _실행_

{{{

package dogbark;

public class Dog {
	int size;
	String name;
	
	void bark() {
		if (size > 60){
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}  //사이즈에 따라 개가 짖는 소리를 다르게 정한다.
	}
}

package dogbark;

public class DogTestDrive {
	
	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;  //개 3마리를 만들고 사이즈를 각각 다르게 설정.
		
		one.bark();
		two.bark();
		three.bark();
	}
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

  A

public class XCopy {
	
	public static void main(String[] args) {
		
		int orig = 42;
		
		XCopy x = new XCopy(); // XCopy의 객체 x 생성
		
		int y = x.go(orig); // y 값에 orig 값(42)을 go 메소드에 넣어 얻은 값을 넣음
		
		System.out.println(orig + " " + y);
	}
	
	int go(int arg) { // go 메소드
		
		arg = arg * 2;
		
		return arg; // arg 값을 메인 메소드의 x.go(orig) 반환한다.로
	}
} // 출력값 : 42 84


  B

package compiler2;

public class Clock {
	String time;
	
	void setTime(String t){
		time = t;
	}
	
	String getTime(){  //void를 사용할 경우 return값을 설정할 수 없기 때문에 time의 변수형인 String으로 설정해야 한다.
		return time;
	}
}

package compiler2;

public class ClockTestDrive {
	public static void main(String[] args) {
		
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time:" + tod);
	}
} // 출력값 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

 - 테스트 대상을 만들기 전에 테스트 코드를 먼저 만드는 소프트웨어 개발 방법.
 - "프로그래머들이 정말 원하는 방법", 90년대 말 등장
 - 조금씩, 하지만 자주 발표한다, 사이클을 반복해서 돌리면서 개발한다, 테스트 코드를 먼저 만든다 등의 규칙이 있다. 

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

package simpledotcom;

public class SimpleDotComGame {
	public static void main(String[] args) { //main 메소드가 들어있는 클래스
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); //새로운 게임을 불러온다.
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); //randomNum에 0과 4사이의 임의의 정수값을 가져온다.
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) { //숫자를 입력하여 맞고 틀리고를 판별.
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

package simpledotcom;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) { //로케이션을 설정.
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) { //사용자가 쓴 숫자가 맞았는지를 체크한다.
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		} //순환문 끝
		
		if (numOfHits == locationCells.length) { //3개를 모두 맞췄으면 kill이라 띄운다.
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} //메소드 끝
} //클래스 끝

package simpledotcom;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

package simpledotcom2;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom2;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	boolean[] hitCells; //맞춘 지를 true/false로 확인시켜줄 새로운 배열 
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
    public void setHitCells(boolean[] hits) {
            hitCells = hits;
    }
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i] && hitCells[i] == false) {
				result = "hit";
				hitCells[i] = true; //맞았을 경우 2번째 행렬의 그 위치를 true로 바꾼다.
				numOfHits++;
				break;
			}
		} 
		
		if (numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} 
}

package simpledotcom2;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); 
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
   boolean[] hits = {false, false, false}; // 초기값은 false로 설정한다.
   theDotCom.setHitCells(hits); // 새로운 배열을 만든다.
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} 
		} 
	} 
} 

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

package simpledotcom3;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom3;

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) { 
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				locationCells[i] = -1; // 맞춘 곳의 locationCells값을 -1로 바꿉니다.
				break;
			}
		} //순환문 끝
		
		if (numOfHits == locationCells.length) { 
			result = "kill";
		}
		System.out.println(result);;
		return result;
	} //메소드 끝
} //클래스 끝

package simpledotcom3;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random() * 5); 
		
		int [] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

package simpledotcom4;

import java.io.*;

public class GameHelper {
	public String getUserInput(String prompt) {
		String inputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

package simpledotcom4;

import java.util.ArrayList;

public class SimpleDotComGame {
	public static void main(String[] args) { 
		int numOfGuesses = 0;
		GameHelper helper = new GameHelper(); 
		
		DotCom theDotCom = new DotCom();
		int randomNum = (int) (Math.random() * 5); 
	
		ArrayList<String> locations = new ArrayList(); //ArrayList를 만듭니다.
		locations.add(String.valueOf(randomNum)); //해당 값들을 넣습니다.
		locations.add(String.valueOf(randomNum+1));
		locations.add(String.valueOf(randomNum+2));
		
   theDotCom.setLocationCells(locations); //locations의 위치를 정합니다.
		
		boolean isAlive = true;
		
		while(isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			} //if문 끝
		} //while문 끝
	} //main문 끝
} //클래스 끝

package simpledotcom4;

import java.util.ArrayList;

public class DotCom {
	
	private ArrayList<String> locationCells;
	// private int numOfHits; (없어도 됩니다)
	
	public void setLocationCells(ArrayList<String> loc) {
		locationCells = loc;
	}
	
	public String checkYourself(String userInput) {
		
		String result = "miss";
		int index = locationCells.indexOf(userInput);
		
		if(index >= 0) {
			locationCells.remove(index);
			
			if(locationCells.isEmpty()) { //locationCells가 모두 사라져 비었을 경우,
				result = "kill";
			} else {
				result = "hit";
			} //if문 끝
		} // 바깥쪽 if문 끝
		System.out.println(result);
		return result;
	} //메소드 끝
} //클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
//나중에 할래요 현기증나요
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 하위클래스들은 상위클래스에게 상속 받으면 하위 클래스에서 별도의 메소드와 인스턴스 변수를 추가할 수도 있고 상위클래스에서 상속받은 메소드를 오버라이드 할 수도 있다. 

 * 다형성: 상위클래스로 선언된 레퍼런스를 이용하여 하위클래스 객체를 참조할 수 있다. 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

package extend;

public class Animal {
	
	String picture;
	boolean food;
	int hunger;
	float boundaries;
	float location;
	
	void makeNoise(){}
	void eat(){}
	void sleep(){}
	void roam(){}
	
}

package extend;

public class Feline extends Animal {
	void roam(){}
}

package extend;

public class Hippo extends Animal {
	void makeNoise() {};
}

package extend;

public class Canine extends Animal {
	void roam() {};
}

package extend;

public class Lion extends Feline {
	void makeNoise() {};
	void eat() {};
}

package extend;

public class Tiger extends Feline {
	void makeNoise() {};
	void eat() {};
}

package extend;

public class Cat extends Feline {
	void makeNoise() {};
	void eat() {};
}

package extend;

public class Wolf extends Canine {
	void makeNoise() {};
	void eat() {};
}

package extend;

public class Dog extends Canine {
	void makeNoise() {};
	void eat() {};
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 자식 메소드에서 부모 메소드를 재정의 하는것. 인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 한다. 메소드를 더 접근하기 어렵게 만들면 안 된다.

 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것. 오버로딩 된 메소드는 메소드 이름만 같을 뿐 그냥 서로 다른 메소드이다. 상속이나 다형성과는 전혀 상관이 없다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

package compiler;

public class MonsterTestDrive {
	public static void main(String[] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++) {
			ma[x].frighten(x); // ma[1].frighten(1), ma[2].frighten(2), ma[3].frighten(3) 실행.
		}
	}
}

package compiler;

public class Monster {
  	boolean frighten(int d) {
  		System.out.println("arrgh");
  		return true;
  	}
}

package compiler;

public class Vampire extends Monster {
	boolean frighten(int x) { //Vampire가 Monster를 오버라이드 해야하기 때문에 입력값 유형(int)와 반환값 유형(boolean)이 같아야 한다.
		System.out.println("a bite?");
		return false;
	}
}

package compiler;

public class Dragon extends Monster {
	boolean frighten(int degree) {
		System.out.println("breath fire");
		return true;
	}
}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 자바에서의 다중 상속 불가를 해결하기 위해 만든 추상 클래스만을 갖는 형태의 클래스.
 * 다형성: 상속하면 다형성을 이용해 레퍼런스와 객체가 다른 유형이 될 수 있다.
 * 추상 클래스: 상속을 받기위해 만든 클래스.
 * 추상 메소드: 반드시 오버라이드 해서 사용해야 하는 메소드. 추상 클래스 안에만 있을 수 있다.
 * 다중 상속: 여러 개의 클래스에서 동시에 상속 받는 것. 자바에서는 불가능하기 때문에 인터페이스를 만들어 사용한다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙=객체들이 모여있는 장소. 쓸모없어진 객체를 없애는 가비지 컬렉션 기능이 있다.
 * 스택에서의 변수: 메소드와 지역 변수가 있는 곳. 스택으로 쌓인다.
 * 생성자: public 이름 (변수1, 변수2, ...) {}처럼 메소드가 만들어 질 때 참조하는 것.
 * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체와 함께 힙에 존재. 초기화 되거나 제거되지 않으면 객체가 사라질 때 같이 사라진다.
 * 지역 변수: 메소드 안에 존재. 순서에 따라 스택에 쌓이며 순차적으로 사라진다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

package radiator;

import java.util.*;

class V2Radiator {
        V2Radiator (ArrayList list) {
                for(int x=0; x<5; x++) {
                        list.add(new SimUnit ("V2Radiator"));
                }
        }
}

class V3Radiator { //V3Radiator가 V2Radiator를 상속하면 안된다!
        V3Radiator (ArrayList lglist) {
                // super(lglist);
                for(int g=0; g<10; g++) {
                        lglist.add(new SimUnit("V3Radiator"));
                }
        }
}

class RetentionBot {
        RetentionBot (ArrayList rlist) {
                rlist.add(new SimUnit("Retention"));
        }
}

public class TestLifeSupportSim {
        public static void main(String[] args) {
                ArrayList aList = new ArrayList();
                V2Radiator v2 = new V2Radiator(aList);
                V3Radiator v3 = new V3Radiator(aList);
                for(int z=0; z<20; z++) {
                        RetentionBot ret = new RetentionBot(aList);
                }
        }
}

class SimUnit {
        String botType;
        SimUnit(String type) {
                botType = type;
        }
        int powerUse() {
                if("Retention".equals(botType)) {
                        return 2;
                } else {
                        return 4;
                }
        }
}

// aList에 V2R이 5개, V2R이 5개, V3R이 10개, Retention이 10개 쌓임. 
// (5+5+10)*4 + 10*2 = 120의 에너지를 소모.
// V3Radiator가 V2Radiator를 상속한 것이 문제. 

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 인스턴스없이 메소드를 실행할 수 있는 메소드.
 * 정적 메소드를 선언하는 방법: static으로 선언한다.
 * static final: 상수로 만든다! (ex)pi = 3.14..
 * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스
 * 오토 박싱: 원시유형을 컬렉션에 집어넣거나, 컬렉션에서 꺼낼 때, 거의 언제나 원시 유형이 들어갈 자리에 그 유형에 해당하는 래퍼 객체를 집어넣거나, 반대로 어떤 래퍼 객체가 들어갈 자리에 원시값을 집어넣을 수 있게하준다.
 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 활용.

*339p Calendar* _구현후 주석달기_

{{{

package calendar;

import java.util.*;

public class CalendarUsage {

        public static void main(String[] args) {

                Calendar c = Calendar.getInstance();
                
                c.set(1992,4,27,18,15); // 년,월,일,시,분 설정
                long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현.
                day1 += 1000 * 60 * 60; // 밀리초단위로 한시간을 나타냅니다.
                c.setTimeInMillis(day1); // 한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
                System.out.println("새 시간 " + c.get(c.HOUR_OF_DAY));

                c.add(c.DATE, 35); // 35일을 더한다.
                System.out.println("35일 후 " + c.getTime());

                c.roll(c.DATE, 35); // 35일을 더하지만 달은 변경하지 않는다.
                System.out.println("35일을 굴리면 " + c.getTime());

                c.set(c.DATE, 1); // 날짜를 1일로 설정.
                System.out.println("1일로 설정 " + c.getTime());
        }
}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 정적변수는 절차위주의 프로그래밍 썼던 비효율적인 변수 할당 방법이므로 바람직하지 않다.
 * 지역 변수: 정적변수는 이미 자바 환경 자체에 녹아들어가 있고 때에 따라서는 정적 변수를 쓰는 것이 편리할 때도 있으므로 정적변수를 매도해서만은 안된다.

*344p 컴파일러가 되어봅시다* _구현후 주석달기_


{{{

package compiler10;

public class StaticSuper {

        static {
                System.out.println("super static block");
        }
        
        StaticSuper() { // 생성자 메소드여야 하므로 ()을 넣어준다.
                System.out.println("super constructor");
        }

}



package compiler10;

public class StaticTests extends StaticSuper {

        static int rand; 
        
        static {
                rand = (int) (Math.random() * 6);
                System.out.println("static block " + rand);
        }
        
        StaticTests() {
                System.out.println("constructor");
        }
        
        public static void main(String[] args) {
                System.out.println("in main");
                StaticTests st = new StaticTests();
        }
        
}

/* 출력 결과 :
 super static block
 static block 0
 in main
 super constructor
 constructor */

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

package except;

public class Try1 {

        public static void main(String[] args) {
                
                public void takeRisk() throws BadException {
                        if (abandonAllHope) {
                                throw new BadException();
                        }
                }
                
                public void crossFingers() {
                        try {
                                anObject.takeRisk(); //예외가 발생 할 수 있는 행동
                        } catch (BadException ex) {  //예외가 발생되면 catch 안에 있는걸 실행!
                                System.out.println("Aaargh!");
                                ex.printStackTrance();
                        }
                }
                
        }
}


}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

package musicApp;

import javax.sound.midi.*;

public class MiniMiniMusicApp {

                public static void main(String[] args) {
                        MiniMiniMusicApp mini = new MiniMiniMusicApp(); //미니미니뮤직앱 생성
                        mini.play(); //실행
                } //main 메소드 끝
                
                public void play() {
                        
                        try {
                                Sequencer player = MidiSystem.getSequencer(); //sequencer를 받아서 엽니다.
                                player.open();
                                
                                Sequence seq = new Sequence(Sequence.PPQ, 4);
                                
                                
                                Track track = seq.createTrack(); // sequencer에 track을 요청.
                                
                                ShortMessage a = new ShortMessage(); 
                                a.setMessage(144, 1, 44, 100);
                                MidiEvent noteOn = new MidiEvent(a, 1);
                                track.add(noteOn);
                                
                                ShortMessage b = new ShortMessage();
                                b.setMessage(128, 1, 44, 100);
                                MidiEvent noteOff = new MidiEvent(b, 16);
                                track.add(noteOff); //track에 MidiEvent를 집어넣습니다.
                                
                                player.setSequence(seq); // sequencer에 sequence를 보냅니다.
                                
                                player.start(); //sequencer의 start() 메소드 호출.
                        
                        } catch (Exception ex) {
                                ex.printStackTrace();
                        }

                } // play 메소드 끝
} // 클래스 

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

package musicApp2;

import javax.sound.midi.*;

public class MiniMusicCmdLine {

                public static void main(String[] args) {
                        MiniMusicCmdLine mini = new MiniMusicCmdLine(); 
                        if (args.length < 2) {
                                System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
                        } else {
                                int instrument = Integer.parseInt(args[0]); //악기 선택.
                                int note = Integer.parseInt(args[1]); //음높이 선택.
                                mini.play(instrument, note); //실행
                        }
                } // main 끝
                
                public void play(int instrument, int note) {
                        
                        try {
                                
                                Sequencer player = MidiSystem.getSequencer(); 
                                player.open();
                                Sequence seq = new Sequence(Sequence.PPQ, 4);
                                Track track = seq.createTrack(); 
                                
                                MidiEvent event = null; //초기화.
                                
                                ShortMessage first = new ShortMessage();
                                first.setMessage(192, 1, instrument, 0);
                                MidiEvent changeInstrument = new MidiEvent(first,1);
                                track.add(changeInstrument); //악기 변경.
                                
                                ShortMessage a = new ShortMessage(); 
                                a.setMessage(144, 1, 44, 100);
                                MidiEvent noteOn = new MidiEvent(a, 1);
                                track.add(noteOn);
                                
                                ShortMessage b = new ShortMessage();
                                b.setMessage(128, 1, 44, 100);
                                MidiEvent noteOff = new MidiEvent(b, 16);
                                track.add(noteOff);
                                player.setSequence(seq); 
                                player.start(); 
                        
                        } catch (Exception ex) {
                                ex.printStackTrace();
                        }

                } // play 메소드 끝
} // 클래스

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

package simpleGUI;

import javax.swing.*;

public class SimpleGui1 {
	public static void main(String[] args) {
		
		JFrame frame = new JFrame(); //프레임을 만듭니다.
		JButton button = new JButton("click me"); //click me 버튼을 만듭니다.
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
		
		frame.getContentPane().add(button); //버튼을 추가합니다.
		
		frame.setSize(300,300); //프레임의 전체 크기를 설정합니다.
		
		frame.setVisible(true); //화면에 보이게 설정합니다.
	}
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

package simpleGUI2;

import javax.swing.*;
import java.awt.event.*;

public class SimpleGui1B implements ActionListener { //인터페이스를 구현합니다.
	JButton button;

	public static void main(String[] args) {
		SimpleGui1B gui = new SimpleGui1B();
		gui.go();
	}
	
	public void go() {
		JFrame frame = new JFrame();
		button = new JButton("click me");
		
		button.addActionListener(this); //버튼에 등록합니다. 전달하는 인자는 ActionListener를 구현한 클래스의 객체여야 합니다.
		
		frame.getContentPane().add(button);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event) { //실제 이벤트를 처리하는 메소드.
		button.setText("I've been clicked!");
	}	
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

package simpleGUI3;

import javax.swing.*;
import java.awt.*;

class MyDrawPanel extends JPanel{

        public void paintComponent (Graphics g) {

                Graphics2D g2d = (Graphics2D) g;
                
                int red = (int) (Math.random() * 256);
                int green = (int) (Math.random() * 256);
                int blue = (int) (Math.random() * 256);
                Color startColor = new Color(red, green, blue);
                
                red = (int) (Math.random() * 256);
                green = (int) (Math.random() * 256);
                blue = (int) (Math.random() * 256);
                Color endColor = new Color(red, green, blue);
                
                GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor); // 시작점의 좌표와 색, 끝점의 좌표와 색 표시
                g2d.setPaint(gradient);
                g2d.fillOval(70,70,100,100); // 색
        }
}


package SimpleGUI3;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3A implements ActionListener {

        JFrame frame;
        
        public static void main(String[] args) {
                SimpleGui3A gui = new SimpleGui3A();
                gui.go();
        }
        
        public void go() {
                frame = new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                
                JButton button = new JButton("Change colors");
                button.addActionListener(this); //액션리스너 추가
                
                MyDrawPanel drawPanel = new MyDrawPanel();
                
                frame.getContentPane().add(BorderLayout.SOUTH, button);
                frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
                frame.setSize(300,300);
                frame.setVisible(true);
        }
        
        public void actionPerformed (ActionEvent event) {
                frame.repaint(); // 액션이벤트 작동(클릭)시 repaint함수 작동.
        }       
}

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

package SimpleGUI4;

import javax.swing.*;
import java.awt.*;

class MyDrawPanel extends JPanel{

        public void paintComponent (Graphics g) {

                Graphics2D g2d = (Graphics2D) g;
                
                int red = (int) (Math.random() * 256);
                int green = (int) (Math.random() * 256);
                int blue = (int) (Math.random() * 256);
                Color startColor = new Color(red, green, blue);
                
                red = (int) (Math.random() * 256);
                green = (int) (Math.random() * 256);
                blue = (int) (Math.random() * 256);
                Color endColor = new Color(red, green, blue);
                
                GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
                g2d.setPaint(gradient);
                g2d.fillOval(70,70,100,100);
        }
}


package SimpleGUI4;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class TwoButtons {
        
        JFrame frame;
        JLabel label;
        
        public static void main(String[] args) {

                TwoButtons gui = new TwoButtons ();
                gui.go();

        }
        
        public void go() {

                frame = new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                
                JButton labelButton = new JButton("Change Label"); //첫번째 버튼
                labelButton.addActionListener(new LabelListener());
                
                JButton colorButton = new JButton("Change Circle"); //두번째 버튼
                colorButton.addActionListener(new ColorListner());
                
                label = new JLabel("I'm a label");
                MyDrawPanel drawPanel = new MyDrawPanel();
                
                frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
                frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
                frame.getContentPane().add(BorderLayout.EAST, labelButton);
                frame.getContentPane().add(BorderLayout.WEST, label); //버튼과 라벨들을 배치한다.
                
                frame.setSize(300,300);
                frame.setVisible(true);

        }
        
        class LabelListener implements ActionListener { //첫번째 버튼 액션
                public void actionPerformed(ActionEvent event) {
                        label.setText("Ouch!");
                }
        }
        
        class ColorListner implements ActionListener { //두번째 버튼 액션
                public void actionPerformed(ActionEvent event) {
                        frame.repaint();
                }
        }

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

package animation;

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {

    int x = 70;
    int y = 70;

    public static void main (String[] args) {

       SimpleAnimation gui = new SimpleAnimation ();
       gui.go();
   }

   public void go() {

       JFrame frame = new JFrame();
       frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

       MyDrawPanel drawPanel = new MyDrawPanel();       

       frame.getContentPane().add(drawPanel);
       frame.setSize(300,300);
       frame.setVisible(true);


       for (int i = 0; i < 130; i++) {
          x++;
          y++;
          drawPanel.repaint();
  
          try {
            Thread.sleep(50);
          } catch(Exception ex) { }
       }
    
   }//메소드 끝


    class MyDrawPanel extends JPanel { //내부 클래스
    
       public void paintComponent(Graphics g) {

          g.setColor(Color.white);
          g.fillRect(0,0,this.getWidth(), this.getHeight());

          g.setColor(Color.green);
          g.fillOval(x,y,40,40);

       } //내부 클래스 끝
    }
 
} 

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

package musicvideo;

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;


public class MiniMusicPlayer3 {

    static JFrame f = new JFrame("My First Music Video");
    static MyDrawPanel ml;

    public static void main(String[] args) {
           MiniMusicPlayer3 mini = new MiniMusicPlayer3();
           mini.go();
     }
   
     public  void setUpGui() {
       ml = new MyDrawPanel();
       f.setContentPane(ml);
       f.setBounds(30,30, 300,300);
       f.setVisible(true);
    } //메소드 끝
 

    public void go() {

       setUpGui();

       try {

         Sequencer sequencer = MidiSystem.getSequencer();         
         sequencer.open();
        
         sequencer.addControllerEventListener(ml, new int[] {127});
         Sequence seq = new Sequence(Sequence.PPQ, 4);
         Track track = seq.createTrack();     

      int r = 0;
      for (int i = 0; i < 60; i+= 4) {

          r = (int) ((Math.random() * 50) + 1);
         
          track.add(makeEvent(144,1,r,100,i));
        
          track.add(makeEvent(176,1,127,0,i));
         
          track.add(makeEvent(128,1,r,100,i + 2));
       }

          sequencer.setSequence(seq);
          sequencer.start();
          sequencer.setTempoInBPM(120);

      } catch (Exception ex) {ex.printStackTrace();}
  } //go 메소드 끝


   public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
          MidiEvent event = null;

          try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
            
          }catch(Exception e) { }
          return event;
       } //메소드 끝



 class MyDrawPanel extends JPanel implements ControllerEventListener {
      
      boolean msg = false;

      public void controlChange(ShortMessage event) {
         msg = true;       
         repaint();         
      }

      public void paintComponent(Graphics g) {
       if (msg) {
            
         Graphics2D g2 = (Graphics2D) g;

         int r = (int) (Math.random() * 250);
         int gr = (int) (Math.random() * 250);
         int b = (int) (Math.random() * 250);

         g.setColor(new Color(r,gr,b));

         int ht = (int) ((Math.random() * 120) + 10);
         int width = (int) ((Math.random() * 120) + 10);

         int x = (int) ((Math.random() * 40) + 10);
         int y = (int) ((Math.random() * 40) + 10);
         
         g.fillRect(x,y,ht, width);
         msg = false;

       } // if문 끝
     } // 메소드 끝
   }  // 내부 클래스 끝

} // 클래스 닫기

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

package beatBox;

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {

    JPanel mainPanel;
    ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장.
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", 
       "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", 
       "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", 
       "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", 
       "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명 String 배열로 저장합니다.
    int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63}; // 실제 드럼 '건반'을 나타냅니다. 드럼 채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식.

    public static void main (String[] args) {
        new BeatBox().buildGUI();
    }
  
    public void buildGUI() {
        theFrame = new JFrame("Cyber BeatBox");
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout);
        background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있다.

        checkboxList = new ArrayList<JCheckBox>();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton("Start");
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);         
          
        JButton stop = new JButton("Stop");
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton("Tempo Up");
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton("Tempo Down");
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i < 16; i++) {
           nameBox.add(new Label(instrumentNames[i]));
        }
        
        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);

        theFrame.getContentPane().add(background);
          
        GridLayout grid = new GridLayout(16,16);
        grid.setVgap(1);
        grid.setHgap(2);
        mainPanel = new JPanel(grid);
        background.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i < 256; i++) { // 체크상자를 만들고 모든 값을 'false'로 선정한 다음 ArrayList와 GUI 패널에 추가합니다.                 
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);            
        } // 순환문 끝

        setUpMidi();

        theFrame.setBounds(50,50,300,300);
        theFrame.pack();
        theFrame.setVisible(true);
    } //buildGUI 메소드 끝


    public void setUpMidi() { //시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드.
      try {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequence = new Sequence(Sequence.PPQ,4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
        
      } catch(Exception e) {e.printStackTrace();}
    } 

    public void buildTrackAndStart() {

      int[] trackList = null;
    
      sequence.deleteTrack(track);
      track = sequence.createTrack(); // 기존 트랙 제거, 트랙을 새로 만듬.

        for (int i = 0; i < 16; i++) { // 열 16개를 모두 초기화
          trackList = new int[16];
 
          int key = instruments[i]; //어떤 악기인지 건반 번호 설정.

          for (int j = 0; j < 16; j++ ) { //이 박자에 해당하는 체크상자가 선택되었는지 확인. 선택되어 있으면 배열의 그자리에 건반값을 집어넣음. 그렇지 않으면 그 악기를 연주하지 않아야 하므로 0으로 설정.
              JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));
              if (jc.isSelected()) {
                 trackList[j] = key;
              } else {
                 trackList[j] = 0;
              }                    
           } // 안쪽 for문 끝
         
           makeTracks(trackList); // 16개에 대해 모두 실행
           track.add(makeEvent(176,1,127,0,16));  
       } // 바깥쪽 for문 끝

       track.add(makeEvent(192,9,1,0,15)); //16번째 박자에는 반드시 이벤트!
       try {
           sequencer.setSequence(sequence); 
             sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); // 루프 반복 횟수를 지정하기 위한 메소드.                   
           sequencer.start();
           sequencer.setTempoInBPM(120);
       } catch(Exception e) {e.printStackTrace();} // 연주
    } // buildTrackAndStart 메소드 끝
            
           
    public class MyStartListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            buildTrackAndStart();
        }
    } // 내부 클래스 끝

    public class MyStopListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            sequencer.stop();
        }
    } // 내부 클래스 끝

    public class MyUpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
              float tempoFactor = sequencer.getTempoFactor(); 
            sequencer.setTempoFactor((float)(tempoFactor * 1.03));
        }
     } // 내부 클래스 끝

     public class MyDownTempoListener implements ActionListener {
         public void actionPerformed(ActionEvent a) {
              float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float)(tempoFactor * .97));
        }
    } // 내부 클래스 끝

    public void makeTracks(int[] list) { //한악기의 16박자 전체에 대해 이벤트를 만든다. int[]배열에는 그 악기에 해당하는 건반 번호 또는 0이 들어간다.
       
       for (int i = 0; i < 16; i++) {
          int key = list[i];

          if (key != 0) {
             track.add(makeEvent(144,9,key, 100, i));
             track.add(makeEvent(128,9,key, 100, i+1));
          }
       }
    }
        
    public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);
끝
        } catch(Exception e) {e.printStackTrace(); }
        return event;
    }

} // 클래스 

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

package beatBox2;

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class BeatBox {

    JPanel mainPanel;
    ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장.
    Sequencer sequencer;
    Sequence sequence;
    Track track;
    JFrame theFrame;

    String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", 
       "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", 
       "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", 
       "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo", 
       "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명 String 배열로 저장합니다.
    int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63}; // 실제 드럼 '건반'을 나타냅니다. 드럼 채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식.

    public static void main (String[] args) {
        new BeatBox().buildGUI();
    }
  
    public void buildGUI() {
        theFrame = new JFrame("Cyber BeatBox");
        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        BorderLayout layout = new BorderLayout();
        JPanel background = new JPanel(layout);
        background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10)); // 비어있는 경계선을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있다.

        checkboxList = new ArrayList<JCheckBox>();
        Box buttonBox = new Box(BoxLayout.Y_AXIS);

        JButton start = new JButton("Start");
        start.addActionListener(new MyStartListener());
        buttonBox.add(start);         
          
        JButton stop = new JButton("Stop");
        stop.addActionListener(new MyStopListener());
        buttonBox.add(stop);

        JButton upTempo = new JButton("Tempo Up");
        upTempo.addActionListener(new MyUpTempoListener());
        buttonBox.add(upTempo);

        JButton downTempo = new JButton("Tempo Down");
        downTempo.addActionListener(new MyDownTempoListener());
        buttonBox.add(downTempo);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i < 16; i++) {
           nameBox.add(new Label(instrumentNames[i]));
        }
        
        background.add(BorderLayout.EAST, buttonBox);
        background.add(BorderLayout.WEST, nameBox);

        theFrame.getContentPane().add(background);
          
        GridLayout grid = new GridLayout(16,16);
        grid.setVgap(1);
        grid.setHgap(2);
        mainPanel = new JPanel(grid);
        background.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i < 256; i++) { // 체크상자를 만들고 모든 값을 'false'로 선정한 다음 ArrayList와 GUI 패널에 추가합니다.                 
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);            
        } // 순환문 끝

        setUpMidi();

        theFrame.setBounds(50,50,300,300);
        theFrame.pack();
        theFrame.setVisible(true);
    } //buildGUI 메소드 끝


    public void setUpMidi() { //시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드.
      try {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequence = new Sequence(Sequence.PPQ,4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
        
      } catch(Exception e) {e.printStackTrace();}
    } 

    public void buildTrackAndStart() {

      int[] trackList = null;
    
      sequence.deleteTrack(track);
      track = sequence.createTrack(); // 기존 트랙 제거, 트랙을 새로 만듬.

        for (int i = 0; i < 16; i++) { // 열 16개를 모두 초기화
          trackList = new int[16];
 
          int key = instruments[i]; //어떤 악기인지 건반 번호 설정.

          for (int j = 0; j < 16; j++ ) { //이 박자에 해당하는 체크상자가 선택되었는지 확인. 선택되어 있으면 배열의 그자리에 건반값을 집어넣음. 그렇지 않으면 그 악기를 연주하지 않아야 하므로 0으로 설정.
              JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));
              if (jc.isSelected()) {
                 trackList[j] = key;
              } else {
                 trackList[j] = 0;
              }                    
           } // 안쪽 for문 끝
         
           makeTracks(trackList); // 16개에 대해 모두 실행
           track.add(makeEvent(176,1,127,0,16));  
       } // 바깥쪽 for문 끝

       track.add(makeEvent(192,9,1,0,15)); //16번째 박자에는 반드시 이벤트!
       try {
           sequencer.setSequence(sequence); 
             sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); // 루프 반복 횟수를 지정하기 위한 메소드.                   
           sequencer.start();
           sequencer.setTempoInBPM(120);
       } catch(Exception e) {e.printStackTrace();} // 연주
    } // buildTrackAndStart 메소드 끝
            
           
    public class MyStartListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            buildTrackAndStart();
        }
    } // 내부 클래스 끝

    public class MyStopListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
            sequencer.stop();
        }
    } // 내부 클래스 끝

    public class MyUpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent a) {
              float tempoFactor = sequencer.getTempoFactor(); 
            sequencer.setTempoFactor((float)(tempoFactor * 1.03));
        }
     } // 내부 클래스 끝

     public class MyDownTempoListener implements ActionListener {
         public void actionPerformed(ActionEvent a) {
              float tempoFactor = sequencer.getTempoFactor();
            sequencer.setTempoFactor((float)(tempoFactor * .97));
        }
    } // 내부 클래스 끝


     // - 추가된 부분 -
     public class MySendListener implements ActionListener {
         public void actionPerformed(ActionEvent a) { // 사용자가 버튼을 클릭해서 ActionEvent가 발생된 경우에 실행.  
           boolean[] checkboxState = new boolean[256]; // 체크박스

           for (int i = 0; i < 256; i++) {
               JCheckBox check = (JCheckBox) checkboxList.get(i); // 체크박스를 훑어보면서 체크박스의 상태 확인후 위의 체크박스에 추가.
               if (check.isSelected()) {
                  checkboxState[i] = true;
               }
            }

           try {
              FileOutputStream fileStream = new FileOutputStream(
                  new File("Checkbox.ser"));
              ObjectOutputStream os = new ObjectOutputStream(fileStream);
              os.writeObject(checkboxState);
           } catch(Exception ex) {
               ex.printStackTrace();
           }

         } // 메소드 끝
       } // 클래스 



      public class MyReadInListener implements ActionListener { 
          public void actionPerformed(ActionEvent a) {

            boolean[] checkboxState = null;
            try {
                FileInputStream fileIn = new FileInputStream(
                    new File("Checkbox.ser"));
                ObjectInputStream is = new ObjectInputStream(fileIn);
                checkboxState = (boolean[]) is.readObject(); // 파일에서 객체 하나를 읽은 다음 부울 배열로 다시 캐스트.

            } catch(Exception ex) {ex.printStackTrace();}

            
            for (int i = 0; i < 256; i++) {
               JCheckBox check = (JCheckBox) checkboxList.get(i);
               if (checkboxState[i]) {
                  check.setSelected(true);
               } else {
                  check.setSelected(false);
               }
           } 


          sequencer.stop(); 
          buildTrackAndStart();
        } // 메소드 끝
    } // 클래스 끝
      
      // - 추가 된 부분 끝 - 


    public void makeTracks(int[] list) { //한악기의 16박자 전체에 대해 이벤트를 만든다. int[]배열에는 그 악기에 해당하는 건반 번호 또는 0이 들어간다.
       
       for (int i = 0; i < 16; i++) {
          int key = list[i];

          if (key != 0) {
             track.add(makeEvent(144,9,key, 100, i));
             track.add(makeEvent(128,9,key, 100, i+1));
          }
       }
    }
        
    public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent event = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            event = new MidiEvent(a, tick);

        } catch(Exception e) {e.printStackTrace(); }
        return event;
    }

} //클래스 끝

}}}