#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 김 정곤에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99;
		String word = "bottles"; //복수형
		
		while (beerNum > 0) {
			
			
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum - 1;

			if (beerNum == 1) {
				word = "bottle";	//단수형(한 병인 경우)
			}
			
			if (beerNum > 0) {
				System.out.println(beerNum + " " + word + " of beer on the wall");
			} else {
				System.out.println("No more bottles of beer on the wall");
			}	// else 문 끝
		} // while 순환문 끝
	}	// main 클래스 끝
} // 클래스 끝

/* if 문 을 beerNum = beerNum - 1; 밑으로 내려주어 한병이 되었을 때 단수형으로 표현*/
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic       //PhraswOMatic 이란 클래스를 만듭니다.
{
        public static void main(String[]args)
        {

                String[]wordListOne={"Gon ", "Young-Hyun ", "Chai-Won ","Seo-Yeon ", "Dong-Hyuk ", "Bong-Woo ", "Sung-Ho ", "Jong-Han ", "Dong-Gi ", "Neung-Ho ", "Jong-Ha "};

                String[]wordListTwo={"Hates ", "Loves ", "Likes ", "Hits ", "Kills ", "Kisses ", "Punches "};

                String[]wordListThree={"Hye-Won", "Hyun-Joo", "Ji-Hyun", "Min-Hyung", "Geun-Young", "Yoo-Yeon", "Seung-Won", "Young-Joo"};
                //각각의 단어 리스트를 만듭니다
                int oneLength = wordListOne.length;
                int twoLength = wordListTwo.length;
                int threeLength = wordListThree.length;
                //각각의 정수변수를 만들고 각 그룹의 단어수만큼 대입합니다.

                int rand1 = (int) (Math.random()*oneLength);
                int rand2 = (int) (Math.random()*twoLength);
                int rand3 = (int) (Math.random()*threeLength);
                //난수를 발생시킵니다.

                String phrase=wordListOne[rand1]+""+wordListTwo[rand2]+""+wordListThree[rand3];
                //그룹에서 랜덤하게 하나씩뽑아서 단어를 만듭니다.
                System.out.println("I know that "+phrase);
        }//단어를 출력합니다.
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
실행.
ClassCast Exception 을 발생.
보안 관련 작업
바이트코드가 만들어진 다음 실행되기 전까지 다른 사람이 건드리는지 확인한다.

 * 컴파일러: 
바이트 코드 컴파일러로 프로그램의 실행 속도를 빠르게한다.
변수에 이상한 유형의 데이터를 저장하지 못하게 막는다.
실행 할 때 일어나면 안 되는 일을 방지한다.
비공개 메소드 호출과 바꾸면 안 되는 메소드 변경과 같은 접근 위반을 방지한다.
클래스의 핵심 내용에 접근하는 코드와 함부로 보면 안 되는 코드를 건드리는 것도 방지한다.
우선적으로 문제점을 잡아낸다. 


*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
* A:
/* big x 가 6번 출력됩니다. */
class Exercise1b {
	
	public static void main(String [] args) {
		
		int x = 1;
		while (x<10) {
			
			if (x>3) {
				System.out.println("big x");
			}
			x++; // x에 1을 하나씩 더해주어 while문을 빠져나갈수 있음.
		} //while문 끝
	} //main클래스 끝

} //클래스 끝


* B:
/* small x 가 2번 출력됩니다. */
class Exercise1b { //클래스 선언을 해줍니다.
	
	public static void main(String [] args) {
		
		int x = 5;
		while (x>1) {
			x--;
			if (x<3) {
				System.out.println("small x");
			}
		} //while문 끝
	} //main클래스 끝

} //클래스 끝

* C:
/* small x 가 2번 출력됩니다. */
class Exercise1b {
	
	public static void main(String [] args) { //main클래스를 선언해줍니다.
		
		int x = 5;
		while (x>1) {
			x--;
			if (x<3) {
				System.out.println("small x");
			}
		} //while문 끝
	} //main클래스 끝

} //클래스 끝


}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것, 객체의 상태(데이터)를 나타냄
 * 메소드: 객체에서 할 수 있는 일
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume
 * 메소드: setChannel(), setVolume(), turnOn(), turnOff()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

GuessGame.java :

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();

		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;

		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;

		int targetNumber = (int) (Math.random() * 10);
		System.out.println("Correct 0 ~ 9");

		while(true) {
			System.out.println("Correct number is " + targetNumber + ".");
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();

			guessp1 = p1.number;
			System.out.println("No.1 choice:" + guessp1);

			guessp2 = p2.number;
			System.out.println("No.2 choice:" + guessp2);

			guessp3 = p3.number;
			System.out.println("No.3 choice:" + guessp3);

			guessp4 = p4.number;
			System.out.println("No.4 choice:" + guessp4);

			if (guessp1 == targetNumber) {
				p1isRight = true;
			}

			if (guessp2 == targetNumber) {
				p2isRight = true;
			}

			if (guessp3 == targetNumber) {
				p3isRight = true;
			}

			if (guessp4 == targetNumber) {
				p4isRight = true;
			}

			if (p1isRight || p2isRight || p3isRight || p4isRight) {

				System.out.println("Someone is correct!");
				System.out.println("No.1: " + p1isRight);
				System.out.println("No.2: " + p2isRight);
				System.out.println("No.3: " + p3isRight);
				System.out.println("No.4: " + p4isRight);
				System.out.println("Game set.");
				break;
			} else {
			System.out.println("Replay.");
			}
		}
	}
}


GameLauncher.java :

public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

Player.java :

public class Player {
	int number = 0;

	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("Choice No: " + number);
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
* A:
class TapeDeck{ // TapeDeck 이라는 클래스를 생성

        boolean canRecord=false; // canRecord를 불린값으로 지정

        void playTape(){
                System.out.println("tape playing");
        }

        void recordTape(){
                System.out.println("tape recording");
        }
}

class TapeDeckTestDrive{ // 테스트 클래스
        public static void main(String[]args){

                TapeDeck t=new TapeDeck(); // t객체를 만들어 주어야 한다

                t.canRecord=true;
                t.playTape();

                if(t.canRecord==true){
                        t.recordTape();
                }
        }
}

* B:
class DVDPlayer{
        boolean canRecord=false;
        void recordDVD(){
                System.out.println("DVD recording");
        }
        void playDVD(){ // playDVD 메소드를 만들어야 사용할 수 있게된다.
                System.out.println("DVD playing");
        }
}
class DVDPlayerTestDrive{
        public static void main(String[]args){
                DVDPlayer d = new DVDPlayer();
                d.canRecord=true;
                d.playDVD();
                        if(d.canRecord==true){
                                d.recordDVD();
                        }
        }
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수에는 정수,부울,부동소수점 수와 같은 기초적인 값이 들어갑니다. 그리고 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어갑니다.(접근하는 방법을 나타내는 비트)
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog { // Dog 클래스.
        String name;
        public static void main(String[]args){
                //Dog 객체를 만들고 접근합니다.
                Dog dog1=new Dog();
                dog1.bark();
                dog1.name="Men-Boong";

                //이번에는 Dog 배열을 만듭니다.
                Dog[]myDogs=new Dog[10]; // Dog 10마리가 짖어대겠지..
                myDogs[0]=new Dog();
                myDogs[1]=new Dog();
                myDogs[2]=new Dog();
                myDogs[3]=new Dog();
                myDogs[4]=new Dog();
                myDogs[5]=new Dog();
                myDogs[6]=new Dog();
                myDogs[7]=new Dog();
                myDogs[8]=new Dog();
                myDogs[9]=dog1;  // myDogs[9]에 dog1을 넣어보자

                // 배열 레퍼런스를 써서 Dog 객체에 접근합니다.

                myDogs[0].name="Geun-Young";
                myDogs[1].name="Young-Hun";
                myDogs[2].name="Neung-Ho";
                myDogs[3].name="Dong-Gi";
                myDogs[4].name="Bong-Woo";
                myDogs[5].name="Min-Hyung";
                myDogs[6].name="Seung-Won";
                myDogs[7].name="Chai-Won";
                myDogs[8].name="Yoo-Yeon";

                System.out.print("마지막 개의 이름:");
                System.out.println(myDogs[9].name); // 마지막 개의 이름.

                // 순환문을 써서 배열에 있는 모든 개가 짖도록 합니다.

                int x = 0;
                while(x < myDogs.length){
                        myDogs[x].bark();
                        x = x + 1;
                }
        }

        public void bark(){
                System.out.println(name + "이(가) 깨갱!하고 짖어댑니다.");
        }
        public void eat(){}
        public void chaseCat(){}


}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A:

class Books{ //Books 클래스 생성
        String title;
        String author;
}

class BooksTestDrive{ //TestDrive 생성
        public static void main(String [] args){

                Books [] myBooks = new Books[3]; 
                int x = 0; // Books 몇개를 넣어준다!
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books();
                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";

                while (x < 3) { // 순환문을 돌려 title by author 로 출력!

                    System.out.print(myBooks[x].title);
                    System.out.print(" by ");
                    System.out.println(myBooks[x].author);
                        x = x + 1;
                }               
        }

}

B:
class Hobbits { // Hobbits 클래스를 생성.

        String name;

        public static void main (String [] args) {

                Hobbits [] h = new Hobbits[3];
                int z = 0; // 배열의 인덱스는 0에서 시작.

                while (z<3)     {    // 그러므로 z<3.

                h[z] = new Hobbits(); // 객체를 설정.
                h[z].name = "bilbo";
                if (z==1) {
                        h[z].name = "frodo";
                }
                if (z==2) {
                        h[z].name = "sam";
                }
                System.out.print(h[z].name + " is a ");
                System.out.println("good hobbit name");
                z = z + 1; //마지막으로 z의 값을 1씩 증가시킨다.
                }
        }
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥이 승리자!
 * 문제가 된 부분은 어딘가요?: 켄트의 코드엔 refc가 다음 Contact가 들어올때마다 초기화가되어서 이전의 값은 버려지게된다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:  인스턴스 변수를 부적절한 값으로 설정하기 못하게 막는다.
 캡슐화를 하려면 인스턴스 변수를 private로 지정한 뒤, 접근 제어를 위해 public으로 지정된 게터와 세터를 만들면된다.
언제든지 마음을 바꿀 수 있다.

 * 게터와 세터: 액세서, 뮤테이터. 각각 가져오고 설정하는 역할. 게터는 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도. 세터는 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.

 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언됩니다.
지역변수는 메소드 내에서 선언됩니다.
지역변수는 사용하기 전에 반드시 초기화해야 합니다.(기본값이 없습니다.)
 

*107p Dog* _실행_

{{{

class Dog { //size가 다른 개는 짖는 소리도 다르당께
        int size;
        String name;

        void bark(){ //짖는 소리를 결정합니다.
                if(size>60){
                        System.out.println("Wooof! Wooof!");
                }else if(size>14){
                        System.out.println("Ruff! Ruff!");
                }else{
                        System.out.println("Yip! Yip!");
                }
        }

}
class DogTestDrive{ //Test를 해보자!

        public static void main(String[]args){

                Dog one=new Dog();
                one.size=70;
                Dog two=new Dog();
                two.size=8;
                Dog three=new Dog();
                three.size=35;

                one.bark();
                two.bark();
                three.bark();

        }
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A:

class XCopy {

        public static void main(String[] args) {
                int orig = 42;
                XCopy x = new XCopy(); // XCopy x 생성
                int y = x.go(orig); 
                System.out.println(orig + " " + y); // orig와 y를 출력
        }

        int go(int arg){ //orig의 값은 바뀌지 않는다.
                arg = arg * 2;
                return arg;
        }
}


B:

// 게터와 세터를 이용하여 캡슐화한 코드
class Clock{
        String time;

        void setTime(String t){
                time = t;
        }

        String getTime(){ //리턴 타입 설정
                return time;
        }
}

class ClockTestDrive {

        public static void main(String [] args) {

                Clock c = new Clock();

                c.setTime("1245");
                String tod = c.getTime();
                System.out.println("time: " + tod);
        }
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?  
소프트웨어의 개발 방법론 분야에서 등장.
막판에 스펙이 바뀌어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는 점.

 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive {
        public static void main(String[] args){
                
                int numOfGuesses=0; //추측한 횟수를 위한 변수
                
                GameHelper helper = new GameHelper();        
                SimpleDotCom theDotCom = new SimpleDotCom();//닷컴객체
                
                int randomNum = (int) (Math.random()*5);                
                int[] locations = {randomNum, randomNum+1, randomNum+2}; //첫번째 셀위치를 정하고 배열을만듦
                
                theDotCom.setLocationCells(locations);//닷컴의 위치 지정
                boolean isAlive=true;
                
                while(isAlive==true){ //닷컴이 살아있는지
                        String guess = helper.getUserInput("enter a number"); //입력값 가져오기
                        String result=theDotCom.checkYourself(guess); //맞는지
                        numOfGuesses++;
                        
                        if(result.equals("kill")){
                                isAlive=false;
                                System.out.println(numOfGuesses+" guesses");
                        }//if문 끝
                }//while문 끝               
        }//main문 끝       
}

public class SimpleDotCom {
    int[] locationCells;
    int numOfHits = 0;
    
    public void setLocationCells(int[] locs)
    {
        locationCells = locs;
    }
    
    public String checkYourself(String stringGuess) {
        int guess = Integer.parseInt(stringGuess); //string을 int로 변환
        String result = "miss"; //리턴결과를 저장할 변수 (초기값 miss)
        for (int i = 0; i < locationCells.length; i++) //배열의 각 원소에 대해 반복
        {
            if (guess == locationCells[i]) {
                result = "hit";
                numOfHits++;
                break;
            } //if문 끝
        }//for문 끝
        if (numOfHits == locationCells.length) //죽었을 때
        {
            result = "kill";
        }
        System.out.println(result);
        return result;
    }//메소드 끝
}//클래스 끝

import java.io.*;
public class GameHelper {
        public String getUserInput(String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length()==0)
                                return null;
                        }catch(IOException e){
                                System.out.println("IOException: " + e);
                }
                return inputLine;
        }
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

import java.util.*;

public class DotCom {
    private ArrayList<String> locationCells;
    private String name;

    public void setLocationCells(ArrayList loc) //닷컴의 위치를 갱신하는 세터메소드
    {
        locationCells = loc;
    }

    public void setName(String n) {
	name = n;
    }    

    public String checkYourself(String userInput)
    {
        String status = "miss";
        int index = locationCells.indexOf(userInput); //추측한위치가 맞으면 인덱스리턴, 아니면 -1리턴
        if (index >= 0) {
            locationCells.remove(index);//그 항목을 지운다
            if (locationCells.isEmpty()) { //모든위치를맞췄나
                status = "kill";
		System.out.println("Ouch! You Sunk " + name + "  : ( ");
            } //닷컴이 가라앉았음을 알려줌
            else
            {
                status = "hit";
            }
        }
        return status;
    }
}



import java.util.*;

public class DotComBust {
    private GameHelper helper = new GameHelper();
    private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();
    private int numOfGuesses = 0;
    
    private void setUpGame() {
        DotCom one = new DotCom(); //닷컴객체 3개
        one.setName("Pets.com");
        DotCom two = new DotCom();
        two.setName("eToys.com");
        DotCom three = new DotCom();
        three.setName("Go2.com");
        dotComsList.add(one);
        dotComsList.add(two);
        dotComsList.add(three);
        
        System.out.println("Your goal is to sink three dot coms."); //간단한 설명
        System.out.println("Pets.com, eToys.com, Go2.com");
        System.out.println("Try to sink them all in the fewest number of guesses");
        
        for (DotCom dotComSet : dotComsList) {
            ArrayList<String> newLocation = helper.placeDotCom(3); //위치를 지정하는 보조 메소드 호출
            dotComSet.setLocationCells(newLocation); //보조메소드에서 받아온 위치를 지정
        }
    }
    
    private void startPlaying() {
        while (!dotComsList.isEmpty()) {
            String userGuess = helper.getUserInput("Enter a guess");
            checkUserGuess(userGuess);
        }
        finishGame();
    }
    
    private void checkUserGuess(String userGuess)
    {
        numOfGuesses++; 추측한 횟수 증가
        String result = "miss";
        
        for (DotCom dotComToTest : dotComsList)
        {
            result = dotComToTest.checkYourself(userGuess); //위치가 맞는지
            if (result.equals("hit"))
            {
                break;
            }
            if (result.equals("kill"))
            {
                dotComsList.remove(dotComToTest);
                break;
            }
        }
        System.out.println(result);
    }
    
    private void finishGame() { //결과를 알려주는 메시지 출력
        System.out.println("All Dot Coms are dead!  Your stock is now worthless");
        if (numOfGuesses <= 18) {
            System.out.println("It only took you " + numOfGuesses + " guesses");
            System.out.println("You got out before your options sank.");
        }
        else
        {
            System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
            System.out.println("Fish are dancing with your options.");
        }
    }
    
    public static void main(String[] args) {
        DotComBust game = new DotComBust(); //게임 객체를 만들고
        game.setUpGame(); //게임을 설정하라는 명령
        game.startPlaying(); //게임진행순환문을 돌려라
    }
}



import java.io.*;
import java.util.*;

public class GameHelper {

  private static final String alphabet = "abcdefg";
  private int gridLength = 7;
  private int gridSize = 49;
  private int [] grid = new int[gridSize];
  private int comCount = 0;


  public String getUserInput(String prompt) {
     String inputLine = null;
     System.out.print(prompt + "  ");
     try {
       BufferedReader is = new BufferedReader(
	 new InputStreamReader(System.in));
       inputLine = is.readLine();
       if (inputLine.length() == 0 )  return null; 
     } catch (IOException e) {
       System.out.println("IOException: " + e);
     }
     return inputLine.toLowerCase();
  }

  
  
 public ArrayList<String> placeDotCom(int comSize) {                 
    ArrayList<String> alphaCells = new ArrayList<String>();
    String [] alphacoords = new String [comSize];      // F6같은 좌표가 들어감
    String temp = null;                                // 임시 String배열
    int [] coords = new int[comSize];                  // 현재 후보 좌표
    int attempts = 0;                                  // 시도 횟수를 세기 위한 카운터
    boolean success = false;                           // 적당한 위치를 찾았는지 표시하기 위한 플래그
    int location = 0;                                  // 현재 시작위치
    
    comCount++;                                        // n번째 닷컴
    int incr = 1;                                      // 수평 방향으로 증가시킬 값 설정
    if ((comCount % 2) == 1) {                         // 홀수번째 닷컴인경우(수직으로 배치)
      incr = gridLength;                               // 수직 방향으로 증가시킬 값 설정
    }

    while ( !success & attempts++ < 200 ) {             // 주 검색 순환문(32)
	location = (int) (Math.random() * gridSize);      // 임의 시작 위치를 구함
        //System.out.print(" try " + location);
	int x = 0;                                        // 위치시킬 닷컴의 n번째 위치
        success = true;                                 // 성공할 것으로 가정
        while (success && x < comSize) {                // 닷컴이 들어갈 자리가 비었는지 확인
          if (grid[location] == 0) {                    // 아직 사용하지 않았으면
             coords[x++] = location;                    // 위치저장
             location += incr;                          // 다음 칸 확인
             if (location >= gridSize){                 // 경계를 벗어난 경우
               success = false;                         // 실패
             }
             if (x>0 & (location % gridLength == 0)) {  // 오른쪽으로 경계를 벗어난 경우
               success = false;                         // 실패
             }
          } else {                                      // 이미 사용 중인 경우
              // System.out.print(" used " + location);  
              success = false;                          // 실패
          }
        }
    } // while문 끝

    int x = 0;                                          // 위치를 알파벳 좌표로 바꿈
    int row = 0;
    int column = 0;
    // System.out.println("\n");
    while (x < comSize) {
      grid[coords[x]] = 1;                              // 기본 그리드 좌표를 사용 중 으로 표시
      row = (int) (coords[x] / gridLength);             // 행 값을 구함
      column = coords[x] % gridLength;                  // 열 값을 구함
      temp = String.valueOf(alphabet.charAt(column));   // 숫자로 된 열을 알파벳으로 변환
      
      alphaCells.add(temp.concat(Integer.toString(row)));
      x++;

      // System.out.print("  coord "+x+" = " + alphaCells.get(x-1));
      
    }
    // System.out.println("\n");
    
    return alphaCells;
   }
}

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
import javax.swing.*; //스윙패키지를 불러옵니다.

public class SimpleGui1 {
        public static void main(String[] args) {

                JFrame frame = new JFrame();  //Frame과 Button을 생성합니다.
                JButton button = new JButton("Click me!");

                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //프로그램을 종료하기위해 써줍니다.

                frame.getContentPane().add(button); //ContentPane에 버튼을 넣어줍니다.

                frame.setSize(300,300); //300x300크기의 프레임입니다.

                frame.setVisible(true); //화면에 보이도록 합니다.
        }
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.event.*; //리스너와 액션이벤트가 들어있는 패키지를 불러옵니다.

public class SimpleGui1B implements ActionListener { //인터페이스를 구현합니다.
        JButton button;

        public static void main(String[] args) {
                SimpleGui1B gui = new SimpleGui1B();
                gui.go();
                }

        public void go() {
                JFrame frame = new JFrame();
                button = new JButton("Click me!");

                button.addActionListener(this); // 버튼에 등록합니다.
                frame.getContentPane().add(button);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(300,300);
                frame.setVisible(true);
        }

        public void actionPerformed(ActionEvent event) { //이벤트를 처리하는 메소드입니다.
                button.setText("Clicked!");
        }
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{
MyDrawPanel.java

import javax.swing.*;
import java.awt.*;

class MyDrawPanel extends JPanel{ //JPanel의 하위클래스
	
	public void paintComponent(Graphics g) { // 중요한 그래픽 메소드
		Graphics2D g2d = (Graphics2D) g; //Graphics2D 에 있으므로 캐스트
		
		int red = (int) (Math.random() * 256);
		int green = (int) (Math.random() * 256);
		int blue = (int) (Math.random() * 256);
		Color startColor = new Color(red, green, blue);
		
		red = (int) (Math.random() * 256);
		green = (int) (Math.random() * 256);
		blue = (int) (Math.random() * 256);
		Color endColor = new Color(red, green, blue);
		
		GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
		g2d.setPaint(gradient); //단색이아닌 그래디언트로 지정
		g2d.fillOval(70, 70, 100, 100); //타원을 채우는 메소드
	}

}

------------------------------------------------

SimpleGui3C.java

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class SimpleGui3C implements ActionListener {
	
	JFrame frame;
	
	public static void main (String[] args) {
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
	}
	
	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton button = new JButton("Change colors");
		button.addActionListener(this); //리스너(this)를 버튼에 추가한다
		
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, button);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel); // 위젯 두개를 프레임의 두 지역에 추가
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event) {
		frame.repaint(); //버튼을 누르면 repaint 메소드를 호출한다.
	}

}
}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButtons { //메인 GUI클래스에서 리스너를 구현하지 않는다.
	
	JFrame frame;
	JLabel label;
	
	public static void main (String[] args) {
		TwoButtons gui = new TwoButtons ();
		gui.go();
	}
	
	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton labelButton = new JButton("Change Label");
		labelButton.addActionListener(new LabelListener()); // 리스너 등록 메소드에 this가 아닌 다른 리스너 클래스를 가지고 만든 객체를 전달한다.
		
		JButton colorButton = new JButton("Change Circle");
		colorButton.addActionListener(new ColorListener()); // 위와 마찬가지
		
		label = new JLabel("I'm a label");
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.getContentPane().add(BorderLayout.EAST, labelButton);
		frame.getContentPane().add(BorderLayout.WEST, label); //각 지역에 위젯을 추가한다.
		
		frame.setSize(300,300);
		frame.setVisible(true); 
	}
	
	class LabelListener implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			label.setText("Ouch!"); //내부클래스에서도 label 변수를 사용할 수 있다.
		}
	} //내부클래스 끝
	
	class ColorListener implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			frame.repaint(); //외부 클래스 객체에 대한 레퍼런스 없이 frame 인스턴스 변수를 사용한다.
		}
	} //내부클래스 끝
}
}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
	
	int x = 70;
	int y = 70; //원의 좌표를 저장하기 위한 인스턴스 변수 설정
	
	public static void main (String[] args) {
		SimpleAnimation gui = new SimpleAnimation ();
		gui.go();
	}
	
	public void go() {
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		MyDrawPanel drawPanel = new MyDrawPanel();
		
		frame.getContentPane().add(drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);
		
		for(int i = 0; i < 130; i++) { //130번 반복합니다.
			x++;
			y++;
			
			drawPanel.repaint(); //새로운 위치에 원을 다시 그립니다.
			
			try {
				Thread.sleep(50); //속도를 약간 줄입니다.
			} catch(Exception ex) {}
			}
		} //go()메소드 끝
	
	class MyDrawPanel extends JPanel {
		
		public void paintComponent(Graphics g) {
			g.setColor(Color.white);
			g.fillRect(0,0,this.getWidth(), this.getHeight()); //JPanel로부터 상속받은 메소드
			
			g.setColor(Color.green);
			g.fillOval(x, y, 40, 40);
		}
	} //내부클래스 끝
} //외부클래스 끝
}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {

        static JFrame f = new JFrame("My First Music Video");
        static MyDrawPanel ml;
        
        public static void main(String[] args) {
                MiniMusicPlayer3 mini = new MiniMusicPlayer3();
                mini.go();
        } //메소드 끝
        
        public void setUpGui() {
                ml = new MyDrawPanel();
                f.setContentPane(ml);
                f.setBounds(30,30,300,300);
                f.setVisible(true);
        } //메소드 끝
        
        public void go() {
                setUpGui();
                
                try {
                        
                        Sequencer sequencer = MidiSystem.getSequencer();
                        sequencer.open(); //시퀀서를 만들고 엽니다.
                        sequencer.addControllerEventListener(ml, new int[] {127});
                        Sequence seq = new Sequence(Sequence.PPQ, 4);
                        Track track = seq.createTrack(); //시퀀스와 트랙을 만듭니다.
                        
                        int r = 0;
                        for (int i = 0; i < 60; i+=4) {
                        	
                        	r = (int) ((Math.random() * 50) + 1);
                        	track.add(makeEvent(144,1,r,100,i));
                        	track.add(makeEvent(176,1,127,0,i));
                        	track.add(makeEvent(128,1,r,100,i + 2));
                        } //순환문 끝
                        
                        sequencer.setSequence(seq);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                } catch (Exception ex) {ex.printStackTrace();}
        }// 메소드 끝
        
        public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        	MidiEvent event = null;
        	try {
        		ShortMessage a = new ShortMessage(); //메시지 인스턴스를 만듭니다
        		a.setMessage(comd, chan, one, two);
        		event = new MidiEvent(a, tick);
        		
        	}catch(Exception e) { }
        	return event; //메시지가 모두 들어있는 MidiEvent 리턴
        }// 메소드 끝
        
        class MyDrawPanel extends JPanel implements ControllerEventListener {
        	boolean msg = false; //플래그를 일단 false로 설정합니다.
        	
        	public void controlChange(ShortMessage event) {
        		msg = true; //이벤트를 받아 플래그를 true로 설정합니다.
        		repaint();
        	}
        	
        	public void paintComponent(Graphics g) {
        		if (msg) {
        			
        			Graphics2D g2 = (Graphics2D) g;
        			
        			int r = (int) (Math.random() * 250);
        			int gr = (int) (Math.random() * 250);
        			int b = (int) (Math.random() * 250);
        			
        			g.setColor(new Color(r,gr,b));
        			
        			int ht = (int) ((Math.random() * 120) + 10);
        			int width = (int) ((Math.random() * 120) + 10);
        			
        			int x = (int) ((Math.random() * 40) + 10);
        			int y = (int) ((Math.random() * 40) + 10);
        			
        			g.fillRect(x,y,ht,width);  //무작위로 색과 직사각형을 그리기 위함입니다.
        			msg =  false;
        			
        		}  //if문 끝
        	} // 메소드 끝
        }  // 내부 클래스 끝
} //  클래스 끝
			
}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {

	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; //체크박스를 배열에 저장.
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;
	
	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat",
			"Open Hi-Hat", "Acoustic Snare", "Crash Cymbal", "Hand Clap",
			"High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga",
			"Cow bell", "Vibaraslap", "Low-mid Tom", "High Agogo",
			"Open Hi Conga"}; //악기명을 string으로 저장
	int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63}; // 실제 드럼 건반을 지정.
	
	public static void main (String[] args) {
		new BeatBox().buildGUI();
	}
	
	public void buildGUI() {
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // empty border를 만들어 간격을 만듦.
		
		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);
		
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);
		
		JButton stop = new JButton("Stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);
		
		JButton upTempo = new JButton("Tempo Up");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo);
		
		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo);
		
		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for (int i = 0; i < 16; i++) {
			nameBox.add(new Label(instrumentNames[i]));
		}
		
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);
		
		theFrame.getContentPane().add(background);
		
		GridLayout grid = new GridLayout(16,16);
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER, mainPanel);
		
		for (int i = 0; i < 256; i++) { // 체크박스를 모두 false 로 지정
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		} // 순환문 끝
		
		setUpMidi();
		
		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);
	} // buildGUI 메소드 끝
	
	public void setUpMidi() {
		try {
			sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
			
		} catch(Exception e) {e.printStackTrace();}
	} // setUpMidi 메소드 끝
	
	public void buildTrackAndStart() {
		int[] trackList = null; // 특정 박자에서의 연주 여부를 집어넣습니다.
		
		sequence.deleteTrack(track);
		track = sequence.createTrack(); // 기존 트랙을 제거 후 새 트랙을 만듭니다.
	
		for (int i = 0; i < 16; i++) { // 16개 모두에 같은 작업을 처리.
			trackList = new int[16];
			
			int key = instruments[i]; // 어떤 악기인지 건반 번호를 설정.
		
			for (int j = 0; j < 16; j++) { // 열의 박자에 같은작업을 반복.
			
				JCheckBox jc = checkboxList.get(j + (16*i));
				if ( jc.isSelected()) {
					trackList[j] = key;
				} else {
					trackList[j] = 0;
				}
			} //안쪽 for문 끝
		
			makeTracks(trackList); // 악기의 16박자에 대한 이벤트를 만들고 트랙에 추가.
			track.add(makeEvent(176,1,127,0,16));
		} // 바깥쪽 for문 끝
		
		track.add(makeEvent(192,9,1,0,15)); // 재시작 전에 16박자가 끝나도록 합니다.
		try {
			
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); //계속 반복
			sequencer.start();
			sequencer.setTempoInBPM(120);
		} catch(Exception e) {e.printStackTrace();}
	} // buildTrackAndStart 메소드 끝 (연주)
	
	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			buildTrackAndStart();
		}
	} // 내부 클래스 끝
	
	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			sequencer.stop();
		}
	} //내부 클래스 끝
	
	public class MyUpTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도 3% 증가
		}
	} // 내부 클래스 끝
	
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도 3% 감소
		}
	} // 내부 클래스 끝
	
	
	public void makeTracks (int[] list) {
		
		for(int i = 0; i < 16; i++) {
			int key = list[i];
			
			if (key != 0) {
				track.add(makeEvent(144,9,key, 100, i));
				track.add(makeEvent(128,9,key, 100, i+1)); //노트 ON OFF 이벤트를 만들어 트랙에 추가.
			}
		}
	}
	
	public MidiEvent makeEvent (int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one , two);
			event = new MidiEvent(a, tick);
			
		} catch(Exception e) {e.printStackTrace(); }
		return event;
	}
} // 클래스 끝
}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.*;

public class BeatBox {

        JPanel mainPanel;
        ArrayList<JCheckBox> checkboxList; //체크박스를 배열에 저장.
        Sequencer sequencer;
        Sequence sequence;
        Track track;
        JFrame theFrame;
        
        String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat",
                        "Open Hi-Hat", "Acoustic Snare", "Crash Cymbal", "Hand Clap",
                        "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga",
                        "Cow bell", "Vibaraslap", "Low-mid Tom", "High Agogo",
                        "Open Hi Conga"}; //악기명을 string으로 저장
        int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63}; // 실제 드럼 건반을 지정.
        
        public static void main (String[] args) {
                new BeatBox().buildGUI();
        }
        
        public void buildGUI() {
                theFrame = new JFrame("Cyber BeatBox");
                theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                BorderLayout layout = new BorderLayout();
                JPanel background = new JPanel(layout);
                background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // empty border를 만들어 간격을 만듦.
                
                checkboxList = new ArrayList<JCheckBox>();
                Box buttonBox = new Box(BoxLayout.Y_AXIS);
                
                JButton start = new JButton("Start");
                start.addActionListener(new MyStartListener());
                buttonBox.add(start);
                
                JButton stop = new JButton("Stop");
                stop.addActionListener(new MyStopListener());
                buttonBox.add(stop);
                
                JButton upTempo = new JButton("Tempo Up");
                upTempo.addActionListener(new MyUpTempoListener());
                buttonBox.add(upTempo);
                
                JButton downTempo = new JButton("Tempo Down");
                downTempo.addActionListener(new MyDownTempoListener());
                buttonBox.add(downTempo);
                
                JButton save = new JButton("serializeIt"); //새로운 버튼 추가
                save.addActionListener(new MySendListener());
                buttonBox.add(save);
                
                JButton restore = new JButton("restore"); //새로운 버튼 추가
                restore.addActionListener(new MyReadInListener());
                buttonBox.add(restore);
                
                Box nameBox = new Box(BoxLayout.Y_AXIS);
                for (int i = 0; i < 16; i++) {
                        nameBox.add(new Label(instrumentNames[i]));
                }
                
                background.add(BorderLayout.EAST, buttonBox);
                background.add(BorderLayout.WEST, nameBox);
                
                theFrame.getContentPane().add(background);
                
                GridLayout grid = new GridLayout(16,16);
                grid.setVgap(1);
                grid.setHgap(2);
                mainPanel = new JPanel(grid);
                background.add(BorderLayout.CENTER, mainPanel);
                
                for (int i = 0; i < 256; i++) { // 체크박스를 모두 false 로 지정
                        JCheckBox c = new JCheckBox();
                        c.setSelected(false);
                        checkboxList.add(c);
                        mainPanel.add(c);
                } // 순환문 끝
                
                setUpMidi();
                
                theFrame.setBounds(50,50,300,300);
                theFrame.pack();
                theFrame.setVisible(true);
        } // buildGUI 메소드 끝
        

		public void setUpMidi() {
                try {
                        sequencer = MidiSystem.getSequencer();
                        sequencer.open();
                        sequence = new Sequence(Sequence.PPQ,4);
                        track = sequence.createTrack();
                        sequencer.setTempoInBPM(120);
                        
                } catch(Exception e) {e.printStackTrace();}
        } // setUpMidi 메소드 끝
        
        public void buildTrackAndStart() {
                int[] trackList = null; // 특정 박자에서의 연주 여부를 집어넣습니다.
                
                sequence.deleteTrack(track);
                track = sequence.createTrack(); // 기존 트랙을 제거 후 새 트랙을 만듭니다.
        
                for (int i = 0; i < 16; i++) { // 16개 모두에 같은 작업을 처리.
                        trackList = new int[16];
                        
                        int key = instruments[i]; // 어떤 악기인지 건반 번호를 설정.
                
                        for (int j = 0; j < 16; j++) { // 열의 박자에 같은작업을 반복.
                        
                                JCheckBox jc = checkboxList.get(j + (16*i));
                                if ( jc.isSelected()) {
                                        trackList[j] = key;
                                } else {
                                        trackList[j] = 0;
                                }
                        } //안쪽 for문 끝
                
                        makeTracks(trackList); // 악기의 16박자에 대한 이벤트를 만들고 트랙에 추가.
                        track.add(makeEvent(176,1,127,0,16));
                } // 바깥쪽 for문 끝
                
                track.add(makeEvent(192,9,1,0,15)); // 재시작 전에 16박자가 끝나도록 합니다.
                try {
                        
                        sequencer.setSequence(sequence);
                        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); //계속 반복
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                } catch(Exception e) {e.printStackTrace();}
        } // buildTrackAndStart 메소드 끝 (연주)
        
        public class MyStartListener implements ActionListener {
                public void actionPerformed(ActionEvent a) {
                        buildTrackAndStart();
                }
        } // 내부 클래스 끝
        
        public class MyStopListener implements ActionListener {
                public void actionPerformed(ActionEvent a) {
                        sequencer.stop();
                }
        } //내부 클래스 끝
        
        public class MyUpTempoListener implements ActionListener {
                public void actionPerformed(ActionEvent a) {
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도 3% 증가
                }
        } // 내부 클래스 끝
        
        public class MyDownTempoListener implements ActionListener {
                public void actionPerformed(ActionEvent a) {
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도 3% 감소
                }
        } // 내부 클래스 끝
        
        public class MySendListener implements ActionListener {
        	public void actionPerformed(ActionEvent a) {
        		boolean[] checkboxState = new boolean[256];
        		for(int i = 0; i < 256; i++) {
        			JCheckBox check = (JCheckBox) checkboxList.get(i);
        			if (check.isSelected()) {
        				checkboxState[i] = true;
        			}
        		}
        		try {
        			FileOutputStream fileStream = new FileOutputStream(new File("Checkbox.ser"));
        			ObjectOutputStream os = new ObjectOutputStream(fileStream);
        			os.writeObject(checkboxState);
        		} catch(Exception ex) {
        			ex.printStackTrace();
        		}
        	}//메소드 끝
        }//내부클래스 끝
        
        public class MyReadInListener implements ActionListener {
        	public void actionPerformed(ActionEvent a) {
        		boolean[] checkboxState = null;
        		try {
        			FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
        			ObjectInputStream is = new ObjectInputStream(fileIn);
        			checkboxState = (boolean[]) is.readObject();
        		} catch(Exception ex) {ex.printStackTrace();}
        		
        		for (int i = 0; i < 256; i++) {
        			JCheckBox check = (JCheckBox) checkboxList.get(i);
        			if (checkboxState[i]) {
        				check.setSelected(true);
        			} else {
        				check.setSelected(false);
        			}
        		}
        		
        		sequencer.stop();
        		buildTrackAndStart();
        
        	}
        }
        
        
        public void makeTracks (int[] list) {
                
                for(int i = 0; i < 16; i++) {
                        int key = list[i];
                        
                        if (key != 0) {
                                track.add(makeEvent(144,9,key, 100, i));
                                track.add(makeEvent(128,9,key, 100, i+1)); //노트 ON OFF 이벤트를 만들어 트랙에 추가.
                        }
                }
        }
        
        public MidiEvent makeEvent (int comd, int chan, int one, int two, int tick) {
                MidiEvent event = null;
                try {
                        ShortMessage a = new ShortMessage();
                        a.setMessage(comd, chan, one , two);
                        event = new MidiEvent(a, tick);
                        
                } catch(Exception e) {e.printStackTrace(); }
                return event;
        }
} // 클래스 끝

}}}