#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
1 bottles라는 문제가 생기므로 이를 1 bottle이 되도록 코드를 바꾸어 주어야 한다.
public class BeerSong {//클레스 생성
	public static void main(String[] args){//매소드 생성
		int beerNum=99;
		String word ="bottles";
		
		while(beerNum>0){
			if(beerNum==1){
				word="bottle";
			}
			System.out.println(beerNum +" "+word+" of beer on the wall");
			System.out.println(beerNum +" "+word+" of beer.");
			System.out.println("take one down");
			System.out.println("pass it around");
			beerNum=beerNum-1;
			
			if(beerNum>0){
				if(beerNum==1){
					word="bottle";//beerNum이 1이 되었을 때 여전이 bottles이므로 bottle로 바꾸어주는 부분이다.
				}
				System.out.println(beerNum +" "+word+" of beer on the wall");
			}
			else{
				System.out.println("no more bottles");
				
			}
		}
	}

}
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main(String[] args){
		String[] wordListOne={"alternate","ascertain","borrow","bound","commute","convoluted","cramped","curb"};
		
		String[] wordListTwo={"descent", "designate","destination","detour","deviate","direction","fare","fine"};
		
		String[] wordListThree={"hail","impassable","interrupt","jam","jaywalk","locate","mileage","mount"};
		
		int oneLength=wordListOne.length;
		int twoLength=wordListTwo.length;
		int threeLength=wordListThree.length;
		
		int rand1=(int)(Math.random()*oneLength);
		int rand2=(int)(Math.random()*twoLength);
		int rand3=(int)(Math.random()*threeLength);
		
		String phrase=wordListOne[rand1]+ " "+wordListTwo[rand2]+" "+wordListThree[rand3];
		System.out.println("what we need is a "+ phrase);
	}

}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:동적 바인딩을 지원하기 위해 ClassCast Exception을 발생시킨다. 바이트코드가 만들어진 다음 다음 실행 전까지 다른 사람이 건드리지 않았는지 확인한다.
 * 컴파일러: 바이트코드로 바꾸어 주어 실행가능하도록 해준다. 변수에 이상한 유형의 데이터를 저장할 수 없게 해준다. 비공개 매소드 호출이나 절대 바꿔서는 안되는 매소드 변경 방지

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class Exercise1bA {
	public static void main(String [] args){
		int x=1;
		while(x<10){
			if(x>3){
				System.out.println("big x");
			}
			x++;//x의 값을 변경시켜주어 while문이 무한히 돌지 않도록 하였다.
		}
	}
}


public class Exercise1bB {//클레스 부분이 빠져있어 클레스를 선언해주었다.
	public static void main(String [] args){
		int x=5;
		while(x>1){
			x=x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}

public class Exercise1bC {
	public static void main(String [] args){//메소드 부분이 빠져있어 메소드를 추가해 주었습니다.
		int x=5;
		while(x>1){
			x=x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터), 각 객체마다 값이 다르다.
 * 메소드: 객체에서 할 수 있는 일
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: power, channel, volume
 * 메소드: turnOnAndOff(), changeChannel(), changeVolume() 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{


public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1= new Player();
		p2= new Player();
		p3= new Player();
		p4= new Player();
		
		int guessp1=0;
		int guessp2=0;
		int guessp3=0;
		int guessp4=0;
		
		boolean p1isRight=false;
		boolean p2isRight=false;
		boolean p3isRight=false;
		boolean p4isRight=false;//기본적인 블리언 값 거짓으로 저장
		
		int targetNumber=(int) (Math.random()*10);//0이상 9이하 숫자를 타켓 숫자로 지정
		
		System.out.println("0이상 9이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는  " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: "+guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: "+guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: "+guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: "+guessp4);
			
			if(guessp1==targetNumber){
				p1isRight=true;//숫자를 맞추면 블리언 값이 참으로 바뀐다.
			}

			if(guessp2==targetNumber){
				p2isRight=true;
			}
			
			if(guessp3==targetNumber){
				p3isRight=true;
			}
			
			if(guessp4==targetNumber){
				p4isRight=true;
			}
			
			if(p1isRight||p2isRight||p3isRight||p4isRight){
				System.out.println("맞춘 선수가 있습니다");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p3isRight);
				System.out.println("게임 끝");
				break;
				
			} 
			
			else{
				System.out.println("다시 시도해야 합니다");
				
						
			}
						
		}
	}

}
}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
//A


class TapeDeck {
	boolean canRecord=false;
	
	void playTape(){
		System.out.println("tape playing");
	}
	
	void recordTape(){
		System.out.println("tape recording");
	}
}


class TapeTestTestDrive {
	public static void main(String[] args){
		TapeDeck t = new TapeDeck();//TapeDeck객체 생성이 안되어 있으므로 추가해준다.
		t.canRecord=true;
		t.playTape();
		
		if(t.canRecord==true){
			t.recordTape();
		}
	}

}

//B


class DVDPlayer {
	boolean canRecord=false;
	
	void playDVD(){
		System.out.println("DVD playing");//playDVD 메소드가 빠져있으므로 추가해 주어야한다.
	}
	
	void recordDVD(){
		System.out.println("DVD recording");
	}

}

class DVDPlayerTestDrive {
	public static void main(String [] args){
		
		DVDPlayer d =new DVDPlayer();
		d.canRecord= true;
		d.playDVD();
		
		if(d.canRecord==true){
			d.recordDVD();
		}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수에는 정수, 부울, 부동소수점 수와 같은 것이 들어가지만 래퍼런스변수에는 객체에 대한 레퍼런스가 들어간다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
	String name;
	public static void main(String[] args){
		Dog dog1=new Dog();
		dog1.bark();
		dog1.name="Bart";
		
		Dog[] myDogs=new Dog[8];
		
		myDogs[0]=new Dog();
		myDogs[1]=new Dog();
		myDogs[2]=dog1;
		myDogs[3]=new Dog();
		myDogs[4]=new Dog();
		myDogs[5]=new Dog();
		myDogs[6]=new Dog();
		myDogs[7]=new Dog();
		
		myDogs[0].name="Fred";
		myDogs[1].name="Marge";
		myDogs[2].name="Brian";
		myDogs[3].name="Jane";
		myDogs[4].name="Marry";
		myDogs[5].name="Sophia";
		myDogs[6].name="William";
		myDogs[7].name="Sam";
		
		System.out.print("마지막 개의 이름: ");
		System.out.println(myDogs[7].name);
		
		int x=0;
		while(x<myDogs.length){
			myDogs[x].bark();
			x=x+1;
		}
	}

public void bark(){
	System.out.println(name+"이(가) 왈!하고 짖습니다.");
}

public void eat(){}
public void chaseCat(){}
}
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

//A

class Books {
	String title;
	String author;

}//Books 클래스 선언

class BooksTestDrive {
	public static void main(String [] args){
		Books [] myBooks=new Books[3];
		int x=0;
		
		myBooks[0]=new Books();//Books배열에 들어있는 원소는 Books 레퍼런스 변수에 불과하기 때문에 Books 객체를 만들어 주어야 한다.
		myBooks[1]=new Books();
		myBooks[2]=new Books();
		
		myBooks[0].title="The Grape of Java";
		myBooks[1].title="The Java Gatsby";
		myBooks[2].title="The Java Cookbook";
		myBooks[0].author="bob";
		myBooks[1].author="sue";
		myBooks[2].author="ian";
		
		while(x<3){
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x=x+1;
			
		}
		
		
	}

}

//B

class Hobbits {	
	String name;
}
//Hobbits 클래스 생성
class HobbitsTestDrive {
	public static void main(String [] args){
		Hobbits [] h= new Hobbits[3];
		int z=0;
		
		while(z<3){//총 3개의 배열을 선언했으므로 z<3이 되어야한다
			h[z] = new Hobbits();//Hobbits 객체 생성
			h[z].name="bilbo";
			if(z==1){
				h[z].name="frodo";
			}
			if(z==2){
				h[z].name="sam";
			}
	
		
		System.out.print(h[z].name + " is a ");
		System.out.println("good Gobbit name");
		z++;//z값을 증가시켜 반복문이 나중에 끝나도록 해준다.
		}
	}

}


}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥이 이겼다.
 * 문제가 된 부분은 어딘가요?: 둘 다  객체를 10개를 만든다. 밥의 경우는 10개의 객체를 만들어 모두에 접근할 수 있지만 켄트의 경우는 10개 중에 마지막 객체에만 접근하므로 문제가 된다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: private이라는 접근 변경자를 사용하여 데이터를 숨긴다.
 * 게터와 세터: 게터는 가져오기로 되어있는 값을 리턴값형태로 받아오고 세터는 설정할 값을 인자로 받아서 설정한다.
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언하지만 지역 변수는 메소드 내에서 선언한다.
 
*107p Dog* _실행_

{{{

class Dog {
	int size;
	String name;
	
	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof!");
		}
		else if(size>14){
			System.out.println("Ruff! Ruff!");
		}
		else{
			System.out.println("Yip! Yip!");
		}
	}

}

class DogTestDrive {
	public static void main(String[] args){
		Dog one=new Dog();
		one.size=70;
		Dog two=new Dog();
		two.size=8;
		Dog three=new Dog();
		three.size=35;
		
		one.bark();
		two.bark();
		three.bark();
	}

}



}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class XCopy {
	public static void main(String[] args){
		int orig=42;
		
		XCopy x= new XCopy();
		int y = x.go(orig);
		
		System.out.println(orig+" "+ y);
	}
		int go(int arg){
			arg=arg*2;
			
			return arg;
		
	}

}

class Clock {
	String time;
	
	void setTime(String t){
		time=t;
		
	}
	
	String getTime(){
		return time;
	}
	
}

class ClockTestDrive {
	public static void main(String [] args){
		
		Clock c= new Clock();
		
		c.setTime("1245");
		String tod= c.getTime();
		System.out.println("time: "+tod);
	}

}


}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 최근 프로그램 개발 방법론으로 테스트 코드를 먼저 만든다. 사이클을 반복해서 개발한다. 야근은 하지마라 등의 규칙이 있다.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
//같은 숫자를 반복해서 입력해서 게임이 끝나는 문제가 있다.
public class SimpleDotComTestDrive {
	public static void main(String[] args){
		
		int numOfGuesses=0;
		
		GameHelper helper = new GameHelper();		
		SimpleDotCom theDotCom = new SimpleDotCom();
		
		int randomNum = (int) (Math.random()*5);		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		
		theDotCom.setLocationCells(locations);
		boolean isAlive=true;
		
		while(isAlive==true){
			String guess = helper.getUserInput("enter a number");
			String result=theDotCom.checkYourself(guess);
			numOfGuesses++;
			
			if(result.equals("kill")){
				isAlive=false;
				System.out.println(numOfGuesses+" guesses");
			}
		}		
	}	
}

public class SimpleDotCom {
	int[] locationCells;
	int numOfHits=0;
	
	public void setLocationCells(int[] locs){
		locationCells=locs;
	}

	public String checkYourself(String stringGuess){
		int guess=Integer.parseInt(stringGuess);
		String result="miss";
		for(int i=0;i<locationCells.length;i++){
			if(guess==locationCells[i]){
				result="hit";
				numOfHits++;
				break;
			}
		}
		if(numOfHits==locationCells.length){
		result="kill";
		
		}
		System.out.println(result);
			return result;
	}

}
import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()==0)
				return null;
			}catch(IOException e){
				System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
//boolean hitCells를 만들어 맞추면 true로 바꾸어주어 문제를 해결한다.
public class SimpleDotComTestDrive {
	public static void main(String[] args){
		
		int numOfGuesses=0;
		
		GameHelper helper = new GameHelper();		
		SimpleDotCom theDotCom = new SimpleDotCom();
		
		int randomNum = (int) (Math.random()*5);		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		
		theDotCom.setLocationCells(locations);
		boolean isAlive=true;
		
		while(isAlive==true){
			String guess = helper.getUserInput("enter a num1ber");
			String result=theDotCom.checkYourself(guess);
			numOfGuesses++;
			
			if(result.equals("kill")){
				isAlive=false;
				System.out.println(numOfGuesses+" guesses");
			}
		}		
	}	
}

public class SimpleDotCom {
	int[] locationCells;
	boolean[] hitCells = {false, false, false};
	int numOfHits=0;
	
	public void setLocationCells(int[] locs){
		locationCells=locs;
	}

	public String checkYourself(String stringGuess){
		int guess=Integer.parseInt(stringGuess);
		String result="miss";
		for(int i=0;i<locationCells.length;i++){
			if(guess==locationCells[i]&&!hitCells[i]){
				result="hit";
				hitCells[i]=true;
				numOfHits++;
				break;
			}
		}
		if(numOfHits==locationCells.length){
		result="kill";
		
		}
		System.out.println(result);
			return result;
	}
}

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()==0)
				return null;
			}catch(IOException e){
				System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
//맞추면 원래값을 -1로 바꾸어주어 다시 못 맞추게 바꾼다.
public class SimpleDotComTestDrive {
	public static void main(String[] args){
		
		int numOfGuesses=0;
		
		GameHelper helper = new GameHelper();		
		SimpleDotCom theDotCom = new SimpleDotCom();
		
		int randomNum = (int) (Math.random()*5);		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		
		theDotCom.setLocationCells(locations);
		boolean isAlive=true;
		
		while(isAlive==true){
			String guess = helper.getUserInput("enter a num1ber");
			String result=theDotCom.checkYourself(guess);
			numOfGuesses++;
			
			if(result.equals("kill")){
				isAlive=false;
				System.out.println(numOfGuesses+" guesses");
			}
		}		
	}	
}

public class SimpleDotCom {
        int[] locationCells;
        int numOfHits=0;
        
        public void setLocationCells(int[] locs){
                locationCells=locs;
        }

        public String checkYourself(String stringGuess){
                int guess=Integer.parseInt(stringGuess);
                String result="miss";
                for(int i=0;i<locationCells.length;i++){
                        if(guess==locationCells[i]&&locationCells[i]!=-1){
                                result="hit";
                                locationCells[i]=-1;
                          
                                numOfHits++;
                                break;
                        }
                }
                if(numOfHits==locationCells.length){
                result="kill";
                
                }
                System.out.println(result);
                        return result;
        }

}

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()==0)
				return null;
			}catch(IOException e){
				System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
//ArrayList를 이용해서 맞추면 그 배열을 없앤다. 따라서 3개의 배열이 있었는데 하나를 맞추면 2개로 줄어든다.
import java.util.ArrayList;


public class SimpleDotComTestDrive {
	public static void main(String[] args){
		
		int numOfGuesses=0;
		
		GameHelper helper = new GameHelper();		
		SimpleDotCom theDotCom = new SimpleDotCom();
		
		int randomNum = (int) (Math.random()*5);		
//		int[] locations = {randomNum, randomNum+1, randomNum+2};
		
		
		
		ArrayList<String> locations = new ArrayList<String>();
		
		locations.add(Integer.toString(randomNum));
		locations.add(Integer.toString(randomNum+1));
		locations.add(Integer.toString(randomNum+2));
		
		
		theDotCom.setLocationCells(locations);
		boolean isAlive=true;
		
		while(isAlive==true){
			String guess = helper.getUserInput("enter a number");
			String result=theDotCom.checkYourself(guess);
			numOfGuesses++;
			
			if(result.equals("kill")){
				isAlive=false;
				System.out.println(numOfGuesses+" guesses");
			}
		}		
	}	
}

import java.util.ArrayList;

public class SimpleDotCom {
	private ArrayList<String> locationCells;
   
public void setLocationCells(ArrayList<String> loc){
        locationCells=loc;
    }

public String checkYourself(String userinput){
        String result="miss";
        int index = locationCells.indexOf(userinput);
        if(index>=0){
        	locationCells.remove(index);
        	
        	if(locationCells.isEmpty()){
                result="kill";
        				}
        	else{
        		result="hit";
        		
        				}
        			}
        System.out.println(result);
        return result;
    }

}

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length()==0)
				return null;
			}catch(IOException e){
				System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}
}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
import java.util.*;
import java.io.*;

public class DotComBust {
    private GameHelper helper = new GameHelper();
    private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();
    private int numOfGuesses = 0;
    
    private void setUpGame(){
        DotCom one = new DotCom();
        one.setName("pets.com");
        DotCom two = new DotCom();
        two.setName("eToys.com");
        DotCom three = new DotCom();
        three.setName("Go2.com");
        dotComsList.add(one);
        dotComsList.add(two);
        dotComsList.add(three);
        
        System.out.println("your goal is to sink three dot coms");
        System.out.println("pets.com, eToys.com, go2.com");
        System.out.println("try to sink them all in the fewest numver of guesses");
        
        for(DotCom dotComToSet : dotComsList){
            ArrayList<String> newLocation = helper.placeDotCom(3);
            dotComToSet.setLocationCells(newLocation);
            
        }
    }
    
    private void startPlaying(){
        
        while(!dotComsList.isEmpty()){
            String userGuess= helper.getUserInput("enter a guess");
            checkUserGuess(userGuess);
            
        }
        finishGame();
    }

    private void checkUserGuess(String userGuess){
        numOfGuesses++;
        String result = "miss";
        
        for(DotCom dotComToTest: dotComsList){
            result=dotComToTest.checkYourself(userGuess);
            
            if(result.equals("hit")){
                break;
            }
            
            if(result.equals("kill")){
                dotComsList.remove(dotComToTest);
                break;
            }
        }
        System.out.println(result);
    }
    
    private void finishGame(){
        System.out.println("all dot coms are dead! your stock is now worthless");
        if(numOfGuesses<=18){
            System.out.println("it only took you "+numOfGuesses+ " guesses.");
            System.out.println("you got out before your options sank");        
            }
        else{
            System.out.println("took you long enough. " + numOfGuesses+ " guesses");
            System.out.println("fish are dancing with your options");
        }
    }
    
    public static void main(String[] args){
        DotComBust game=new DotComBust();
        game.setUpGame();
        game.startPlaying();    
    }
    
}

import java.util.*;

public class DotCom{
    private ArrayList<String> locationCells;
    private String name;
    
    public void setLocationCells(ArrayList loc){
        locationCells= loc;
    }
    
    public void setName(String n){
        name = n;
    }
    
    public String checkYourself(String userInput){
        String status= "miss";
        int index = locationCells.indexOf(userInput);
        if(index>=0){
            locationCells.remove(index);
            if(locationCells.isEmpty()){
                status="kill";
                System.out.println("Ouch you sunk" + name+" ( ");
            }else{
                status="hit";
            }
        }
        return status;
    }
}

import java.io.*;
import java.util.*;

public class GameHelper{
    private static final String alphabet="abcdefg";
    private int gridLength=7;
    private int gridSize=49;
    private int [] grid = new int[gridSize];
    private int comCount=0;
    
    public String getUserInput(String prompt){
        String inputLine = null;
        System.out.print(prompt+" ");
        try{
            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
            inputLine=is.readLine();
            if(inputLine.length()==0)
                return null;
        }catch(IOException e){
            System.out.println("OExeption: "+e);
            
        }
        return inputLine.toLowerCase();
    }
    
    public ArrayList<String> placeDotCom(int comSize){
        ArrayList<String> alphaCells = new ArrayList<String>();
        String [] alphacoords= new String[comSize];
        String temp=null;
        int [] coords= new int[comSize];
        int attempts=0;
        boolean success=false;
        int location=0;
        
        comCount++;
        int incr =1;
        if((comCount%2)==1){
            incr=gridLength;
            
        }
        
        while(!success&attempts++<200){
            location =(int) (Math.random()*gridSize);
            System.out.print("try" +location);
            int x=0;
            success=true;
            while(success&&x<comSize){
                if(grid[location]==0){
                    coords[x++]=location;
                    location+=incr;
                    if(location>=gridSize){
                        success=false;
                    }
                    if(x>0&(location%gridLength==0)){
                        success=false;
                    }
                    }else{
                        System.out.print("used" +location);
                        success=false;
                    }
                }
            }
            
            int x=0;
            int row=0;
            int column=0;
            System.out.println("\n");
            while(x<comSize){
                grid[coords[x]]=1;
                row=(int)(coords[x]/gridLength);
                column=coords[x]%gridLength;
                temp=String.valueOf(alphabet.charAt(column));
                
                alphaCells.add(temp.concat(Integer.toString(row)));
                x++;
                System.out.print("   coord  "+x+" = "+ alphaCells.get(x-1));
            }
            
            System.out.println("\n?");
            return alphaCells;
        
    }
}
  

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상속은 공통적인 코드가 있을 때에,공통적인 부분을 상위클래스에 넣어주고 더 구체적인 클래스에 공통적이지 않은 부분을 넣어준다. 하위클래스에서 별도의 메소드와 인스턴스 변수를 추가할 수도 잇고 메소드를 오버라이드할 수도 있다.
 * 다형성:  다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다. 또 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{


public class Animal {
	String picture;
	String food;
	int hunger;
	int boundaries;
	int location;
	
	public void makeNoise(){}
	public void eat(){}
	public void sleep(){}
	public void roam(){}
	
}

 class Feline extends Animal{
	 public void roam(){}
 }
 
 class Hippo extends Animal{
	 public void makeNoise(){}
	 public void eat(){}
 }
 
 class Canine extends Animal{
	 public void roam(){}
 }
 
 class Lion extends Feline{
	 public void makeNoise(){}
	 public void eat(){}
 }
 
 class Tiger extends Feline{
	 public void makeNoise(){}
	 public void eat(){}
 }
 
 class Cat extends Feline{
	 public void makeNoise(){}
	 public void eat(){}
 }
 
 class Wolf extends Canine{
	 public void makeNoise(){}
	 public void eat(){}
 }
 
 class Dog extends Canine{
	 public void makeNoise(){}
	 public void eat(){}
 }

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이드에서 인자는 똑같아야하고 리턴 유형은 호환 가능해야 한다. 또 매소드를 더 접근하기 어렵게 만들면 안된다.
 * 오버로딩:  오버로딩은 이름이 같고 인자 목록이 다른 메소드를 여러개 만드는 것이다. 이때 리턴 유형이 달라도 되지만 리턴 유형만 바꿀 수는 없고 접근 단계도 마음대로 바꿀 수 없다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive {
	public static void main(String [] args){
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x=0; x<3; x++){
			ma[x].frighten(x);
		}
	}

}

class Monster{//int형 변수를 받아 boolean값을 리턴한다.
	boolean frighten(int d){
	System.out.println("arrrgh");
	return true;
	}
}

class Vampire extends Monster{//int형 변수를 받아 boolean값을 리턴한다.
	boolean frighten(int x){
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster{//int형 변수를 받아 boolean값을 리턴한다.
	boolean frighten(int degree){
		System.out.println("breath fire");
		return true;
		}
	}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 인터페이스는 100% 추상 클래스이다. 
 * 다형성: 상위클래스를 만들면 상위클래스 형식이 하위클래스에 속하는 객체를 마음대로 사용할 수 있다.
 * 추상 클래스: 인스턴스를 만들 수 없는 클래스이고 반드시 확장해야 하는 클래스이다.
 * 추상 메소드: 반드시 오버라이드해야하는 메소드이다.
 * 다중 상속: 상위 클래스를 여러개 접근하는 것.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:객체가 사는 곳 
 * 스택에서의 변수: 메소드 호출과 지역 변수가 살아가는 곳
 * 생성자: 메소드와 거의 똑같지만 메소드가 아니다. 어떤 클래스의 인스턴스를 만들 때 실행할 코드가 들어있다.
 * 널 레퍼런스: 리모콘 기능을 해제하는 것
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체를 지원하는 역할을 하며 항상 객체와 함께 한다.
 * 지역 변수: 스택에 들어있고 위에 있는 메소드가 끝나야 실행된다.

*302p 5분 미스터리* _구현후 주석달기_

{{{
//상속부분을 제거하여 20:(5+10)=4:3이 되게 하였다.

import java.util.ArrayList;
class V2Radiator {
    V2Radiator(ArrayList list){
        for(int x=0;x<5;x++){
            list.add(new SimUnit("V2Radiator"));
        }
    }

}

class V3Radiator{
    V3Radiator(ArrayList lglist){
        //super(lglist); 상위클래스의 메소드를 오버라이드 하는 것
        for(int g=0;g<10;g++){
            lglist.add(new SimUnit("V3Radiator"));
        }
    }
}

class RetentionBot{
    RetentionBot(ArrayList rlist){
        rlist.add(new SimUnit("Retention"));
    }
}

public class TestLifeSupportSim{
    public static void main(String[] args){
        ArrayList aList =new ArrayList();
        V2Radiator v2 = new V2Radiator(aList);
        V3Radiator v3 = new V3Radiator(aList);
        for(int z=0;z<20;z++){
            RetentionBot ret = new RetentionBot(aList);
        }
    }
}


class SimUnit{
    String botType;
    SimUnit(String type){
        botType = type;
    }
    int powerUse(){
        if("retention".equals(botType)){
            return 2;
        } else{
            return 4;
        }
    }
} 


}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 클래스의 인스턴스없이 메소드를 실행할 수 있다.
 * 정적 메소드를 선언하는 방법: static을 붙여 사용한다.
 * static final: 이렇게 선언된 변수는 상수이고 final로 지정한 변수는 값을 바꿀 수 없다.
 * 널 레퍼런스: 리모콘 기능을 해제하는 것
 * 오토 박싱: 원시값과 객체 사이의 경계를 없애는 것
 * 정적 임포트: 정적클래스, 정적 변수, enum 등을 사용할 때 타이핑을 적게 하도록 돕는다.

*339p Calendar* _구현후 주석달기_

{{{
import java.util.*;

public class CalendarEx {
	public static void main(String[] args){
		Calendar c= Calendar.getInstance();
		c.set(2004,0,7,15,40);
		long day1=c.getTimeInMillis();
		day1+=1000*60*60;
		c.setTimeInMillis(day1);
		System.out.println("new hour "+ c.get(c.HOUR_OF_DAY));
		c.add(c.DATE, 35);
		System.out.println("add 35 days " + c.getTime());
		c.roll(c.DATE, 35);
		System.out.println("roll 35 days " + c.getTime());
		c.set(c.DATE, 1);
		System.out.println("set to 1 " + c.getTime());
	}
	

}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 객체지향 프로그래밍에서 많이 사용되는 변수
 * 지역 변수: 클래스라는 객체안에 존재, 클래스에 속하는 인스턴스에 의해서 공유

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class StaticTests extends StaticSuper {
	static int rand;
	
	static{
		rand=(int)(Math.random()*6);
		System.out.println("static block " + rand);
	}
	
	StaticTests(){
		System.out.println("constructor");
	}
	
	public static void main(String [] args){
		System.out.println("in main");
		StaticTests st= new StaticTests();
	}
	


}

class StaticSuper{
	static{
		System.out.println("super static block");
	}
	
	StaticSuper(){//()추가
		System.out.println("super constructor");
	}
}
}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{
		public void takeRisk() throws BadException{
			if(abandonAllHope){
				throw new BadException();
			}
		}
		
		public void crossFingers(){
			try{//실행한다
				anObject.takeRisk();
			}catch(BadException ex){//오류가 발생한 경우
				System.out.println("Aaargh!");
				ex.printStackTrace();
			}
		}
}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{
import javax.sound.midi.*;

public class MiniMiniMusicApp {
	public static void main(String[] args){
		MiniMiniMusicApp mini= new MiniMiniMusicApp();//객체 생성
		mini.play();
	}
	
	public void play(){
		try{
			Sequencer player=MidiSystem.getSequencer();
			player.open();
			
			Sequence seq = new Sequence(Sequence.PPQ,4);
			
			Track track = seq.createTrack();
			
			ShortMessage a= new ShortMessage();//MidiEvent 집어넣기
			a.setMessage(144, 1, 44,100);
			MidiEvent noteOn= new MidiEvent(a,1);
			track.add(noteOn);
			
			ShortMessage b= new ShortMessage();
			b.setMessage(128,1,44,100);
			MidiEvent noteOff= new MidiEvent(b,16);
			track.add(noteOff);
			
			player.setSequence(seq);
			player.start();//실행
		}catch(Exception ex){
			ex.printStackTrace();
		}
	}

}

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{
import javax.sound.midi.*;

public class MiniMusicCmdLine {	
	public static void main(String[] args){
		MiniMusicCmdLine mini= new MiniMusicCmdLine();//객체 생성
		if(args.length<2){
			System.out.println("악기의 음 높이를 지정하는 인자를 입력하세요.");
		}else{
			int instrument = Integer.parseInt(args[0]);
			int note=Integer.parseInt(args[1]);
			mini.play(instrument, note);
		}
	}
	
	public void play(int instrument, int note){
		try{
			Sequencer player= MidiSystem.getSequencer();
			player.open();
			Sequence seq= new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack();
			
			MidiEvent event=null;
			
			ShortMessage first = new ShortMessage();//MidiEvent 집어넣기
			first.setMessage(192,1,instrument,0);
			MidiEvent changeInstrument=new MidiEvent(first,1);
			track.add(changeInstrument);
			
			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,note,100);
			MidiEvent noteOn=new MidiEvent(a,1);
			track.add(noteOn);		
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,note,100);
			MidiEvent noteOff=new MidiEvent(b,16);
			track.add(noteOff);	
			player.setSequence(seq);
			player.start();//실행
		}catch(Exception ex){ex.printStackTrace();}
	}
}

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

import javax.swing.*;

public class SimpleGuil {
	public static void main(String[] args){
		JFrame frame =new JFrame();//프레임 생성
		JButton button =new JButton("click me");//버튼 생성 및 버튼 생성자에 버튼에 표시할 텍스트 전달
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//창을 닫았을 때 프로그램이 종료 된다
		frame.getContentPane().add(button);//버튼을 프레임 내용틀에 추가
		frame.setSize(300,300);
		frame.setVisible(true);
		
	}

}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.event.*;

public class SimpleGui1B implements ActionListener{
	JButton button;
	
	public static void main(String[] args){
		SimpleGui1B gui = new SimpleGui1B();
		gui.go();
	}
	
	public void go(){
		JFrame frame = new JFrame();
		button =new JButton("click me");
	
	button.addActionListener(this);
	
	frame.getContentPane().add(button);
	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	frame.setSize(300,300);
	frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event){
		button.setText("I've been clicked!");
	}
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {
	JFrame frame;
	public static void main(String[] args){
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
	}
	
	public void go(){
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton button= new JButton("change colors");
		button.addActionListener(this);//리스너를 버튼에 추가한다.
		
		MyDrawPanel drawPanel =new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH, button);//프레임의 남쪽에 추가한다.
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	
	public void actionPerformed(ActionEvent event){
		frame.repaint();//사용자가 버튼을 클릭하면 paintComponent()메소드 호출된다.
	}
	
	class MyDrawPanel extends JPanel{
		public void paintComponent(Graphics g){
			g.fillRect(0, 0, this.getWidth(), this.getHeight());//왼쪽 끝에서 0픽셀, 위쪽 끝에서 0픽셀에서 시작하여 전체를 검은색으로 칠한다.
			
			int red = (int)(Math.random()*255);
			int green = (int)(Math.random()*255);
			int blue = (int)(Math.random()*255);
			
			Color randomColor=new Color(red, green, blue);
			g.setColor(randomColor);
			g.fillOval(70,70,100,100); //왼쪽에서 70픽셀, 위에서 70픽셀인 곳에서 너비와 높이가 100픽셀인 원을 그린다.
	}

	}
}

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

import javax.swing.*;

import java.awt.*;
import java.awt.event.*;

public class TwoButtons {
	JFrame frame;
	JLabel label;
	
	public static void main(String[] args){
		TwoButtons gui = new TwoButtons();
		gui.go();
		
		}
	
	public void go(){
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JButton labelButton= new JButton("change label");
		labelButton.addActionListener(new LabelListener());
		JButton colorButton=new JButton("change circle");
		colorButton.addActionListener(new ColorListener());
		
		label= new JLabel("I'm a label");
		MyDrawPanel drawPanel=new MyDrawPanel();
		
		frame.getContentPane().add(BorderLayout.SOUTH,colorButton);
		frame.getContentPane().add(BorderLayout.CENTER,drawPanel);
		frame.getContentPane().add(BorderLayout.EAST,labelButton);
		frame.getContentPane().add(BorderLayout.WEST,label);
		
		frame.setSize(300,300);
		frame.setVisible(true);
		
	}
	
	class LabelListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			label.setText("Ouch!");
		}
	}
	
	class ColorListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			frame.repaint();
		}
	}
	
	class MyDrawPanel extends JPanel{
		public void paintComponent(Graphics g){
			g.fillRect(0, 0, this.getWidth(), this.getHeight());//왼쪽 끝에서 0픽셀, 위쪽 끝에서 0픽셀에서 시작하여 전체를 검은색으로 칠한다.
			
			int red = (int)(Math.random()*255);
			int green = (int)(Math.random()*255);
			int blue = (int)(Math.random()*255);
			
			Color randomColor=new Color(red, green, blue);
			g.setColor(randomColor);
			g.fillOval(70,70,100,100); //왼쪽에서 70픽셀, 위에서 70픽셀인 곳에서 너비와 높이가 100픽셀인 원을 그린다.
	}

	}

}


}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
	int x= 70;
	int y= 70;
	
	public static void main(String[] args){
		SimpleAnimation gui = new SimpleAnimation();
		gui.go();
	}
	
	public void go(){
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		MyDrawPanel drawPanel= new MyDrawPanel();
		frame.getContentPane().add(drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);
		for(int i=0;i<130;i++)
		{
			x++;
			y++;
			
			drawPanel.repaint();
			
			try{
				Thread.sleep(50);
			}catch(Exception ex){}
		}
	}
		
		class MyDrawPanel extends JPanel{
			public void paintComponent(Graphics g){
				g.setColor(Color.green);
				g.fillOval(x, y, 40, 40);
			}
		}

}

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}