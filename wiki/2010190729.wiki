#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
문제 : 48p의 코드를 실행시켜 보면 1bottle일때 1bottles 라고 나오는데, if의 위치를 바꿔 주면 해결할수 있다.



public class Beersong {
		public static void main(String[] args){
				int beerNum = 99;
				String word = "bottles";//복수형
				
				while(beerNum > 0)//beerNum이 0보다 크면 실행
				{
					System.out.println(beerNum + " " + word + " of beer on the wall");
//beerNum이라는 문자열과 " "(띄어쓰기) 를 붙이는 "+" 를 사용
					System.out.println(beerNum + " " + word + " of beer");
					System.out.println("Take one down.");
					System.out.println("pass it around.");
					beerNum = beerNum-1;
					if(beerNum==1)//beerNum이1이면 실행, 단수형(한 병인 경우)
					{
						word = "bottle";
					}
					if(beerNum>0)//beerNum이 0보다크면 실행
					{
						System.out.println(beerNum + " " + word + " of beer on the wall");
					}else//beerNum이 0보다 크지않으면 실행
					{
						System.out.println("No more bottles of beer on the wall");
					}//else문 끝
				}//while문 끝
		}//main클래스 끝
}//클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
        public static void main (String[] args) {

                String[] wordListOne = {"dynamic", "beautiful", "wonderful", "nice", "good",
                                        "hot", "rainy", "crowded"};

                String[] wordListTwo = {"Paris", "Tokyo", "Beijing", "Seoul", "Newyork",
                                        "Hongkong", "London", "Sydney"};

                String[] wordListThree = {"with family", "with friends", "with girl friend",
                                        "with boy friend", "with sister", "with brother", "alone" };

//
                int oneLength = wordListOne.length;
                int twoLength = wordListTwo.length;
                int threeLength = wordListThree.length;

                int rand1 = (int) (Math.random() * oneLength);
                int rand2 = (int) (Math.random() * twoLength);
                int rand3 = (int) (Math.random() * threeLength);

                String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

                System.out.println("I will go to " + phrase);
                }
        }
~                                                                                                              
~                   
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 보안 관련 작업을 한다. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 건드리지 않았는지 확인하는 작업도 한다.
 * 컴파일러: 프로그래밍언어를 바이트코드로 바꿔준다. 자바가 순수한 인터프리터 언어라면 가상 머신에서 텍스트 편집기로 만든 소스 코드를 해석해야 될 테고, 그러면 자바 프로그램 실행속도는 느려지게 된다. 세미콜론을 체크 한다. 자바는 유형을 지키는 언어이기 때문에, 변수에 이상한 유형의 데티러를 저장할수 없게 하는 일을 한다. 비공개(private) 메소드를 호출하려고 한다거나 절대 바꿔서는 안 되는 메소드를 변경하려는 것을 방지한다. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class Exercise1b{
        public static void main(String[] args) {
                int x = 1;
                while( x < 10 ) { //x가 10보다 작기 때문에 while문 안으로 들어감
                        if ( x > 3 ) { //x가 3보다는 작기 때문에 실행되지 않음
                                System.out.println("big x");
                        }
                } // while 문에서 갇혀버리게 된다. x가 증가하지 않고 그대로 x=1에 머물러 있기 때문에 컴파일은 되고 실행도 되지만 아무일도 일어나지 않고 프로그램이 계속 돌아가게 된다.
        }
}
}}}
{{{

B
// 맨 첫줄에 class가 정의되어 있지 않기 때문에 컴파일이 되지 않는다.
public static void main(String[] args){
        int x= 5;
        while (x>1) { // x가 1보다 크기 때문에 while문으로 들어온다
                x = x - 1; // while문이 한번 돌때마다 1씩 줄어든다.
                if ( x < 3 ) { // 맨 처음에 4, 그리고 다음번째에는 3이 된다. 
                        System.out.println("small x"); // x가 4일때에만 한번 if문이 실행되므로 small x 라는 문장이 1회 출력된다.
                }
        }
}

}}}
{{{

C
// class는 존재하지만 main함수가 없기 때문에 컴파일이 되지 않는다.
class Exercise1b{
        int x = 5;  
        while ( x >1 ) { // x가 5이기 때문에 처음에 while문이 실행된다.
                x = x - 1; // x가 1씩 줄어든다.
                if ( x < 3 ) { // 위와 같이 맨처음엔 4, 다음엔 3
                        System.out.println("small x"); // x가 4일때만 한번 if문이 실행
                }
        }
}   

}}}
= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 아는 것
 * 메소드: 객체에서 하는 것
 * 클래스: 객체에 해당하는 클래스
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스이며, 테스트용 클래스에는 main() 메소드가 들어가며 그 main() 메소드에서 테스트할 클래스 유형의 객체를 만들어서 접근한다.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channels
 * 메소드: turnOff(), turnOn(), changeChannel(), volumeUp(), volumeDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame{
        Player p1;
        Player p2;
        Player p3;
        Player p4;
        // Player 객체 4개를 저장하기위한 인스턴트 변수 네개

        public void startGame(){
                p1 = new Player();
                p2 = new Player();
                p3 = new Player();
                p4 = new Player(); // player 객체 네 개를 생성하고 각각을 player 인스턴스 변수 네 개에 대입

                int guessp1 = 0;
                int guessp2 = 0;
                int guessp3 = 0;
                int guessp4 = 0; // player 객체 네 개에서 찍은 숫자를 저장하기 위해 변수 네 개를 선언.

                boolean p1isRight = false;
                boolean p2isRight = false;
                boolean p3isRight = false;
                boolean p4isRight = false;

                int targetNumber = (int) (Math.random() * 10);
                System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

                while(true){
                        System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");

                        p1.guess();
                        p2.guess();
                        p3.guess();
                        p4.guess();

                        guessp1 = p1.number;
                        System.out.println("1번 선수가 찍은 숫자: " + guessp1);

                        guessp2 = p2.number;
                        System.out.println("2번 선수가 찍은 숫자: " + guessp2);

                        guessp3 = p3.number;
                        System.out.println("3번 선수가 찍은 숫자: " + guessp3);

                        guessp4 = p4.number;
                        System.out.println("4번 선수가 찍은 숫자: " + guessp4);

                        if (guessp1 == targetNumber) {
                                p1isRight = true;
                        }

                        if (guessp2 == targetNumber) {
                                p2isRight = true;
                        }

                        if (guessp3 == targetNumber) {
                                p3isRight = true;
                        }

                        if (guessp4 == targetNumber) {
                                p4isRight = true;
                        }

                        if (p1isRight || p2isRight || p3isRight || p4isRight) {

                                System.out.println("맞춘 선수가 있습니다.");
                                System.out.println("1번 선수: "+ p1isRight);
                                System.out.println("2번 선수: "+ p2isRight);
                                System.out.println("3번 선수: "+ p3isRight);
                                System.out.println("4번 선수: "+ p4isRight);
                                System.out.println("게임 끝.");
                                break;
                        } else{
                                System.out.println("다시 시도해야 합니다.");
                        }
                }
        }
}

}}}

{{{

public class Player{
        int number = 0;

        public void guess() {
                number = (int) (Math.random() * 10);
        }
}

}}}

{{{          
public class GameLauncher {
        public static void main (String[] args) {
                GuessGame game = new GuessGame();
                game.startGame();
        }
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class TapeDeck{

        boolean canRecord = false;

        void playTape() {
                System.out.println("tape playing");
        }

        void recordTape() {
                System.out.println("tape recording");
        }
}

}}}

{{{

class TapeDeckTestDrive {
        public static void main(String [] args) {

                t.canRecord = true; //객체의 이름은 canRecord가 아닌 TapeDeck이다 따라서 TapeDeck t = new TapeDeck(); 으로 새로운 t를 생성해준다.
                                    // 그 후에 t.canRecord = true;
                t.playTape();

                if (t.canRecord == true) {
                        t.recordTape();
                }
        }
}

}}}

{{{
class DVDPlayer {

        boolean canRecord = false;

        void recordDVD() {
                System.out.println("DVD recording");
        }
        // 테스트드라이브에서 playDVD라는 메소드를 불러오고 있지만 존재하지 않기 때문에 넣어주어야 한다
        /* void playDVD() {
                  System.out.println("DVD playing");
           }
        */
}
}}}

{{{
class DVDPlayerTestDrive {
        public static void main( String [] args) {

                DVDPlayer d = new DVDPlayer();
                d.canRecord = true;
                d.playDVD(); //DVDPlayer라는 객체에는 playDVD라는 메소드가 존재하지 않는다.

                if ( d.canRecord == true ) {
                        d.recordDVD();
                }
        }
}

}}}



= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 
원시변수(primitive variable)는 정수, 부울, 부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이다. 객체 레퍼런스(object reference) 객체에 대한 레퍼런스가 들어간다.
원시변수와 레퍼런스변수 둘 어떤 유형에 무관하게 두가지 선언 규칙은 반드시 준수해야 한다.
1. 변수에는 유형이 있어야한다.
2. 변수에는 이름이 있어야한다. 
예) int(유형) count;(이름)

또한 자바에는 변수의 이름을 정할 수 있다는 특징이 있다. 
예)
int size = 32; size라는 int변수 32라는 값을 대입
char initial = 'j'; initial이라는 char변수를 선언하고 'j'라는 값을 대입
double d = 456.709; d라는 double 변수를 선언하고 456.709라는 값을 대입
boolean isCrazy; isCrazy라는 boolean 변수를 선언(값은 대입하지 않음)
isCrazy = true; 앞서 선언한 isCrazy에 true라는 값을 대입
int y =  x + 456; y라는 int변수를 선언하고 x의 현재 값에 456을 더한 값을 대입
 
객체 변수 레퍼런스라는 것
1.객체 변수라는 것은 존재하지 않는다. 2. 객체 레퍼런스 변수라는 것만 존재. 3. 객체 레퍼런스에는 객채에 접근하는 방법을 알려주는 비트가 있다. 4.객체 레퍼런스에 객체 자체가 들어있는 것은 아님. 그 레퍼런스가 객체 단 하나를 가리킨다. 

레퍼런스 변수에 대해 점 연산자(.)을 사용하면 "점 앞에 있는 것을 이용해서 점 뒤에 있는 것을 갖다주세요." 예) myDog.bark();  myDog라는 변수로 참조할 수 있는 객체를 이용하여 bark()메소드를 호출하라.

원시변수 byte x = 7; 7을 나타내는 비트들이 변수에 저장(00000111)
레퍼런스 변수 Dog myDog = new Dog(); Dog객체에 접근하는 방법을 나타내는 비트들이 변수에 저장됩니다. (Dog 객체 자체는 변수에 저장되지 않습니다.)

객체 선언, 생성과 대입의 3단계
1. 레퍼런스 변수 선언 : Dog myDog = new Dog(); 레퍼런스 변수용 공간을 할당해달라는 요청을 한 다음 그 변수명을 myDog로 지정. 이렇게 하고 나면 myDog라는 레퍼런스 변수는 영원히 Dog유형의 변수가됨. 즉 Dog 객체를 제어하기 위한 버튼이 장착된 리모컨.
2. 객체 생성 : Dog myDog = new Dog(); : 힙에 새로운 Dog객체를 위한 공간을 마련하도록 지시
3. 객체와 레퍼런스 연결 : 새로운 Dog 객체를 myDog라는 레퍼런스 변수에 대입합니다. 즉, 리모컨의 기능을 결정.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog{
        String name;
        public static void main(String [] args){
                Dog dog1 = new Dog();
                dog1.bark();
                dog1.name = "Bart";

                Dog[] myDogs = new Dog[5];
                myDogs[0] = new Dog();
                myDogs[1] = new Dog();
                myDogs[2] = new Dog();
                myDogs[3] = new Dog();
                myDogs[4] = dog1;

                myDogs[0].name = "Fred";
                myDogs[1].name = "Marge";
                myDogs[2].name = "Tom";
                myDogs[3].name = "Kate";
                myDogs[4].name = "Suri";

                System.out.print("마지막 개의 이름: ");
                System.out.println(myDogs[4].name);

                int x = 0;
                while(x<myDogs.length){
                        myDogs[x].bark();
                        x=x+1;
                        }
        }

        public void bark() {
                System.out.println(name + " 이(가) 왈!하고 짖습니다.");
        }
        public void eat(){}
        public void chaseCat() {}
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class Books{
        String title;
        String authour;
        }

class BooksTestDrive{ // public class로 지정을 해주어야 한다. 파일명도 BooksTestDrive.java
        public static void main(String [] args) {
                Books[] myBooks = new Books[3];
                int x = 0;
                // myBooks[0]~myBooks[2]의 객체를 생성하지 않았기 때문에 이후의 명령이 실행되지 않기 때문에, myBooks[0] = new Books();... 를 추가해야한다.
                myBooks[0].title = "The Grapes of Java"; 
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";

                while ( x < 3 ) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}


}}}


{{{

class Hobbits{
        String name;

        public static void main(String [] args) {
                Hobbits [] h = new Hobbits[3];
                int z = 0;

                while ( z < 4 ) { // Hobbits배열은 Hobbits[0~2]까지이므로 ( z < 3 ) 으로 바꾸어야 한다.
                        z = z + 1; // 첫번째 인덱스가 0이기 때문에 z = z + 1 을 while문의 끝으로 이동시켜야한다.
                        h[z] =  new Hobbits();
                        h[z].name = "bilbo";
                        if ( z == 1 ) {
                                h[z].name = "frodo";
                        }

                        if ( z == 2 ) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.print("good Hobbit name");
                        //z = z+1;
                }
        }
}
}}}
*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:밥
 * 문제가 된 부분은 어딘가요?:
켄트의 메소드는 사용한 레퍼런스 변수의 개수는 작았지만 그의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수가 없다는 문제가 있었다. 순환문을 돌 때마다 새로운 객체를 전에 레퍼런스 변수 하나에 대입했기 때문에 이전의 것은 사라져버린다.

따라서 켄트의 코드는 사실 객체 한개에만 접근 할 수 있기 때문에 쓸모가 없는 메소드이다.
{{{
밥의 코드
Contact[] ca = new Contact[10];
while ( x < 10 ) { // 연락처 객체 10개를 만듭니다.
 ca[x] = new Contact();
 x = x + 1;
}

켄트의 코드
Contact refc;
while( x < 10 ) { // 연락처 객체 10개를 만듭니다.
 refc = new Contact();
 x = x + 1;
}

}}}



= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
데이터와 자신이 구현한 코드를 나중에 수정할 권한을 보호할 수 있도록 구현하는 방법. public 과 private라는 접근 변경자를 사용하면 데이터를 숨길수가 있다. 캡슐화를 하려면 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만들면 된다.
(( 인스턴스 변수는 private로! 게터와 세터는 public으로! ))

캡슐화는 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다. 다른 코드에서 항상 세터 메소드를 사용하게 한다. 세터 메소드에서 매개변수의 값을 확인하고 그 값이 올바른 값인지 결정할 수 있다. 인스턴스 변수가 공개된 경우에는 아무 것도 할 수 없지만 세터 메소드를 사용하면 자신이 원하는 것을 모두 할 수있다.

세터에서 가장 중요한 점은 나중에 뭔가를 변경하더라도 다른 코드는 건드리지 않아도 된다는 점이다. 


 * 게터와 세터: 
정식명칭은 getter-accessor / setter-mutator이다. 게터와 세터라는 명칭은 자바에서 일반적으로 메소드에 이름을 붙이는 방법하고도 연관이 있다. getter와 setter는 보통 인스턴스 변수의 값에 대해 가져오고 설정하는 작업을 한다. 
getter 는 getter가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 사용.
setter 는 setter가 설정한 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 사용.
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_
{{{
class Dog2 { //전의 실습에서 Dog이라는 class가 있기때문에 Dog2라는 class를 생성
        int size;
        String name;

        void bark() {
                if ( size > 60 ) {
                        System.out.println("Wooof! Wooof!");
                } else if ( size > 14 ) {
                        System.out.println("Ruff! Ruff!" );
                } else {
                        System.out.println("Yip! Yip!");
                }
        }
}
}}}
{{{
class Dog2TestDrive{

        public static void main( String[] args) {
                Dog2 one = new Dog2();
                one.size = 70;
                Dog2 two = new Dog2();
                two.size = 8;
                Dog2 three = new Dog2();
                three.size = 35;

                one.bark();
                two.bark();
                three.bark();
        }
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 
소프트웨어 공학과는 다른 프로그래밍 방법론으로 "프로그래머들이 정말 원하는 방법"이다.
그의 규칙에는 1.조금씩, 자주 2.사이클을 반복해서 개발 3.스펙에 없는 것은 넣지 않는다. 4.테스트코드를 먼저 만든다. 그외 어디서든 개선, 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획, 모든 일을 단순하게 처리 한다 등이 있다.

 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive{

        public static void main (String[] args){
                SimpleDotCom dot = new SimpleDotCom();          
                int[] locations = {2,3,4};                      //위치 2,3,4
                dot.setLocationCells(locations);                //dot의 locationCells를 locations로 지정
                String userGuess = "2";                         
                String result = dot.checkYourself(userGuess);   
        }
}

class SimpleDotCom{
        int[] locationCells;
        int numOfHits=0;

        public void setLocationCells(int[] locs){
                locationCells = locs;                           //locationsCells에 2,3,4 입력
        }

        public String checkYourself(String stringGuess){
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0; i<locationCells.length; i++){    //locationCells에 guess가 있는지 확인
                        if (guess == locationCells[i]){
                                result = "hit";
                                numOfHits++;
                                break;
                        }
                }
                if (numOfHits == locationCells.length){
                result = "kill";
                }
                System.out.println(result);
                return result;
        }
}


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{



}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:A라는 클래스가 B로부터 상속을 받는다고 하면, A는 하위클래스(subclass)가 되고, B는 상위클래스(superclass)가 된다. 상위 클래스에 어떤 기능이 있으면 하위클래스에서도 상속하는 클래스의 메소드를 기능을 사용 할 수 있다. 이러한 것을 상속이라고 한다.
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}