#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
문제 : 48p의 코드를 실행시켜 보면 1bottle일때 1bottles 라고 나오는데, if의 위치를 바꿔 주면 해결할수 있다.



public class Beersong {
		public static void main(String[] args){
				int beerNum = 99;
				String word = "bottles";//복수형
				
				while(beerNum > 0)//beerNum이 0보다 크면 실행
				{
					System.out.println(beerNum + " " + word + " of beer on the wall");
//beerNum이라는 문자열과 " "(띄어쓰기) 를 붙이는 "+" 를 사용
					System.out.println(beerNum + " " + word + " of beer");
					System.out.println("Take one down.");
					System.out.println("pass it around.");
					beerNum = beerNum-1;
					if(beerNum==1)//beerNum이1이면 실행, 단수형(한 병인 경우)
					{
						word = "bottle";
					}
					if(beerNum>0)//beerNum이 0보다크면 실행
					{
						System.out.println(beerNum + " " + word + " of beer on the wall");
					}else//beerNum이 0보다 크지않으면 실행
					{
						System.out.println("No more bottles of beer on the wall");
					}//else문 끝
				}//while문 끝
		}//main클래스 끝
}//클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
        public static void main (String[] args) {

                String[] wordListOne = {"dynamic", "beautiful", "wonderful", "nice", "good",
                                        "hot", "rainy", "crowded"};

                String[] wordListTwo = {"Paris", "Tokyo", "Beijing", "Seoul", "Newyork",
                                        "Hongkong", "London", "Sydney"};

                String[] wordListThree = {"with family", "with friends", "with girl friend",
                                        "with boy friend", "with sister", "with brother", "alone" };

//
                int oneLength = wordListOne.length;
                int twoLength = wordListTwo.length;
                int threeLength = wordListThree.length;

                int rand1 = (int) (Math.random() * oneLength);
                int rand2 = (int) (Math.random() * twoLength);
                int rand3 = (int) (Math.random() * threeLength);

                String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

                System.out.println("I will go to " + phrase);
                }
        }
~                                                                                                              
~                   
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 보안 관련 작업을 한다. 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 건드리지 않았는지 확인하는 작업도 한다.
 * 컴파일러: 프로그래밍언어를 바이트코드로 바꿔준다. 자바가 순수한 인터프리터 언어라면 가상 머신에서 텍스트 편집기로 만든 소스 코드를 해석해야 될 테고, 그러면 자바 프로그램 실행속도는 느려지게 된다. 세미콜론을 체크 한다. 자바는 유형을 지키는 언어이기 때문에, 변수에 이상한 유형의 데티러를 저장할수 없게 하는 일을 한다. 비공개(private) 메소드를 호출하려고 한다거나 절대 바꿔서는 안 되는 메소드를 변경하려는 것을 방지한다. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class Exercise1b{
        public static void main(String[] args) {
                int x = 1;
                while( x < 10 ) { //x가 10보다 작기 때문에 while문 안으로 들어감
                        if ( x > 3 ) { //x가 3보다는 작기 때문에 실행되지 않음
                                System.out.println("big x");
                        }
                } // while 문에서 갇혀버리게 된다. x가 증가하지 않고 그대로 x=1에 머물러 있기 때문에 컴파일은 되고 실행도 되지만 아무일도 일어나지 않고 프로그램이 계속 돌아가게 된다.
        }
}
}}}
{{{

B
// 맨 첫줄에 class가 정의되어 있지 않기 때문에 컴파일이 되지 않는다.
public static void main(String[] args){
        int x= 5;
        while (x>1) { // x가 1보다 크기 때문에 while문으로 들어온다
                x = x - 1; // while문이 한번 돌때마다 1씩 줄어든다.
                if ( x < 3 ) { // 맨 처음에 4, 그리고 다음번째에는 3이 된다. 
                        System.out.println("small x"); // x가 4일때에만 한번 if문이 실행되므로 small x 라는 문장이 1회 출력된다.
                }
        }
}

}}}
{{{

C
// class는 존재하지만 main함수가 없기 때문에 컴파일이 되지 않는다.
class Exercise1b{
        int x = 5;  
        while ( x >1 ) { // x가 5이기 때문에 처음에 while문이 실행된다.
                x = x - 1; // x가 1씩 줄어든다.
                if ( x < 3 ) { // 위와 같이 맨처음엔 4, 다음엔 3
                        System.out.println("small x"); // x가 4일때만 한번 if문이 실행
                }
        }
}   

}}}
= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 아는 것
 * 메소드: 객체에서 하는 것
 * 클래스: 객체에 해당하는 클래스
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스이며, 테스트용 클래스에는 main() 메소드가 들어가며 그 main() 메소드에서 테스트할 클래스 유형의 객체를 만들어서 접근한다.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channels
 * 메소드: turnOff(), turnOn(), changeChannel(), volumeUp(), volumeDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame{
        Player p1;
        Player p2;
        Player p3;
        Player p4;
        // Player 객체 4개를 저장하기위한 인스턴트 변수 네개

        public void startGame(){
                p1 = new Player();
                p2 = new Player();
                p3 = new Player();
                p4 = new Player(); // player 객체 네 개를 생성하고 각각을 player 인스턴스 변수 네 개에 대입

                int guessp1 = 0;
                int guessp2 = 0;
                int guessp3 = 0;
                int guessp4 = 0; // player 객체 네 개에서 찍은 숫자를 저장하기 위해 변수 네 개를 선언.

                boolean p1isRight = false;
                boolean p2isRight = false;
                boolean p3isRight = false;
                boolean p4isRight = false;

                int targetNumber = (int) (Math.random() * 10);
                System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

                while(true){
                        System.out.println("맞춰야 할 숫자는" + targetNumber + "입니다.");

                        p1.guess();
                        p2.guess();
                        p3.guess();
                        p4.guess();

                        guessp1 = p1.number;
                        System.out.println("1번 선수가 찍은 숫자: " + guessp1);

                        guessp2 = p2.number;
                        System.out.println("2번 선수가 찍은 숫자: " + guessp2);

                        guessp3 = p3.number;
                        System.out.println("3번 선수가 찍은 숫자: " + guessp3);

                        guessp4 = p4.number;
                        System.out.println("4번 선수가 찍은 숫자: " + guessp4);

                        if (guessp1 == targetNumber) {
                                p1isRight = true;
                        }

                        if (guessp2 == targetNumber) {
                                p2isRight = true;
                        }

                        if (guessp3 == targetNumber) {
                                p3isRight = true;
                        }

                        if (guessp4 == targetNumber) {
                                p4isRight = true;
                        }

                        if (p1isRight || p2isRight || p3isRight || p4isRight) {

                                System.out.println("맞춘 선수가 있습니다.");
                                System.out.println("1번 선수: "+ p1isRight);
                                System.out.println("2번 선수: "+ p2isRight);
                                System.out.println("3번 선수: "+ p3isRight);
                                System.out.println("4번 선수: "+ p4isRight);
                                System.out.println("게임 끝.");
                                break;
                        } else{
                                System.out.println("다시 시도해야 합니다.");
                        }
                }
        }
}

}}}

{{{

public class Player{
        int number = 0;

        public void guess() {
                number = (int) (Math.random() * 10);
        }
}

}}}

{{{          
public class GameLauncher {
        public static void main (String[] args) {
                GuessGame game = new GuessGame();
                game.startGame();
        }
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class TapeDeck{

        boolean canRecord = false;

        void playTape() {
                System.out.println("tape playing");
        }

        void recordTape() {
                System.out.println("tape recording");
        }
}

}}}

{{{

class TapeDeckTestDrive {
        public static void main(String [] args) {

                t.canRecord = true; //객체의 이름은 canRecord가 아닌 TapeDeck이다 따라서 TapeDeck t = new TapeDeck(); 으로 새로운 t를 생성해준다.
                                    // 그 후에 t.canRecord = true;
                t.playTape();

                if (t.canRecord == true) {
                        t.recordTape();
                }
        }
}

}}}

{{{
class DVDPlayer {

        boolean canRecord = false;

        void recordDVD() {
                System.out.println("DVD recording");
        }
        // 테스트드라이브에서 playDVD라는 메소드를 불러오고 있지만 존재하지 않기 때문에 넣어주어야 한다
        /* void playDVD() {
                  System.out.println("DVD playing");
           }
        */
}
}}}

{{{
class DVDPlayerTestDrive {
        public static void main( String [] args) {

                DVDPlayer d = new DVDPlayer();
                d.canRecord = true;
                d.playDVD(); //DVDPlayer라는 객체에는 playDVD라는 메소드가 존재하지 않는다.

                if ( d.canRecord == true ) {
                        d.recordDVD();
                }
        }
}

}}}



= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 
원시변수(primitive variable)는 정수, 부울, 부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼 수 있는 값)이다. 객체 레퍼런스(object reference) 객체에 대한 레퍼런스가 들어간다.
원시변수와 레퍼런스변수 둘 어떤 유형에 무관하게 두가지 선언 규칙은 반드시 준수해야 한다.
1. 변수에는 유형이 있어야한다.
2. 변수에는 이름이 있어야한다. 
예) int(유형) count;(이름)

또한 자바에는 변수의 이름을 정할 수 있다는 특징이 있다. 
예)
int size = 32; size라는 int변수 32라는 값을 대입
char initial = 'j'; initial이라는 char변수를 선언하고 'j'라는 값을 대입
double d = 456.709; d라는 double 변수를 선언하고 456.709라는 값을 대입
boolean isCrazy; isCrazy라는 boolean 변수를 선언(값은 대입하지 않음)
isCrazy = true; 앞서 선언한 isCrazy에 true라는 값을 대입
int y =  x + 456; y라는 int변수를 선언하고 x의 현재 값에 456을 더한 값을 대입
 
객체 변수 레퍼런스라는 것
1.객체 변수라는 것은 존재하지 않는다. 2. 객체 레퍼런스 변수라는 것만 존재. 3. 객체 레퍼런스에는 객채에 접근하는 방법을 알려주는 비트가 있다. 4.객체 레퍼런스에 객체 자체가 들어있는 것은 아님. 그 레퍼런스가 객체 단 하나를 가리킨다. 

레퍼런스 변수에 대해 점 연산자(.)을 사용하면 "점 앞에 있는 것을 이용해서 점 뒤에 있는 것을 갖다주세요." 예) myDog.bark();  myDog라는 변수로 참조할 수 있는 객체를 이용하여 bark()메소드를 호출하라.

원시변수 byte x = 7; 7을 나타내는 비트들이 변수에 저장(00000111)
레퍼런스 변수 Dog myDog = new Dog(); Dog객체에 접근하는 방법을 나타내는 비트들이 변수에 저장됩니다. (Dog 객체 자체는 변수에 저장되지 않습니다.)

객체 선언, 생성과 대입의 3단계
1. 레퍼런스 변수 선언 : Dog myDog = new Dog(); 레퍼런스 변수용 공간을 할당해달라는 요청을 한 다음 그 변수명을 myDog로 지정. 이렇게 하고 나면 myDog라는 레퍼런스 변수는 영원히 Dog유형의 변수가됨. 즉 Dog 객체를 제어하기 위한 버튼이 장착된 리모컨.
2. 객체 생성 : Dog myDog = new Dog(); : 힙에 새로운 Dog객체를 위한 공간을 마련하도록 지시
3. 객체와 레퍼런스 연결 : 새로운 Dog 객체를 myDog라는 레퍼런스 변수에 대입합니다. 즉, 리모컨의 기능을 결정.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog{
        String name;
        public static void main(String [] args){
                Dog dog1 = new Dog();
                dog1.bark();
                dog1.name = "Bart";

                Dog[] myDogs = new Dog[5];
                myDogs[0] = new Dog();
                myDogs[1] = new Dog();
                myDogs[2] = new Dog();
                myDogs[3] = new Dog();
                myDogs[4] = dog1;

                myDogs[0].name = "Fred";
                myDogs[1].name = "Marge";
                myDogs[2].name = "Tom";
                myDogs[3].name = "Kate";
                myDogs[4].name = "Suri";

                System.out.print("마지막 개의 이름: ");
                System.out.println(myDogs[4].name);

                int x = 0;
                while(x<myDogs.length){
                        myDogs[x].bark();
                        x=x+1;
                        }
        }

        public void bark() {
                System.out.println(name + " 이(가) 왈!하고 짖습니다.");
        }
        public void eat(){}
        public void chaseCat() {}
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class Books{
        String title;
        String authour;
        }

class BooksTestDrive{ // public class로 지정을 해주어야 한다. 파일명도 BooksTestDrive.java
        public static void main(String [] args) {
                Books[] myBooks = new Books[3];
                int x = 0;
                // myBooks[0]~myBooks[2]의 객체를 생성하지 않았기 때문에 이후의 명령이 실행되지 않기 때문에, myBooks[0] = new Books();... 를 추가해야한다.
                myBooks[0].title = "The Grapes of Java"; 
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";

                while ( x < 3 ) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}


}}}


{{{

class Hobbits{
        String name;

        public static void main(String [] args) {
                Hobbits [] h = new Hobbits[3];
                int z = 0;

                while ( z < 4 ) { // Hobbits배열은 Hobbits[0~2]까지이므로 ( z < 3 ) 으로 바꾸어야 한다.
                        z = z + 1; // 첫번째 인덱스가 0이기 때문에 z = z + 1 을 while문의 끝으로 이동시켜야한다.
                        h[z] =  new Hobbits();
                        h[z].name = "bilbo";
                        if ( z == 1 ) {
                                h[z].name = "frodo";
                        }

                        if ( z == 2 ) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.print("good Hobbit name");
                        //z = z+1;
                }
        }
}
}}}
*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:밥
 * 문제가 된 부분은 어딘가요?:
켄트의 메소드는 사용한 레퍼런스 변수의 개수는 작았지만 그의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수가 없다는 문제가 있었다. 순환문을 돌 때마다 새로운 객체를 전에 레퍼런스 변수 하나에 대입했기 때문에 이전의 것은 사라져버린다.

따라서 켄트의 코드는 사실 객체 한개에만 접근 할 수 있기 때문에 쓸모가 없는 메소드이다.
{{{
밥의 코드
Contact[] ca = new Contact[10];
while ( x < 10 ) { // 연락처 객체 10개를 만듭니다.
 ca[x] = new Contact();
 x = x + 1;
}

켄트의 코드
Contact refc;
while( x < 10 ) { // 연락처 객체 10개를 만듭니다.
 refc = new Contact();
 x = x + 1;
}

}}}



= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
데이터와 자신이 구현한 코드를 나중에 수정할 권한을 보호할 수 있도록 구현하는 방법. public 과 private라는 접근 변경자를 사용하면 데이터를 숨길수가 있다. 캡슐화를 하려면 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만들면 된다.
(( 인스턴스 변수는 private로! 게터와 세터는 public으로! ))

캡슐화는 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다. 다른 코드에서 항상 세터 메소드를 사용하게 한다. 세터 메소드에서 매개변수의 값을 확인하고 그 값이 올바른 값인지 결정할 수 있다. 인스턴스 변수가 공개된 경우에는 아무 것도 할 수 없지만 세터 메소드를 사용하면 자신이 원하는 것을 모두 할 수있다.

세터에서 가장 중요한 점은 나중에 뭔가를 변경하더라도 다른 코드는 건드리지 않아도 된다는 점이다. 


 * 게터와 세터: 
정식명칭은 getter-accessor / setter-mutator이다. 게터와 세터라는 명칭은 자바에서 일반적으로 메소드에 이름을 붙이는 방법하고도 연관이 있다. getter와 setter는 보통 인스턴스 변수의 값에 대해 가져오고 설정하는 작업을 한다. 
getter 는 getter가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 사용.
setter 는 setter가 설정한 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 사용.
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_
{{{
class Dog2 { //전의 실습에서 Dog이라는 class가 있기때문에 Dog2라는 class를 생성
        int size;
        String name;

        void bark() {
                if ( size > 60 ) {
                        System.out.println("Wooof! Wooof!");
                } else if ( size > 14 ) {
                        System.out.println("Ruff! Ruff!" );
                } else {
                        System.out.println("Yip! Yip!");
                }
        }
}
}}}
{{{
class Dog2TestDrive{

        public static void main( String[] args) {
                Dog2 one = new Dog2();
                one.size = 70;
                Dog2 two = new Dog2();
                two.size = 8;
                Dog2 three = new Dog2();
                three.size = 35;

                one.bark();
                two.bark();
                three.bark();
        }
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 
소프트웨어 공학과는 다른 프로그래밍 방법론으로 "프로그래머들이 정말 원하는 방법"이다.
그의 규칙에는 1.조금씩, 자주 2.사이클을 반복해서 개발 3.스펙에 없는 것은 넣지 않는다. 4.테스트코드를 먼저 만든다. 그외 어디서든 개선, 조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획, 모든 일을 단순하게 처리 한다 등이 있다.

 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive{
        public static void main(String[] args){
                int numOfGuesses = 0; // 사용자의 추측 횟수 저장을 위한 int 변수 선언
                GameHelper helper = new GameHelper(); //GameHelper인스턴스 생성

                SimpleDotCom theDotCom = new SimpleDotCom(); //SimpleDotCom인스턴스 생성
                int randomNum = (int) (Math.random()*5); // 첫 번째 셀 위치를 정하기 위한 난수를 만든다. 0이상 4이하의 정수가 리턴된다 (int) cast

                int[] locations = {randomNum, randomNum+1, randomNum+2}; //첫 번째 셀위치에 1씩 더해 셀위치배열을 만든다.
                theDotCom.setLocationCells(locations); //닷컴의 위치를 저장하는 메소드
                boolean isAlive = true; // 닷컴이 살아있는지 추적하기 위한 부울 값

                while(isAlive == true) { // 닷컴이 살아있으면 실행
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if(result.equals("kill")){
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }
                }
        }
}
}}}

{{{
public class SimpleDotCom{

        int[] locationCells;
        int numOfHits = 0;

        public void setLocationCells(int[] locs){
                locationCells = locs;
        } // int 배열값을 받아서 셀의 위치로 저장하는 메소드

        public String checkYourself(String stringGuess){
                int guess = Integer.parseInt(stringGuess); //String을 int로 변환
                String result = "miss";
                for (int i = 0 ;i <locationCells.length; i++) {
                        if(guess == locationCells[i]){ // 사용자가 추측한 값과 배열에 들어있는 셀과 비교
                                result = "hit";
                                numOfHits++;
                                break;
                        }
                }
                if(numOfHits == locationCells.length){ // 맞은 횟수가 셀배열의 길이와 같아지면. 즉, 모든 셀갯수만큼의 hit를 하면
                        result = "kill";
                }
                System.out.println(result);
                        return result;
        }
}

}}}

{{{
import java.io.*;
public class GameHelper{
        public String getUserInput(String prompt){
                String inputLine = null;
                System.out.print(prompt + " ");
                try{
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));

                        inputLine = is.readLine();
                        if(inputLine.length() == 0 ) return null;
                }catch(IOException e){
                        System.out.println("IOException: " + e);
                }
                return inputLine;
        }
}
}}}



= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{



}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:A라는 클래스가 B로부터 상속을 받는다고 하면, A는 하위클래스(subclass)가 되고, B는 상위클래스(superclass)가 된다. 상위 클래스에 어떤 기능이 있으면 하위클래스에서도 상속하는 클래스의 메소드를 기능을 사용 할 수 있다. 이러한 것을 상속이라고 한다.
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Animal{

        boolean picture, food, hunger;
        int boundaries, location;

        void makeNoise(){}
        void eat(){}
        void sleep(){}
        void roam(){}

}

class Feline extends Animal{
        void roam(){}
}

class Lion extends Feline{
        void makeNoise(){}
        void eat(){}
}

class Tiger extends Feline{
        void makeNoise(){}
        void eat(){}
}

class Cat extends Feline{
        void makeNoise(){}
        void eat(){}
}

class Canine extends Animal{
        void roam(){}
}

class Wolf extends Canine{
        void makeNoise(){}

class Dog extends Canine{
        void makeNoise(){}
        void eat(){}
}

class Hippo extends Animal{
        void makeNoise(){}
        void eat(){}
}


}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 

오버라이드는 메소드의 인자와 리턴 형식이 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 한다는 특징이 있다.

예를들면

{{{
public class Appliance(){
      boolean turnOn(){}
}
public class Toaster extends(){
      boolean turnOn(){}
}
}}}
와 같이 메소드의 인자 void값, 그리고 리턴 형식 boolean이 일치하게끔 해야한다.
 * 오버로딩:

오버로딩은 이름은 같고 인자 목록이 다른 메소드 두개를 만드는 것을 오버로드라고 한다. 오버로드 된 메소드는 다형성과는 전혀 관계가 없다고 할 수 있다.

예를들면
{{{
public class Overloads{
      String uniqueID;
      public int addNums(int a, int b){
            return a+b;
      }
      public double addNumbs(double a, double b){
            return a+b;
      }
      public void setUniqueID(String theID){
            uniqueID = theID;
      }
      public void setUniqueID(int ssNumber){
            String numString = " " + ssNumber;
            setUniqueID(numString);
      }
}
}}}
메소드 오버로딩 정리
1.리턴 유형이 달라도 된다;메소드를 오버로드할 때는 인자 목록만 다르면 리턴 유형을 마음대로 바꿔도 된다.
2.리턴 유형만 바꿀 수는 없다;메소드를 오버로딩할 때는 리턴 유형하고는 무관하게 인자 목록을 반드시 변경해야 한다.
3.접근 단계를 마음대로 바꿀 수 있다;메소드를 오버로드해서 더 제한이 심한 메소드를 만들어도 된다. 새로운 메소드가 오버로드된 메소드의 계약 조건을 이행해야 하는 것은 아니기 때문.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive{
        public static void main(String[] args){
                Monster[] ma = new Monster[3];  
                ma[0] = new Vampire();         
                ma[1] = new Dragon();          
                ma[2] = new Monster();
 /* Monster의 배열에는 Monster의 하위클래스인 Vampire, Dragon 객체를 집어 넣을 수있다 */
                for ( int x = 0 ; x < 3 ; x++ ) {
                        ma[x].frighten(x);
                }
        }
}

class Monster {
        boolean frighten(int d){
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster{   /* Monster의 하위클래스인 Vampire */
        boolean frighten(int x){
                System.out.println("a bite?");
                return false;
        }
}

class Dragon extends Monster{    /* Monster의 하위클래스인 Dragon */
        boolean frighten(int degree){
                System.out.println("breath fire");
                return true;
        }
}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:

 자바에서는 다중 상속이 필요한 문제를 해결 하기 위해 인터페이스(interface)라는 것을 제공한다. 다중 상속의 다형적인 장점을 누릴 수 있게 해줌으로써 다중 상속 문제를 해결해준다. 
 자바의 인터페이스는 추상 클래스와 비슷하다. 따라서 인터페이스에 들어있는 모든 메소드는 추상 메소드이고 모든 클래스는 인터페이스의 메소드를 오버라이드해야한다.
 인터페이스를 정의하려면 public interface Pet { ... }
 인터페이스를 구현하려면 public class Dog extends Canine implments Pet{ ... }

인터페이스의 예시
{{{
public interface Pet{
      public abstract void beFriendly();
      public abstract void play();
 /* 인터페이스에 들어있는 모든 메소드는 추상 메소드이므로 반드시 세미콜론으로 끝나야함. 본체가없다.*/
}
public class Dog extends Canine implments Pet{
      public void beFriendly(){...}
      public void play(){...}
 /* Dog도 Pet이므로 Pet의 메소드를 반드시 구현해야 한다. */
      public void roam(){...}
      public void eat(){...}
 /* 일반적으로 오버라이드 하는 메소드들 */
 
}
}}}


 * 다형성:

 다형성(polymorphism)은 말 그대로 여러가지 형태를 가질 수 있다는 뜻이다. 자바에서 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다.
 예를들면 Dog myDog = new Dog();처럼 Dog객체를 myDog라는 레퍼런스 변수에 대입하는게 일반적이다.
 하지만, Animal myDog = new Dog(); 처럼 레퍼런스 변수는 Animal(실제 객체 유형의 상위 클래스 유형)으로 선언하고 객체를 만들 때에는 new Dog()를 사용하는 것도 가능하다.
 이처럼 다형성을 이용하면 편리하게 다형적인 배열을 만드는 것과 같은 일을 할 수 있다.

다형성을 이용한 다형적인 배열의 예
{{{

Animal[] animals = new Animal[5];
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Wolf();
animals[3] = new Hippo();
animals[4] = new Lion();

for ( int i = 0 ; i < animals.length; i++ ){
       animals[i].eat();
       animals[i].roam();
}
}}}

 이 뿐아니라, 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있다. 

예
{{{

class Vet{
       public void giveShot(Animal a){
              a.makeNoise();
       }
}

class PetOwner{
       public void start(){
              Vet v = new Vet();
              Dog d = new Dog();
              Hippo h = new Hippo();
              v.giveShot(d);
              v.giveShot(h);
   /* Vet의 giveShot() 메소드에서는 모든 Animal을 인자로 받을 수 있다. 인자로 전달된 객체가 Animal의 하위 클래스이기만하면 ( 여기에서는 Dog, Hippo) 제대로 작동가능하다. */
       }
}
}}}
 * 추상 클래스: 

 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스를 의미한다. 그 클래스 유형의 객체를 만들지 못하도록 하는 클래스.클래스를 추상클래스로 만드는 방법은 간단하다, 클래스를 abstract로 지정하면 컴파일러에서 그 유형의 인스턴스를 만드는 코드를 허용하지 않는다. 
 예) abstract class Canine extends Animal { public void roam(){} }
 추상 클래스는 확장하지 않으면 쓸모가 없다. 추상 클래스를 만들었을 때 실젲 실행 중에 일을 처리하는 것은 그 추상 클래스의 하위클래스 인스턴스이다.

 * 추상 메소드:

 위에서 설명한 것과 같이 추상 클래스는 반드시 확장해야 하는 클래스를 의미했다면, 추상 메소드는 반드시 오버라이드해야하는 메소드를 의미한다. 추상 클래스의 행동 가운데 일부에 대해 더 구체적인 하위클래스에서 구현되지 않는 이상 전혀 의미가 없다는 결정을 내릴 수 있다.
 추상 메소드에는 몸통이 없다. 적당한 코드를 생각할 수 없는 메소드를 추상 메소드로 만들기 때문에 추상 메소드에는 몸통(코드)가 필요 없다. 
 예)public abstract void eat(); 이것 처럼메소드의 코드가 없고 세미콜론으로 끝내면 된다.
 추상 메소드를 만들 때 에는 클래스도 반드시 추상을 만들어야한다. 클래스에 추상 메소드가 하나라도 있으면 그 클래스도 추상 클래스로 지정해야 한다. 
 추상 메소드는 다형성을 위해 존재할 뿐이다. 즉, 상속 트리에서 처음으로 등장하는 구상 클래스에서 모든 추상 메소드를 구현해야 한다.

 * 다중 상속:

 다중 상속(multiple inheritance)란 상위클래스를 두 개 이상 사용하는 접근법이다. 하지만 자바에서는 다중 상속을 쓸 수가 없다. 

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 

 객체가 사는 곳. 
 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스)만 스택에 들어간다. 레퍼런스 변수를 어디에서 선언하든(메소드 안에서 선언하든, 클래스의 인스턴스 변수로 선언하든) 객체는 무조건 힙에 들어가게된다.
 인스턴스 변수는 힙에, 그 변수가 속하는 객체안에 있다.

 * 스택에서의 변수:

 메소드 호출과 지역 변수가 살아가는 곳 
 메소드를 호출하면 그 메소드는 호출 스택 맨 위에 올라가게 됨. 실제로 스택에 들어 가는 것은 스택 프레임인데, 거기에는 실행하는 코드, 모든 지역 변수의 값을 포함한 메소드의 상태가 들어있다. 
 스택 맨 위에 있는 메소드는 항상 현재 실행 중인 메소드이다.

 * 생성자:

 객체를 생성할 때 실행되는 코드가 들어있다.
 모든 클래스에는 생성자가 존재한다.
 직접 만들지 않아도 컴파일러에서 자동으로 생성자를 만들어 준다.

 Duck myDuck = new Duck();  // Duck 생성자를 호출하는 것이다.
 컴파일러에서 만드는 기본 생성자는 다음과 같다.
{{{
public Duck(){

}
}}}
 메소드와는 다르게 리턴유형이 들어가지 않는다.
 생성자를 생성할 때 1.class의 이름과 동일해야함 2.return 유형이 없어야한다.
 
 아래와 같이 생성자를 이용하여 객체의 상태를 초기화 할 수 있다.
{{{
public class Duck{
      int size;
      public Duck(int duckSize) {
            size = duckSize;
      }
}
}}}
 초기화 할 수 있지만, 인자가 없는 생성자를 꼭 만드는 편이 좋다. 

 * 널 레퍼런스:

 객체의 레퍼런스를 제거하는 세 가지 방법
{{{
1.레퍼런스가 영원히 영역을 벗어남.
void go(){
      Life z = new Life();
}
}}}
{{{
2.레퍼런스에 다른 객체를 대입.
Life z = new Life();
z = new Life();
}}}
{{{
3.레퍼런스를 직접 null로 설정.
Life z = new Life();
z = null;
}}}

 널 레퍼런스에는 '아무 것도 없음'을 나타내는 비트들이 들어있다.
 널 레퍼런스는 위에 방법중 세 번째 방법과 같이 객체를 제거 할 때 사용 된다.

*298p 집중토론* _요약_

 * 인스턴스 변수:

 객체를 지원하는 역할. 
 객체와 함께 힙에 저장. 객체의 상태를 저장.
 객체가 가비지 컬렉터에 의해 처리되면 인스턴스 변수도 사라짐.

 * 지역 변수: 

 메소드를 작동시키기 위한 역할.
 다른 여러 지역 변수와 함께 스택 프레임에 들어가 있게됨.
 객체를 지역 변수에서만 참조한다면, 객체에 대한 유일한 레퍼런스라면 지역변수가 사라 질 때 인스턴스 변수도 같이 사라지게됨. 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}