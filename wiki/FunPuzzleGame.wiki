#labels 2013190722,박선우
= Introduction =

슬라이딩 그림 퍼즐 맞추기 게임입니다.(발표때 한 게임을 수정했습니다.)


= Details =

[http://comp166-koreauniv.googlecode.com/files/메인메뉴.jpg] 메인메뉴 모습입니다.

[http://comp166-koreauniv.googlecode.com/files/게임방법.jpg] 메인메뉴에서 
HOW TO PLAY 버튼을 누를 경우 나오게 되는 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/게임시작메뉴.jpg] 메인메뉴에서 GAME START 버튼을 누를 경우 나오게 되는 화면입니다. 난이도를 Easy, Normal, Hard, Very Hard 네 단계로 나누었습니다. 

[http://comp166-koreauniv.googlecode.com/files/이지모드시작전.jpg] 난이도를 Easy로 선택했을 때 뜨는 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/이지모드시작후.jpg] 게임시작버튼을 클릭했을 때 퍼즐조각이 섞인 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/노말모드시작전2.jpg] 난이도를 Normal로 선택했을 때 뜨는 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/노말모드시작후.jpg] 게임시작 버튼을 클릭했을 때 퍼즐조각이 섞인 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/하드모드시작전.jpg] 난이도를 Hard로 선택했을 때 뜨는 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/하드모드시작후.jpg] 게임시작 버튼을 클릭했을 때 퍼즐조각이 섞인 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/베리하드모드시작전.jpg] 난이도를 Very Hard로 선택했을 때 뜨는 화면입니다.

[http://comp166-koreauniv.googlecode.com/files/베리하드모드시작후.jpg] 게임시작 버튼을 클릭했을 때 퍼즐조각이 섞인 화면입니다.

= 코드 리스트 =

[http://comp166-koreauniv.googlecode.com/files/CodeList.jpg]

= 전체 코드 =

[http://comp166-koreauniv.googlecode.com/files/AllCode.zip]


= FunPuzzle 코드 =

메인 메뉴, 버튼 구성 등을 구현한 코드입니다.

= R.java =

{{{
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * aapt tool from the resource data it found.  It
 * should not be modified by hand.
 */

package com.example.funpuzzle;

public final class R {
    public static final class attr {
    }
    public static final class dimen {
        /**  Default screen margins, per the Android Design guidelines. 

         Customize dimensions originally defined in res/values/dimens.xml (such as
         screen margins) for sw720dp devices (e.g. 10" tablets) in landscape here.
    
         */
        public static final int activity_horizontal_margin=0x7f040000;
        public static final int activity_vertical_margin=0x7f040001;
    }
    public static final class drawable {
        public static final int but1=0x7f020000;
        public static final int but2=0x7f020001;
        public static final int but3=0x7f020002;
        public static final int but4=0x7f020003;
        public static final int button1=0x7f020004;
        public static final int button2=0x7f020005;
        public static final int howtoplay=0x7f020006;
        public static final int ic_launcher=0x7f020007;
        public static final int slide1=0x7f020008;
        public static final int slide2=0x7f020009;
        public static final int title=0x7f02000a;
        public static final int titledd=0x7f02000b;
    }
    public static final class id {
        public static final int action_settings=0x7f080004;
        public static final int imageButton1=0x7f080000; //난이도 Easy에 대한 버튼입니다.
        public static final int imageButton2=0x7f080001; //난이도 Normal에 대한 버튼입니다
        public static final int imageButton3=0x7f080002; //난이도 Hard에 대한 버튼입니다.
        public static final int imageButton4=0x7f080003; //난이도 Very Hard에 대한 버튼입니다.
    }
    public static final class layout {   //layout 첫 화면에 gamestart와 howtoplay 두개의 버튼을 만들었습니다.
        public static final int activity_game_start=0x7f030000;
        public static final int activity_how_to_play=0x7f030001;
        public static final int activity_main=0x7f030002;
    }
    public static final class menu {
        public static final int game_start=0x7f070000;
        public static final int how_to_play=0x7f070001;
        public static final int main=0x7f070002;
    }
    public static final class string {
        public static final int action_settings=0x7f050001;
        public static final int app_name=0x7f050000;
        public static final int hello_world=0x7f050002;
        public static final int title_activity_game_start=0x7f050003;
        public static final int title_activity_how_to_play=0x7f050004;
    }
    public static final class style {
        /** 
        Base application theme, dependent on API level. This theme is replaced
        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
    

            Theme customizations available in newer API levels can go in
            res/values-vXX/styles.xml, while customizations related to
            backward-compatibility can go here.
        

        Base application theme for API 11+. This theme completely replaces
        AppBaseTheme from res/values/styles.xml on API 11+ devices.
    
 API 11 theme customizations can go here. 

        Base application theme for API 14+. This theme completely replaces
        AppBaseTheme from BOTH res/values/styles.xml and
        res/values-v11/styles.xml on API 14+ devices.
    
 API 14 theme customizations can go here. 
         */
        public static final int AppBaseTheme=0x7f060000;
        /**  Application theme. 
 All customizations that are NOT specific to a particular API-level can go here. 
         */
        public static final int AppTheme=0x7f060001;
    }
}
}}}

= MainActivity.java = 

{{{
package com.example.funpuzzle;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;


public class MainActivity extends Activity {
	
	ImageButton imageButton;

	private ImageButton GameStart_btn;
	private ImageButton HowToPlay_btn;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		
		GameStart_btn=(ImageButton)findViewById(R.id.imageButton1);
		HowToPlay_btn=(ImageButton)findViewById(R.id.imageButton2);

		GameStart_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intentGameStart = new Intent(MainActivity.this, GameStart.class);
				startActivity(intentGameStart);
			}
		}); //GameStart 버튼을 누르면 다음 화면으로 넘어가게 하는 코드입니다.
		
		HowToPlay_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intentHowToPlay = new Intent(MainActivity.this, HowToPlay.class);
				startActivity(intentHowToPlay);
			} //HowToPlay 버튼을 누르면 다음 화면으로 넘어가게 하는 코드입니다.
		});
	}
		


	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}

}
}}}

= HowToPlay.java = 

{{{
package com.example.funpuzzle;

import android.os.Bundle;
import android.app.Activity;
import android.view.Menu;

public class HowToPlay extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_how_to_play);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.how_to_play, menu);
		return true;
	}

}
}}}

= GameStart.java = 

{{{
package com.example.funpuzzle;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;

public class GameStart extends Activity {
	
	ImageButton imageButton;

	private ImageButton Easy_btn;
	private ImageButton Normal_btn;
	private ImageButton Hard_btn;
	private ImageButton VeryHard_btn; //GameStart버튼을 누를시 나오게 되는 네가지 버튼들을 정의한 것입니다.


	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_game_start);

		Easy_btn=(ImageButton)findViewById(R.id.imageButton1);
		Normal_btn=(ImageButton)findViewById(R.id.imageButton2);
		Hard_btn=(ImageButton)findViewById(R.id.imageButton3);
		VeryHard_btn=(ImageButton)findViewById(R.id.imageButton4);
		
		Easy_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intent = getPackageManager().getLaunchIntentForPackage("com.PocketPuzzle1"); 
//Easy버튼을 누를시 "com.PocketPuzzle1"이라는 어플이 실행되도록 구동했습니다.
				intent.setAction(Intent.ACTION_MAIN);
				startActivity(intent);
			}
		});
		
		Normal_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intent = getPackageManager().getLaunchIntentForPackage("com.PocketPuzzle2"); 
//Normal버튼을 누를시 "com.PocketPuzzle2"이라는 어플이 실행되도록 구동했습니다.

				intent.setAction(Intent.ACTION_MAIN);
				startActivity(intent);
			}
		});
		
		Hard_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intent = getPackageManager().getLaunchIntentForPackage("com.PocketPuzzle3"); 
//Hard버튼을 누를시 "com.PocketPuzzle3"이라는 어플이 실행되도록 구동했습니다.

				intent.setAction(Intent.ACTION_MAIN);
				startActivity(intent);
			}
		});
		
		VeryHard_btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v)
			{
				Log.i("onClick","Food");
				Intent intent = getPackageManager().getLaunchIntentForPackage("com.PocketPuzzle4"); 
//Very Hard버튼을 누를시 "com.PocketPuzzle4"이라는 어플이 실행되도록 구동했습니다.

				intent.setAction(Intent.ACTION_MAIN);
				startActivity(intent);
			}
		});
		
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.game_start, menu);
		return true;
	}

}
}}}

= 게임코드 =
= 코드출처 =

원본 소스 : [http://newworlds.tistory.com/1389]

게임코드는 그대로 사용했습니다. 하지만 원본 소스는 5X6의 그림 퍼즐만 제공하였지만 저는 이 소스를 응용하여 3X4, 4X5, 5X6, 6X7 총 4가지의 그림 퍼즐들을 만들어 난이도를 나눴습니다. 물론 사용된 사진도 바꿨습니다. 난이도에 맞춰 피츄, 피카츄, 라이츄,피츄와 피카츄와 라이츄가 같이 있는 사진들을 이용했습니다. 네가지 난이도중 이지모드로 코드를 쓰겠습니다. 

= CPocketPuzzle.java =

{{{
     package com.PocketPuzzle1;

import com.PocketPuzzle.R;

import android.app.Activity;
import android.os.Bundle;
import android.view.Window;

public class CPocketPuzzle extends Activity
{
     @Override    //상위클래스의 메서드를 재정의하는 것
     public void onCreate(Bundle savedInstanceState)
     {
          super.onCreate(savedInstanceState);
          
          requestWindowFeature(Window.FEATURE_NO_TITLE);         
          
          setContentView(R.layout.main);
     }
}
}}}

= CPpBtnExit.java = 

{{{
package com.PocketPuzzle1; //easy모드의 이름은 pocketPuzzle1이고 normal모드의 이름은 pocketPuzzle2 이런 식으로 정했습니다.

import com.PocketPuzzle.R;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;

public class CPpBtnExit
{

    private int _x; 
    private int _y;

    private int _bx;
    private int _by;

    private int _width = 144;     //이차원 배열의 가로 길이
    private int _height = 40;     //이차원 배열의 세로 길이

    private Bitmap _btnStart_e;
    private Bitmap _btnStart_d;

    public CPpBtnExit(int x, int y, int bx, int by, Resources resources)
    {
        this._x = x;       //this는 객체 자기 자신을 부르는 명령어
        this._y = y;

        this._bx = bx;
        this._by = by;

        Bitmap _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_exit_e);
        _btnStart_e = Bitmap.createScaledBitmap(_tmp, _width, _height, false);

        _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_exit_d);
        _btnStart_d = Bitmap.createScaledBitmap(_tmp, _width, _height, false);
    }

    public void doMoveTo(int x, int y)
    {
        this._bx = x;   //_bx를 x로!
        this._by = y;   //_by를 y로!
    }

    public void doDrawExit(Canvas canvas, Paint p, boolean enabled)
    {
        p.setAlpha(0xff);

        if (enabled)
        {
            canvas.drawBitmap(_btnStart_e, _bx + _x, _by + _y, p);
        }
        else
        {
            canvas.drawBitmap(_btnStart_d, _bx + _x, _by + _y, p);

        }
    }

    public boolean chkSelectin(float px, float py)
    {
        boolean bx = (_bx + _x <= px) && (_bx + _x + _width > px);
        boolean by = (_by + _y <= py) && (_by + _y + _height > py);

        return (bx && by);
    } //메소드끝
}  //클래스 끝
}}}

= CPpBtnStart.java =

{{{
package com.PocketPuzzle1;

import com.PocketPuzzle.R;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;

public class CPpBtnStart
{
    private int _x;  //x변수 놓기
    private int _y;  //y변수 놓기

    private int _bx;
    private int _by;

    private int _width = 144;   //이차원배열의 가로길이
    private int _height = 40;   //이차원 배열의 세로 길이

    private boolean _bStarted=false;  //boolean은 참거짓을 뜻하는 타입
//_bStarted를 false로 놓는다!

    private Bitmap _btnStart_e;
    private Bitmap _btnStart_d;
    private Bitmap _btnRestart_e;
    private Bitmap _btnRestart_d;

    public CPpBtnStart(int x, int y, int bx, int by, Resources resources)
    {
        this._x = x;
        this._y = y;

        this._bx = bx;
        this._by = by;

        Bitmap _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_start_e);
        _btnStart_e = Bitmap.createScaledBitmap(_tmp, _width, _height, false);
        _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_start_d);
        _btnStart_d = Bitmap.createScaledBitmap(_tmp, _width, _height, false);

        _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_restart_e);
        _btnRestart_e = Bitmap.createScaledBitmap(_tmp, _width, _height, false);
        _tmp = BitmapFactory.decodeResource(resources, R.drawable.btn_restart_d);
        _btnRestart_d = Bitmap.createScaledBitmap(_tmp, _width, _height, false);
    }

    public void doMoveTo(int x, int y)
    {
        this._bx = x;
        this._by = y;
    }

    public void doDrawStart(Canvas canvas, Paint p, int gameMode, boolean enabled)
    {
        p.setAlpha(0xff);

        if (enabled)
        {
            if (is_bStarted())
            {
                canvas.drawBitmap(_btnRestart_e, _bx + _x, _by + _y, p);
            }
            else
            {
                canvas.drawBitmap(_btnStart_e, _bx + _x, _by + _y, p);
            }
        }
        else
        {
            if (is_bStarted())
            {
                canvas.drawBitmap(_btnRestart_d, _bx + _x, _by + _y, p);
            }
            else
            {  
                canvas.drawBitmap(_btnStart_d, _bx + _x, _by + _y, p);            
            }
        }
    }

    public boolean chkSelectin(float px, float py)
    {
        boolean bx = (_bx + _x <= px) && (_bx + _x + _width > px);
        boolean by = (_by + _y <= py) && (_by + _y + _height > py);

        return (bx && by); // bx와 by 값을 리턴
    }

    /**
     * @param _bStarted the _bStarted to set
     */
    public void set_bStarted(boolean _bStarted)
    {
        this._bStarted = _bStarted;
    }

    /**
     * @return the _bStarted
     */
    public boolean is_bStarted()
    {
        return _bStarted;
    }

}
}}}

= CPpInfo.java = 

{{{
package com.PocketPuzzle1;

import com.PocketPuzzle.R;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.EmbossMaskFilter;
import android.graphics.Paint;
import android.graphics.Point;
import android.util.Log;

public class CPpInfo
{
    static int _GMSTANDBY = 0; 
    static int _GMSTARTING = 1; 
    static int _GMSTARTED = 2; 
    static int _GMENDED = 3; 

    public int _GameMode = _GMSTANDBY;

    private Context _context;

    public int _nCanvasWidth;
    public int _nCanvasHeight;

    public int _SIZE = 48; //크기를 뜻함
    public int _XNUM = 3; // 가로줄에 있는 사각형의 개수
    public int _YNUM = 4; // 세로줄에 있는 사각형의 개수

    public int _nMoveCnt = -1;

    public int _BaseX;
    public int _BaseY;

    public CPpTag _cPpTagOrg[][] = new CPpTag[_XNUM][_YNUM];
    public CPpTag _cPpTagBak[][] = new CPpTag[_XNUM][_YNUM];

    private Bitmap _smallBody;
    private Bitmap _Success;
    private Bitmap _allBody;

    private Bitmap _backGroundFull;
    private Bitmap _backGround;
    private CPpBtnStart _btnStart;
    private CPpBtnExit _btnExit;

    private int _nMixDir = 0;
    public int _nMixingCount = -1;
    public boolean _bStccess = false;

    private Bitmap GetRImage(int rImg)
    {
        return BitmapFactory.decodeResource(_context.getResources(), rImg);
    }

    /**
     * 
     * 
     * @param width
     * @param height
     */
    public void setSurfaceSize(int width, int height)
    {
        _nCanvasWidth = width;
        _nCanvasHeight = height;

        // _BaseX = width;

        _BaseX = Math.round((width - (_SIZE * _XNUM)) / 2);
        _BaseY = 20; 

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j].doMoveTo(_BaseX, _BaseY);
            }
        }

        // String.format("%03d,%03d", width, height);

        _backGroundFull = Bitmap.createScaledBitmap(_backGround, width, height, false);

        _btnStart.doMoveTo(_BaseX, _BaseY);
        _btnExit.doMoveTo(_BaseX, _BaseY);
    }

    /**
     * 
     * @param context
     */
    public CPpInfo(Context context)
    {
        _context = context;

        _smallBody = Bitmap.createScaledBitmap(GetRImage(R.drawable.d), _XNUM * 18, _YNUM * 18, false);
        
        Bitmap _tmp = BitmapFactory.decodeResource(_context.getResources(), R.drawable.success);
        _Success  = Bitmap.createScaledBitmap(_tmp, 200, 100, false);

        _tmp = BitmapFactory.decodeResource(_context.getResources(), R.drawable.d);
        _allBody = Bitmap.createScaledBitmap(_tmp, _SIZE * _XNUM, _SIZE * _YNUM, false);        
        _backGround = BitmapFactory.decodeResource(_context.getResources(), R.drawable.background);

        _btnStart = new CPpBtnStart(2 * _SIZE + 4, _YNUM * _SIZE + 4, _BaseX, _BaseY, _context.getResources());
        _btnExit = new CPpBtnExit(2 * _SIZE + 4, _YNUM * _SIZE + 46, _BaseX, _BaseY, _context.getResources());

        Paint p = new Paint();

        int x, y;

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                x = i * _SIZE;
                y = j * _SIZE;

                if ((i != _XNUM - 1) || (j != _YNUM - 1))
                {
                    _cPpTagOrg[i][j] = new CPpTag(_cPpTagOrg, _allBody, i, j, _BaseX, _BaseY, x, y, _SIZE, true, p);

                }
                else
                {
                    _cPpTagOrg[i][j] = new CPpTag(_cPpTagOrg, _allBody, i, j, _BaseX, _BaseY, x, y, _SIZE, false, p);
                }
            }
        }

    }

    
    public void doTagsUpdating()
    {
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j].doUpdating(this);
            }
        }
    }

    private void doClaerBack()
    {

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagBak[i][j] = null;
            }
        }

    }

    
    public void doMoveComplete()
    {
        doClaerBack();

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                if (_cPpTagOrg[i][j].chkMove() == true)
                {
                    Point mv = _cPpTagOrg[i][j].getMoveVar();

                    _cPpTagBak[mv.x][mv.y] = _cPpTagOrg[i][j]; 
                }
                else
                {
                    _cPpTagBak[i][j] = _cPpTagOrg[i][j];
                }
            }
        }
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j] = _cPpTagBak[i][j];

            }
        }
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j].clearMoveVar();
            }
        }

        _nMoveCnt = -1;
    }

    
    public void doInitialization()
    {
        doClaerBack();

        int x, y;

        
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                Point point = _cPpTagOrg[i][j].getIJ();
                x = point.x * _SIZE;
                y = point.y * _SIZE;

                _cPpTagBak[point.x][point.y] = _cPpTagOrg[i][j];
                _cPpTagBak[point.x][point.y].setXY(x, y);
            }
        }
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j] = _cPpTagBak[i][j];
            }
        }
    }

    public boolean doChkSuccess()
    {
        int x, y;
        boolean result = true;

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                Point point = _cPpTagOrg[i][j].getIJ();

                if ((i != point.x) || (j != point.y))
                {
                    result = false;
                }
            }
        }

        return result;
    }

    
    public void doDrawBackGround(Canvas canvas, Paint p)
    {
        p.setAlpha(0xff);

        canvas.drawBitmap(_backGroundFull, 0, 0, p);
    }

    
    public void doDrawTags(Canvas canvas, Paint p)
    {
        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                _cPpTagOrg[i][j].doDraw(canvas, p);
            }
        }
    }

    public void doDrawSmall(Canvas canvas, Paint p)
    {
        p.setAlpha(0xff);

        EmbossMaskFilter emboss = new EmbossMaskFilter(new float[] { 2, 2, 2 }, 0.5f, 6, 5);
        p.setMaskFilter(emboss);

        canvas.drawBitmap(_smallBody, _BaseX, _BaseY + _YNUM * _SIZE + 4, p);
    }


    
    public void doDrawSuccess(Canvas canvas, Paint p)
    {
        p.setAlpha(0xff);

        canvas.drawBitmap(_Success, (_nCanvasWidth-200)/2, (_nCanvasHeight-100)/2, p);
    }

    public void doDrawStart(Canvas canvas, Paint p)
    {
        _btnStart.doDrawStart(canvas, p, _GameMode, (_GameMode != _GMSTARTING));
    }

    public void doDrawExit(Canvas canvas, Paint p)
    {
        _btnExit.doDrawExit(canvas, p, (_GameMode != _GMSTARTING));
    }

    
    public void onTouchClick(float x, float y)
    {
        if (_GameMode == _GMSTARTED)
        {
            int nSelectX = -1;
            int nSelectY = -1;

            for (int i = 0; i < _XNUM; i++)
            {
                for (int j = 0; j < _YNUM; j++)
                {
                    if (_cPpTagOrg[i][j].chkSelectin(i, j, x, y))
                    {
                        if (_nMoveCnt == -1)
                        {
                            _cPpTagOrg[i][j].setAlpha(0x33);

                            nSelectX = i;
                            nSelectY = j;
                        }
                        else
                        {
                            Log.i("warning", String.valueOf(_nMoveCnt));
                        }
                    }
                    else
                    {
                        _cPpTagOrg[i][j].setAlpha(0xee);
                    }
                }
            }

            if ((nSelectX > -1) && (nSelectY > -1))
            {
                doTagSelecting(nSelectX, nSelectY);
            }
        }

        
        if (_btnStart.chkSelectin(x, y))
        {
            
            _GameMode = _GMSTARTING; 

            doInitialization();

            _nMixingCount = 20; 

            _btnStart.set_bStarted(true);

            _bStccess = false;

        }

        
        if (_btnExit.chkSelectin(x, y))
        {
            if (_GameMode != _GMSTARTING) System.exit(0);
        }
    }

    private void doTagSelecting(int nSelectX, int nSelectY)
    {
        int nEmptX = -1;
        int nEmptY = -1;

        for (int _i = 0; _i < _XNUM; _i++)
        {
            if (_cPpTagOrg[_i][nSelectY].isBitmapNull() == true)
            {
                nEmptX = _i; 
            }
        }

        for (int _j = 0; _j < _YNUM; _j++)
        {
            if (_cPpTagOrg[nSelectX][_j].isBitmapNull() == true)
            {
                nEmptY = _j; 
            }
        }

        if ((nEmptX > -1) || (nEmptY > -1)) 
        {
            int nCnt = 0;

            if (nEmptX > -1) 
            {
                int sx = (nEmptX > nSelectX) ? nSelectX : nEmptX + 1;
                int ex = (nEmptX < nSelectX) ? nSelectX : nEmptX - 1;

                for (int k = sx; k <= ex; k++)
                {
                    nCnt++;

                    if (nEmptX < nSelectX) _cPpTagOrg[k][nSelectY].doMoveLeft(k, nSelectY);
                    if (nEmptX > nSelectX) _cPpTagOrg[k][nSelectY].doMoveRight(k, nSelectY);
                }

                nCnt++;
                _cPpTagOrg[nEmptX][nSelectY].doJumpTo(nSelectX, nSelectY);
            }
            if (nEmptY > -1) 
            {
                int sy = (nEmptY > nSelectY) ? nSelectY : nEmptY + 1;
                int ey = (nEmptY < nSelectY) ? nSelectY : nEmptY - 1;

                for (int k = sy; k <= ey; k++)
                {
                    nCnt++;

                    if (nEmptY < nSelectY) _cPpTagOrg[nSelectX][k].doMoveUp(nSelectX, k);
                    if (nEmptY > nSelectY) _cPpTagOrg[nSelectX][k].doMoveDown(nSelectX, k);
                }

                nCnt++;
                _cPpTagOrg[nSelectX][nEmptY].doJumpTo(nSelectX, nSelectY);
            }

            _nMoveCnt = nCnt;
        }
    }

    public void doMixing()
    {
        int nEmptX = -1;
        int nEmptY = -1;

        for (int i = 0; i < _XNUM; i++)
        {
            for (int j = 0; j < _YNUM; j++)
            {
                if (_cPpTagOrg[i][j].isBitmapNull())
                {
                    nEmptX = i;
                    nEmptY = j;
                }
            }
        }

        int dir;
        int rx;
        int ry;

        do
        {
            dir = (int) (Math.random() * 2);
        }
        while (dir == _nMixDir);
        _nMixDir = dir;

        do
        {
            rx = (int) (Math.random() * _XNUM);
        }
        while (rx == nEmptX);

        do
        {
            ry = (int) (Math.random() * _YNUM);
        }
        while (ry == nEmptY);

        if (dir == 0)
        {
            doTagSelecting(rx, nEmptY);
        }
        else
        {
            doTagSelecting(nEmptX, ry);
        }

        _nMixingCount--;
    }
}
}}}

= CPpTag.java = 

{{{
package com.PocketPuzzle1;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.Bitmap.Config;

public class CPpTag
{
    
    class CScene
    {
        public long _now;
        public int _x;
        public int _y;
    }

    
    class CSceneQeue
    {
        private int _nSize = 0;
        private int _nHead = 0;
        private int _nTail = 0;
        private int _nNum = 0;
        private CScene _cArrScene[];

        
        public CSceneQeue(int size)
        {
            this._nSize = size;
            this._cArrScene = new CScene[size];

            for (int i = 0; i < size; i++)
            {
                this._cArrScene[i] = new CScene();
            }
        }

       
        public CScene doRead()
        {
            return _cArrScene[_nHead];
        }

       
        public boolean doOut()
        {
            if (_cArrScene[_nHead]._now != 0)
            {
                _cArrScene[_nHead]._now = 0;
                _cArrScene[_nHead]._x = -1;
                _cArrScene[_nHead]._y = -1;

                _nNum--;

                doNextHead();

                return true;
            }
            else
            {
                return false;
            }
        }

       
        private boolean doNextHead()
        {
            if (_nHead != _nTail)
            {
                _nHead++;

                if (_nHead >= _nSize) _nHead = 0;

                return true;
            }
            else
            {

                return false;
            }
        }

       
        public boolean doIn(long now, int x, int y)
        {
            if (_cArrScene[_nTail]._now == 0)
            {
                _cArrScene[_nTail]._now = now;
                _cArrScene[_nTail]._x = x;
                _cArrScene[_nTail]._y = y;

                _nNum++;

                return true;
            }
            else
            {
                if (doNextTail() == true)
                {
                    _cArrScene[_nTail]._now = now;
                    _cArrScene[_nTail]._x = x;
                    _cArrScene[_nTail]._y = y;

                    _nNum++;

                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

                private boolean doNextTail()
        {
            int nOldTail = _nTail;

            _nTail++;
            if (_nTail >= _nSize) _nTail = 0;

            if (_nHead == _nTail)
            {
                _nTail = nOldTail;

                return false;
            }
            else
            {
                return true;
            }
        }

                public int getNum()
        {
            return _nNum;
        }
    }

   

    private int _i;
    private int _j;

    private int _mi = -1;
    private int _mj = -1;

    private int _bx;
    private int _by;

    private int _x;
    private int _y;

    private int _Size;
    private int _Alpha;

   

       public CPpTag(CPpTag[][] cArrTag, Bitmap allBody, int i, int j, int bx, int by, int x, int y, int size, boolean bBitmap, Paint p)
    {
        this._cArrTag = cArrTag;
        this._Alpha = 0xff;

        this._i = i;
        this._j = j;

        this._bx = bx;
        this._by = by;

        this._x = x;
        this._y = y;

        this._Size = size;

        this._cSceneQeue = new CSceneQeue(10);

        if (bBitmap == true)
        {
            this._bitmap = Bitmap.createBitmap(size, size, Config.ARGB_8888);

            Canvas offscreen = new Canvas(this._bitmap);

            offscreen.drawBitmap(allBody, new Rect(i * size, j * size, i * size + size, j * size + size), new Rect(0, 0, size, size), p);

            p.setColor(Color.WHITE);
            offscreen.drawLine(0, 0, size, 0, p);
            offscreen.drawLine(0, 0, 0, size, p);

            p.setColor(Color.GRAY);
            offscreen.drawLine(0, size - 1, size, size - 1, p);
            offscreen.drawLine(size - 1, 0, size, size - 1, p);

            offscreen = null;
        }
        else
        {
            this._bitmap = null;
        }
    }

    public Point getIJ()
    {
        return new Point(_i,_j);
    }

    public void setXY(int x, int y)
    {
        this._x = x;
        this._y = y;
    }

    public void doDraw(Canvas canvas, Paint p)
    {
        if (_bitmap != null)
        {
            p.setAlpha(_Alpha);

            canvas.drawBitmap(_bitmap, _bx + _x, _by + _y, p);
        }
    }

    public void doUpdating(CPpInfo cGame2Ifo)
    {
        if (_Alpha < 0xee) _Alpha += 8;
        if (_Alpha > 0xee) _Alpha = 0xee;

        if (_cSceneQeue.getNum() > 0)
        {
            CScene cPiece = _cSceneQeue.doRead();

            this._x = cPiece._x;
            this._y = cPiece._y;

            long now = System.currentTimeMillis();

            if (now >= cPiece._now)
            {
                _cSceneQeue.doOut();
            }

            if (_cSceneQeue.getNum() == 0)
            {
                cGame2Ifo._nMoveCnt--; 
            }
        }
    }

    public void setAlpha(int alpha)
    {
        _Alpha = alpha;
    }

    public boolean isBitmapNull()
    {
        return (_bitmap == null);
    }

    public boolean chkSelectin(int i, int j, float px, float py)
    {
        boolean bx = (_bx + i * _Size <= px) && (_bx + (i + 1) * _Size > px);
        boolean by = (_by + j * _Size <= py) && (_by + (j + 1) * _Size > py);
        boolean bItem = (_bitmap != null);

        return (bx && by && bItem);
    }

    public void doMoveTo(int x, int y)
    {
        this._bx = x;
        this._by = y;
    }

    public void doJumpTo(int nSelectX, int nSelectY)
    {
        this._mi = nSelectX; 
        this._mj = nSelectY; 

        long now = System.currentTimeMillis();

        _cSceneQeue.doIn(now + 250, _cArrTag[nSelectX][nSelectY]._x, _cArrTag[nSelectX][nSelectY]._y);
    }

    public void doMoveLeft(int k, int nSelectY)
    {
        this._mi = k - 1; 
        this._mj = nSelectY; 

        long dNow = System.currentTimeMillis();

        int nTmp = _cArrTag[k][nSelectY]._x;
        int nAdd = 0;
        int nGap = 32;

        setAlpha(0x33);

        for (int i = 0; i < 5; i++)
        {
            dNow += 50;
            nAdd += nGap;

            nTmp -= nAdd;
            if (nTmp < _cArrTag[k - 1][nSelectY]._x)
            {
                nTmp = _cArrTag[k - 1][nSelectY]._x;
            }

            _cSceneQeue.doIn(dNow, nTmp, _cArrTag[k][nSelectY]._y);

            nGap >>= 1; 
        }
    }

    public void doMoveRight(int k, int nSelectY)
    {
        this._mi = k + 1; 
        this._mj = nSelectY; 

        long dNow = System.currentTimeMillis();

        int nTmp = _cArrTag[k][nSelectY]._x;
        int nAdd = 0;
        int nGap = 32;

        setAlpha(0x33);

        for (int i = 0; i < 5; i++)
        {
            dNow += 50;
            nAdd += nGap;

            nTmp += nAdd;
            if (nTmp > _cArrTag[k + 1][nSelectY]._x)
            {
                nTmp = _cArrTag[k + 1][nSelectY]._x;
            }

            _cSceneQeue.doIn(dNow, nTmp, _cArrTag[k][nSelectY]._y);

            nGap >>= 1;       
           }
    }

    public void doMoveUp(int nSelectX, int k)
    {
        this._mi = nSelectX; 
        this._mj = k - 1; 

        long dNow = System.currentTimeMillis();

        int nTmp = _cArrTag[nSelectX][k]._y;
        int nAdd = 0;
        int nGap = 32;

        setAlpha(0x33);

        for (int i = 0; i < 5; i++)
        {
            dNow += 50;
            nAdd += nGap;

            nTmp -= nAdd;
            if (nTmp < _cArrTag[nSelectX][k - 1]._y)
            {
                nTmp = _cArrTag[nSelectX][k - 1]._y;
            }

            _cSceneQeue.doIn(dNow, _cArrTag[nSelectX][k]._x, nTmp);

            nGap >>= 1;         }
    }

    public void doMoveDown(int nSelectX, int k)
    {
        this._mi = nSelectX; 
        this._mj = k + 1; 

        long dNow = System.currentTimeMillis();

        int nTmp = _cArrTag[nSelectX][k]._y;
        int nAdd = 0;
        int nGap = 32;

        setAlpha(0x33);

        for (int i = 0; i < 5; i++)
        {
            dNow += 50;
            nAdd += nGap;

            nTmp += nAdd;
            if (nTmp > _cArrTag[nSelectX][k + 1]._y)
            {
                nTmp = _cArrTag[nSelectX][k + 1]._y;
            }

            _cSceneQeue.doIn(dNow, _cArrTag[nSelectX][k]._x, nTmp);

            nGap >>= 1; 
        }
    }

    public boolean chkMove()
    {
        return ((_mi != -1) && (_mj != -1));
    }

    public void clearMoveVar()
    {
        _mi = -1;
        _mj = -1;
    }

    public Point getMoveVar()
    {
        return new Point(_mi, _mj);
    }
}
}}}

= CPpThread.java = 

{{{
package com.PocketPuzzle1;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Handler;
import android.view.MotionEvent;
import android.view.SurfaceHolder;

public class CPpThread extends Thread
{
    private SurfaceHolder _holder;
    private CPpInfo _cInfo;

    private boolean _run;
    private long _LastTime;

    
    public CPpThread(CPpInfo cInfo, SurfaceHolder holder, Handler handler)
    {
        _cInfo = cInfo;
        _holder = holder;
    }

    @Override
    public void run()
    {
        while (_run)
        {
            Canvas c = null;

            try
            {
                c = _holder.lockCanvas(null);
                synchronized (_holder)
                {
                    doUpdating();
                    doDraw(c);
                }
            }
            finally
            {
                if (c != null)
                {
                    _holder.unlockCanvasAndPost(c);
                }
            }
        }
    }

    
    private void doUpdating()
    {
        long now = System.currentTimeMillis();

        if (_LastTime > now) return;

        _LastTime = now;

        _cInfo.doTagsUpdating();

        if (_cInfo._nMoveCnt == 0)
        {
            _cInfo.doMoveComplete();
        }

        if (_cInfo._nMoveCnt == -1)
        {
            if (_cInfo._GameMode == CPpInfo._GMSTARTING)
            {
                if (_cInfo._nMixingCount > 0)
                {
                    _cInfo.doMixing();
                }
                else
                {
                    _cInfo._nMixingCount = -1;

                    _cInfo._GameMode = CPpInfo._GMSTARTED;
                }
            }

            if (_cInfo._GameMode == CPpInfo._GMSTARTED)
            {
                if (_cInfo.doChkSuccess())
                {
                    _cInfo._GameMode = CPpInfo._GMSTANDBY;
                    _cInfo._bStccess = true;
                }

            }
        }
    }

    private void doDraw(Canvas canvas)
    {
        Paint p = new Paint();
        p.setAlpha(0xee);

        _cInfo.doDrawBackGround(canvas, p);

        _cInfo.doDrawTags(canvas, p);

        

        _cInfo.doDrawStart(canvas, p);

        _cInfo.doDrawExit(canvas, p);

        _cInfo.doDrawSmall(canvas, p);
        
        if(_cInfo._bStccess)
        {
            _cInfo.doDrawSuccess(canvas, p);
        }

        // canvas.drawBitmap(_cGame2Ifo._coral,_x,_y,p);

        // p.setColor(Color.WHITE);
        // canvas.drawText(_cGame2Ifo.sCanvasSize, _x, _y, p);
    }

    public void setSurfaceSize(int width, int height)
    {
        synchronized (_holder)
        {
            _cInfo.setSurfaceSize(width, height);
        }
    }

    public void setRunning(boolean b)
    {
        _run = b;
    }

    public boolean onTouchEvent(MotionEvent event)
    {
        synchronized (_holder)
        {
            if (event.getAction() == MotionEvent.ACTION_DOWN)
            {
                _cInfo.onTouchClick(event.getX(), event.getY());

            }
            return false;
        }
    }
}
}}}

= CPpView.java = 

{{{
package com.PocketPuzzle1;

import android.content.Context;
import android.os.Handler;
import android.os.Message;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class CPpView extends SurfaceView implements SurfaceHolder.Callback
{
     
     private CPpThread cPpThread;
     
     public CPpView(Context context, AttributeSet attrs)
     {
          super(context, attrs);
          
          SurfaceHolder holder = getHolder();
          holder.addCallback(this);
          
          cPpThread = new CPpThread(new CPpInfo(context), holder, new Handler()
          {
               @Override
               public void handleMessage(Message msg)
               {
                    // super.handleMessage(msg);
               }
          });
     }
     
     @Override
     public boolean onTouchEvent(MotionEvent event)
     {
          return cPpThread.onTouchEvent(event);
     }
     
     @Override
     public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)
     {
          cPpThread.setSurfaceSize(width, height);
     }
     
     @Override
     public void surfaceCreated(SurfaceHolder holder)
     {
          cPpThread.setRunning(true);
          cPpThread.start();
     }
     
     @Override
     public void surfaceDestroyed(SurfaceHolder holder)
     {
          boolean retry = true;
          cPpThread.setRunning(false);
          
          while (retry)
          {
               try
               {
                    cPpThread.join();
                    retry = false;
               }
               catch (InterruptedException e)
               {
                    e.printStackTrace();
               }
          }
     }
     
}
}}}