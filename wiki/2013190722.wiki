#summary 박선우의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong{
	public static void main (String[] args){
		int beerNum = 99;
		String word = "bottles"; //복수형

		while(beerNum > 0){
		
			if(beerNum == 1){
				word = "bottle";   //단수형(한 병인 경우)	
			}

		System.out.println(beerNum + " " + word + " of beer on the wall");
		System.out.println(beerNum + " " + word + " of beer.");
		System.out.println("Take one down.");
		System.out.printon("Pass it around.");
		beerNum = beerNum - 1;

		if(beerNum > 0){
			System.out.println(beerNum + " " + word + " of beer on ther wall");
		}else {
			System.out.println("No more bottles of beer on the wall");
			} //else문 끝
		}//while 순환문 끝
	}//main 클래스 끝
}//클래스끝









}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic{
	public static void main (String[] args){
	 
	String[] fruit = {"apple", "banana", "melon", "grape"};
	String[] animal = {"cat", "dog", "snake", "horse"};
	String[] sport = {"baseball", "basketball", "soccer", "volleyball"};

	int oneLength = fruit.length;
	int twoLength = animal.length;
	int threeLength = sport.length;

	int rand1 = (int)(Math.random() * oneLength);
	int rand2 = (int)(Math.random() * twoLength);
	int rand3 = (int)(Math.random() * twoLength);

	String phrase = fruit[ran1] + " " + animal[ran2] + " " + sport[ran3];
	
	System.out.println("What we need is a " + phrase);
	}
}


}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행, 보안 관련 작업 처리, 바이트코드 확인
 * 컴파일러:실행할 때 절대로 일어나면 안 되는 일을 방지 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b{
	public static void main(String[] args){
		int x = 1;
		while(x < 10){
			if(x >３）｛		
				System.out.println("big x");
			}
		ｘ = x + 1;  // 이 부분을 추가시켜야 함
		}
	}
}
class Exercise2b{   // 클래스가 정의돼어야 한다.
	public static void main(String [] args){
	int x = 5;
	while(x > 1){  
		x = x - 1;
		if(x < 3){
			System.out.println("small x");
		}
	}
}

class Exercise3b{
	public static void main(String [] args){   // while 순환은 반드시 메소드 안에 있어야 한다.
	int x = 5;
	while(x > 1){
		x = x -1;
		if( x < 3){
			System.out.println("small x");
		}
	}
}


}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 
                    변수를 테스트해보는 것 
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Volume, Channel 
 * 메소드: UpVolume, DownVolume, UpChannel, DownChannel 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame
{
        Player p1;
        Player p2;
        Player p3;
        Player p4;

        public void startGame()
        {
                p1 = new Player();
                p2 = new Player();
                p3 = new Player();
                p4 = new Player();

                int guessp1 = 0;
                int guessp2 = 0;
                int guessp3 = 0;
                int guessp4 = 0;

                boolean p1isRight = false;
                boolean p2isRight = false;
                boolean p3isRight = false;
                boolean p4isRight = false;

                int targetNumber = (int) (Math.random()* 10);
                System.out.println("0이상 9이하의 숫자를 맞춰보세요.");

                while(true)
                {
                        System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

                        p1.guess();
                        p2.guess();
                        p3.guess();
                        p4.guess();

                        guessp1 = p1.number;
                        System.out.println("1번 선수가 찍은 숫자: " + guessp1);

                        guessp2 = p2.number;
                        System.out.println("2번 선수가 찍은 숫자: " + guessp2);

                        guessp3 = p3.number;
                        System.out.println("3번 선수가 찍은 숫자: " + guessp3);

                        guessp4 = p4.number;
                        System.out.println("4번 선수가 찍은 숫자: " + guessp4);

                        if ( guessp1 == targetNumber )
                                p1isRight = true;

                        if ( guessp2 == targetNumber )
                                p2isRight = true;

                        if ( guessp3 == targetNumber )
                                p3isRight = true;

                        if ( guessp4 == targetNumber )
                                p4isRight = true;

                        if ( p1isRight || p2isRight || p3isRight || p4isRight)
                        

                        guessp1 = p1.number;
                        System.out.println("1번 선수가 찍은 숫자: " + guessp1);

                        guessp2 = p2.number;
                        System.out.println("2번 선수가 찍은 숫자: " + guessp2);

                        guessp3 = p3.number;
                        System.out.println("3번 선수가 찍은 숫자: " + guessp3);

                        guessp4 = p4.number;
                        System.out.println("4번 선수가 찍은 숫자: " + guessp4);

                        if ( guessp1 == targetNumber )
                                p1isRight = true;

                        if ( guessp2 == targetNumber )
                                p2isRight = true;

                        if ( guessp3 == targetNumber )
                                p3isRight = true;

                        if ( guessp4 == targetNumber )
                                p4isRight = true;

                        if ( p1isRight || p2isRight || p3isRight || p4isRight)
                        {
                                System.out.println("맞은 선수가 있습니다.");
                                System.out.println("1번 선수: " + p1isRight);
                                System.out.println("2번 선수: " + p2isRight);
                                System.out.println("3번 선수: " + p3isRight);
                                System.out.println("4번 선수: " + p4isRight);
                                System.out.println("게임 끝.");
                                Break;
                        }

                        else
                        {
                                System.out.println("다시 시도해야 합니다.");
                        }
                }
        }
}
public class Player     {
        int number = 0;

        public void guess()     {
                number = (int) (Math.Random() * 10);
                System.out.println("찍은 숫자 : " + number );
        }
}

public class GameLauncher       {
        public static void main(String[] args)  {
                GuessGame game = new GuessGame();
                game.startGame();
        }
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class TapeDeck
{
        boolean canRecord = false;

        void playTape() // 테이프 플레이 
        {
                System.out.println("tape playing"); // tape playing 출력
        }

        void recoredTape() // 테이프 녹음
        {
                System.out.println("tape recording"); // tape recording 출력
        {
}

class TapeDeckTestDrive
{
        public static void main(String [] args)
        {
                TapeDeck t = new TapeDeck(); //테이프 객체 생성
                t.canrecord = true; // record가 참
                t.playTape(); // 그래서 재생

                if(t.canRecord == true) // 플레이 없음 녹음
                        t.recordTape();
        }
}



class DVDPlayer 
{
        boolean canRecord = false;
        
        void playDVD()
        {
                System.out.println("DVD playing");
        }
        
        void recordDVD()
        {
                System.out.println("DVD recording");
        }
}

class DVDPlayerTestDrive
{
        public static void main(String [] args)
        {
                DVDPlayer d = new DVDPlayer(); // DVD 객체 생성
                d.canRecord = true;
                d.playDVD();
        
                if(d.canRecord == true)
                        d.recordDVD(); // 실행할 것이 없음 녹음
        }
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시 변수( 정수, 부울, 부동소수점 수와 같은 기초적인 값 - 단순한 비트 패턴으로 나타낼 수 있는 값 ) 

레퍼런스변수( 객체에 대한 레퍼선스가 들어감 ) 
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog
{
        String name;
        public static void main(String [] args)
        {
                int n,i;
                Dog dog1 = new Dog();
                dog1.bark();
                dog1.name = "Bart";

                        
                Dog[] mydogs = new dog[100];

                for(i=0;i<99;i++)
                {
                        myDogs[i] = new Dog();
                }
                myDogs[99] = dog1;

                for(i=0;i<99;i++)
                {
                        myDogs[i].name = "Bart" + i ;
                }
                
                myDogs[99] = "Bart" + n-1;

                System.out.println("마지막 개의 이름 :");      
                System.out.println("myDogs[99].name);
        
                int x = 0;
                
                while(x < myDogs.length)
                {
                        myDog[x].bark();
                        x++;
                }
        }

        public void bark()
        {
                System.out.println(name + "이(가) 왈! 하고 짖습니다.");
        }
        
        public void eat() { }
        public void chaseCat() { }
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Books
{
        String title;
        String author;
}

class BooksTestDrive
{
        public static void main(String [] args)
        {
                Books [] myBookes = new Books[3]; //Books 객체 생성
                int x = 0;
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books();

                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";

                while(x<3) // 차례대로 책이름 저자 프린트
                {       
                        System.out.println(myBooks[x].title);
                        System.out.println(" by ");
                        System.out.println(myBooks[x].author);
                        x++;
                }
        }
}




class Hobbits
{
        
        String name;
        
        public static void main(String [] args)
        {
                Hobbits [] h = new Hobbits[3]; //Hobbits 객체 생성
                int z = 0;
                
                while(z<3) // 차례대로 is a good Hobbit name 프린트
                {
                        h[z] = new Hobbits();
                        h[z].name = "bilbo";
                        if(z==1)
                                h[z].name = "frodo";
                        if(z==2)
                                h[z].name = "sam";
                
                        System.out.println(h[z].name + " is a ");
                        System.out.println("good Hobbit name");
                        z++;
                }
        }
}
}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:bob
 * 문제가 된 부분은 어딘가요?:객체를 형성하지 않음

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:모든 인스턴스 변수에 대해 세터 메소드를 만들고 다른 코드에서는 데이터를 절대 직접 접근할 수 없도록, 반드시 세터 메소드를 사용해야한다. 
 * 게터와 세터:게터(액세서) : 인스턴스 변수의 값 등을 가져옴 

세터(뮤테이터): 인스턴스 변수의 값 등을 설정 
 * 인스턴스 변수 vs 지역 변수:지역 변수에는 기본값이 없다. 따라서 지역 변수를 초기화하기 전에 사용하려고 하면 컴파일 과정에서 오류 
 
*107p Dog* _실행_

{{{
class Dog
{
        int size;
        String name;

        void bark()
        {
                if ( size > 60 )
                        System.out.println("Wooof! Wooof!");
                else if ( size > 14)
                        System.out.println("Ruff! Ruff!");
                else
                        System.out.println("Yip! Yip!");
        {
{

class DogTestDrive
{

        public static void main(String[] args)
        {
                Dog one = new Dog();
                one.size = 70;
                Dog two = new Dog();
                two.size = 8;
                Dog three = new Dog();
                three.size = 35;

                one.bark();
                two.bark();
                three.bark();
        }
}
}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class XCopy
{
        public static void main(String [] args)
        {
                int orig = 42; //orig 에 42를 넣습니다. 

                XCopy x = new XCopy(); //XCopy 란 변수를 만듭니다.

                int y = x.go(orig); // y는 XCopy 변수로 만들고 42를 넣습니다. 그리고 곱하기 2를 합니다.

                System.out.println(orig + " " + y);
        }

        int go(int arg)
        {

                arg = arg * 2;  // arg 를 2배합니다.

                return arg;
        }
}


class Clock
{
        String time;

        void setTime(String t) //시간설정을 합니다.
        {
                time = t;
        }

        String getTime()  // 시간을 보내버리자 값으로
        {
                return time;
        }
}

class ClockTestDrive
{
        public static void main(String [] args)
        {
        Clock c = new Clock(); //Clock 변수를 만듭니다.

        c.setTime("1245"); // time에 1245를 넣습니다.
        String tod = c.getTime(); // tod를 time으로 잡습니다.
        System.out.println("time: " + tod); // 시간을 tod 참고 출력
        }
}
}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 소프트웨어 개발 방법. 프로그래머들이 정말 원하는 방법. 90년대 말에 등장, 여러 회사에서 다양한 규모의 회사에 사용됨. 스펙이 변경되어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있는 장점. 
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class simpledotcomtestdrive {
        
    public static void main(String[] args)  {
        int numofGuesses = 0;
        GameHelper helper = new GameHelper();
        
        simpledotcom thedotcom = new simpledotcom();
        
        int randomNum = (int)(Math.random()*5);
        
        int[] locations = {randomNum, randomNum+1, randomNum+2};
        thedotcom.setLocationCells(locations);
        boolean isAlive = true;
        
        while(isAlive == true)  {
                String guess = helper.getUserInput("enter a number");
                String result = thedotcom.checkYourself(guess);
                numofGuesses++;
                
                if(result.equals("kill"))       {
                        isAlive = false;
                        
                        System.out.println(numofGuesses + " guesses");
                }
        }
    }
}



public class simpledotcom {

        int[] locationCells;
        int numOfHits = 0; // number of answer that you correct the target.

public void setLocationCells (int[] locs)       {
        locationCells = locs;
}

public String checkYourself (String stringGuess)        {
        int guess = Integer.parseInt(stringGuess); // string 변수를 int형으로
        String result = "miss";
        for(int i=0; i < locationCells.length; i++)     {
                if(guess == locationCells[i])   {
                        result = "hit";
                        numOfHits++;
                        break;
                }
        }

        if (numOfHits == locationCells.length)  {
                result = "kill";
        }

        System.out.println(result);
        
        return result;
        }       
}
             


import java.io.*;

public class GameHelper {
        public String getUserInput(String prompt)       {
                String inputLine = null;
                
                System.out.print(prompt + " ");
                
                try{
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        
                        if(inputLine.length() == 0 )
                                return null;
                }       catch (IOException e)   {
                        System.out.println("IOException: " + e);
                }
                
                return inputLine;
        }
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
public class DotcomFirstOption
{
                public static void main(String[] args) 
                {
                        int numOfGuesses = 0;
                        GameHelper helper = new GameHelper();
                        
                        SimpleDotCom theDotCom = new SimpleDotCom();
                        int randomNum = (int) (Math.random() * 5);
                        int[] locations = {randomNum, randomNum + 1,randomNum + 2};
                        theDotCom.setLocationCells(locations);
                        boolean isAlive = true;
                        
                        while(isAlive == true)
                        {
                                String guess = helper.getUserInput("enter a number");
                                String result = theDotCom.checkYourself(guess);
                                numOfGuesses++;
                                
                                if(result.equals("kill"))
                                {
                                        isAlive = false;
                                        System.out.println(numOfGuesses + " guesses");
                                }
                        }
                        
                }

        }

public class SimpleDotCom
{
        int[] locationCells;
        int numOfHits = 0;
        boolean[] hitCells = {false, false, false};//hitCells 배열을 선언하고 모두 false로 초기화해줍니다.
        
        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == locationCells[i]&& hitCells[i] == false)
                        {
                        //guess와 locationCells가 같고 맞춘 셀이 아닐때에만
                                result = "hit";
                                hitCells[i] = true;//hitCells을 true로 설정해줍니다
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}

import java.io.*;
//가져오기를 선언해줍니다. System.in을 사용하기 위함입니다.

public class GameHelper 
{
        public String getUserInput(String prompt)
        {
                String inputLine = null;
                System.out.println(prompt + " ");
                try
                {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0)
                                return null;
                        
                }
                catch (IOException e)
                {
                        System.out.println("IOException: " + e);
                        
                }
                return inputLine;
        }
}
}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
//다른 클래스들은 동일합니다.

public class SimpleDotCom 
{
        int[] locationCells;
        int numOfHits = 0;
        
        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == -1)//만약에 사용자가 입력한 숫자가 -1이면 반복문을 빠져나갑니다.
                                break;
                        else if(guess == locationCells[i])
                        {
                                result = "hit";
                                locationCells[i] = -1;//맞췄을 경우 배열의 값을 -1로 바꿔줍니다.
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
//다른 클래스는 모두 같습니다.

import java.util.ArrayList;

public class DotCom 
{
        private ArrayList<String> locationCells;
        //private int numOfHits;
        //없어도 됩니다.
        
        //배열 대신 string이 들어가는 ArrayList를 사용합니다.
        
        public void setLocationCells(ArrayList<String> loc)
        {
                locationCells = loc;
        }
        
        public String checkYourself(String userInput)//새로 바뀐 인자명입니다.
        {
                String result = "miss";
                
                int index = locationCells.indexOf(userInput);
                //사용자가 추측한 위치가 ArrayList에 들어있는지 확인합니다. 들어있으면 인덱스 번호가, 그렇지 않으면 -1이 리턴됩니다.
                if(index >= 0)//인덱스가 0 이상이면
                {
                        locationCells.remove(index);//제거
                
                        if(locationCells.isEmpty())//목록이 비어있다면 닷컴이 죽었다는 것을 알 수 있다.
                                retult = "kill";        
                        else
                                result = "hit";
                }//바깥쪽 if문 끝
                
                return result;
        }//메소드 끝
}//클래스 끝
}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
import java.util.*;

public class DotCom
{
        private ArrayList<String> locationCells;//DotCom의 인스턴스 변수 -셀위치
        private String name;//DotCom의 인스턴스 변수  -DotCom의 이름

        public void setLocationCells(ArrayList<String> loc)
        {
                locationCells = loc;//DotCom의 위치를 갱신합니다.
        }
        
        public void setName(String n)
        {
                name = n;//이름을 설정합니다
        }
        
        public String checkYourself(String userInput)
        {
                String status = "miss";//처음에 miss로 초기화합니다.
                int index = locationCells.indexOf(userInput);
                //ArrayList의 indexOf()메소드를 사용하여  사용자가 추측한 위치가 ArrayList에 들어있으면 인덱스를 그렇지 않으면 -1을 리턴합니다.
                if(index >= 0)
                {
                        locationCells.remove(index);
                        //ArrayList의 remove 메소드를 써서 그 항목을 지웁니다.
                        if(locationCells.isEmpty())//isEmpty를 써서 모든 위치를 맞췄는지 확인합니다.
                        {
                                status = "kill";
                                System.out.println("Ouch! You sunk " + name + "    : ( ");
                                //DotCom이 가라앉았다고 알려줍니다.
                        }
                        else
                        {
                                status = "hit";//아니면 hit
                        }
                }//if문 끝

        return status;
        }
        //miss or hit or kill을 리턴합니다.
}

import java.util.*;

public class DotComBust 
{
        private GameHelper helper = new GameHelper();//GameHelper객체를 생성합니다.
        private ArrayList<DotCom> dotComsList = new ArrayList<DotCom>();//DotCom객체로 이루어진 ArrayList를 만듭니다.
        private int numOfGuesses = 0;//추측한 숫자를 나타내는 변수를 선언하고 0으로 초기화합니다.
        
        private void setUpGame()//닷컴 객체 몇 개를 만들고 위치를 지정합니다.
        {
                DotCom one = new DotCom();
                one.setName("Pets.com");
                DotCom two = new DotCom();
                two.setName("eToys.com");
                DotCom three = new DotCom();
                three.setName("Go2.com");
                dotComsList.add(one);
                dotComsList.add(two);
                dotComsList.add(three);
                //DotCom 객체 세 개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다.
                
                System.out.println("Your goal is to sink three dot coms.");
                System.out.println("Pets.com, eToys.com, Go2.com");
                System.out.println("Try to sink them all in the fewest number of guesses");
                //사용자에게 간단한 게임 방법을 설명합니다.
                
                for(DotCom dotComToSet : dotComsList)//목록에 있는 각 DotCom에 대해 반복합니다.
                {
                        ArrayList<String> newLocation = helper.placeDotCom(3);
                        //DotCom의 위치를 지정하기 위한 보조 메소드를 호출합니다.
                        dotComToSet.setLocationCells(newLocation);
                        //이 DOtCom 객체의 세터 메소드를 호출하여 방금 보조 메소드에서 받아온 위치를 지정합니다.
                        
                }//for 순환문 끝
        }//setUpgame 메소드 끝
        
        private void startPlaying()
        {
                while(!dotComsList.isEmpty())//dotComsList가 비어있지 않으면 계속 반복합니다.
                {
                        String userGuess = helper.getUserInput("Enter a guess");
                        //사용자의 입력을 받습니다.
                        checkUserGuess(userGuess);
                        //checkUserGuess 메소드를 호출합니다.
                        
                }//while문 끝
                finishGame();
        }//startPlaying 메소드 끝

        private void checkUserGuess(String userGuess)
        {
                numOfGuesses++;//메소드가 호출되면 사용자 추측 횟수를 증가시킵니다.
                String result = "miss";//miss라고 가정합니다.
                
                for(DotCom dotComToTest : dotComsList)//목록의 모든 DotCom 객체에 대해 반복합니다.
                {
                        result = dotComToTest.checkYourself(userGuess);
                        //DotCom 객체에 사용자가 입력한 위치가 맞는지 또는 객체가 죽었는지 물어봅니다.
                        if(result.equals("hit"))//결과가 hit 이라면
                        {
                                break;//순환문을 빠져나옵니다.
                        }
                        if(result.equals("kill"))//결과가 kill이라면
                        {
                                dotComsList.remove(dotComToTest);//DotCom 목록에서 빼고
                                break;//순환문을 빠져나옵니다.
                        }
                }//for 문 끝
        }//checkUserGuess 메소드 끝
        
        private void finishGame()//게임 결과를 알려주는 메시지를 출력합니다.
        {
                System.out.println("All Dot Coms are dead! Your stock is now worthless");
                if(numOfGuesses <= 18)
                {
                        System.out.println("It only took you " + numOfGuesses + " guesses.");
                        System.out.println("You got out before your options sank");
                }
                else
                {
                        System.out.println("Took you long enough. " + numOfGuesses + " guesses.");
                        System.out.println("Fish are dancing with your options");
                }
        }

        public static void main(String[] args)
        {
                DotComBust game = new DotComBust();//DotComBust 객체를 만듭니다.
                game.setUpGame();//게임 객체에 게임을 설정하라는 명령을 내립니다.
                game.startPlaying();
                //게임 객체에서 주 게임 진행 순환문을 돌리라는 명령을 내립니다
        }

}


import java.io.*;
import java.util.*;

public class GameHelper
{
        private static final String alphabet = "abcdefg";
        private int gridLength = 7;
        private int gridSize = 49;
        private int[] grid = new int[gridSize];
        private int comCount = 0;
        
        public String getUserInput(String prompt)
        {
                String inputLine = null;
                System.out.println(prompt +" ");
                try
                {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if(inputLine.length() == 0)
                                return null;    
                }
                catch(IOException e)
                {
                        System.out.println("IOException: " + e);
                }
        
                return inputLine.toLowerCase();
                
        }
        
        public ArrayList<String> placeDotCom(int comSize)
        {
                ArrayList<String> alphaCells = new ArrayList<String>();//F6과 같은 좌표가 들어감
                String temp = null;//나중에 연결하기 위한 임시 String배열
                int[] coords = new int[comSize];//현재 후보 좌표
                int attempts = 0;//시도 횟수를 세기 위한 카운터
                boolean success = false;//적당한 위치를 찾았느지 표시하기 위한 플래그
                int location = 0;//현재 시작 위치
                
                comCount++;//n번째 닷컴
                int incr = 1;//수평 방향으로 증가시킬 값 설정
                if((comCount % 2)==1)//홀수 번째 닷컴인 경우
                {
                        incr = gridLength;//수직 방향으로 증가시킬 값 결정
                }
                
                while(!success & attempts++ < 200)//주 검색 순환문(32)
                {
                        location = (int) (Math.random() * gridSize);//임의 시작 위치를 구함
                        //System.out.print(" try " + location);
                        
                        int x = 0;//위치시킬 닷컴의 n번째 위치
                        success = true;//성공할 것으로 가정함
                        while(success && x < comSize)//닷컴이 들어갈 자리가 비었는지 확인
                        {
                                if(grid[location] == 0)//아직 사용하지 않았으면
                                {
                                        coords[x++] = location;//위치 저장
                                        location += incr;//다음 칸 확인
                                        if(location >= gridSize)//경계를 벗어난 경우
                                                success = false;//실패
                                        if(x > 0 & (location % gridLength == 0))//경계를 벗어난 경우(오른쪽)
                                                success = false;//실패
                                        else//이미 사용중인 경우
                                                //System.out.print(" used " + location)
                                                success = false;//실패
                                }
                        }
                        
                }//while 끝

        int x = 0;//위치를 알파벳 좌표로 바꿈
        int row = 0;
        int column = 0;
        
        while(x < comSize)
        {
                grid[coords[x]] = 1;//기본 그리드 좌표를 사용중 으로 표시
                row = (int) (coords[x] / gridLength);//행 값을 구함
                column = coords[x]&gridLength;//열 값을 구함
                temp = String.valueOf(alphabet.charAt(column));//숫자가 된 열을 알파벳으로 변환
                
                alphaCells.add(temp.concat(Integer.toString(row)));
                x++;
                //System.out.println("   coord  " + x + " = "  + alphaCells.get(x-1));
                //DotCom의 위치를 알려주는 메소드
                                
        }
        
        return alphaCells;
        }
        
}
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상속을 이용한다는 것은 공통적인 코드를 어떤 클래스에 넣은 다음, 다른 더 구체적인 클래스에 공통적인(더 추상적인)클래스가 상위클래스라는 것을 알려준다는 것. 즉 하위클래스가 상위클래스로부터 상속받는다, 하위클래스가 상위클래스를 확장한다고 얘기한다. 
 * 다형성:  다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{
class Animal
{
        String picture;
        Boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise()
        {
                //소리를 낼 때의 행동
        }

        void eat()
        {
                //그 동물이 음식을 접했을 때의 행동
        }

        void sleep()
        {
                //그 동물이 잠들어 있을 때의 행동
        }

        void roam()
        {
                //그 동물이 먹거나 자고 있지 않을 때의 행동
        }

}
class Feline extends Animal//Feline은 Animal을 상속받습니다.
{
        void roam()
        {
                //roam을 오버라이드합니다.
        }
}

class Canine extends Animal//Canine은 Animal을 상속받습니다.
{
        void roam()
        {
                //roam을 오버라이드합니다.
        }
}

class Lion extends Feline//Lion은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Tiger extends Feline//Tiger은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}



class Cat extends Feline//Cat은 Feline을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Hiippo extends Animal//Hippo는 Animal을 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Wolf extends Canine//Wolf는 Canine를 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}

class Dog extends Canine//Dog는 Canine를 확장합니다.
{
        void makeNoise()
        {
                //makeNoise를 오버라이드합니다.
        }

        void eat()
        {
                //eat를 오버라이드합니다.
        }
}
}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 인자를 받지 않으며 부울 값을 리턴하는 것. 즉 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야함. 
 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것. 오버로드된 메소드는 다형성과는 전혀 관계가 없다. 

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
1.
public class MonsterTestDrive {
        public static void main(String []args) {
                Monster [] ma= new Monster[3];
                ma[0]=new Vampire();
                ma[1]=new Dragon();
                ma[2]=new Monstere();
                for(int x=0;,x<3;x++) {
                        ma[x].fighten(x);
                }
        }
}

class Monster {
        boolean frighten(int d) {
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster {
        boolean frighten (int x) {
                System.out.println("a bite?");
                return false;
        }
}

class Dragon extends Monster {
        boolean frighten (int degree) {
                System.out.println("breath fire");
                return true;
        }
}

1번코드는 제대로 작동.
}}}

{{{
2.
public class MonsterTestDrive {
        public static void main(String []args) {
                Monster [] ma= new Monster[3];
                ma[0]=new Vampire();
                ma[1]=new Dragon();
                ma[2]=new Monstere();
                for(int x=0;,x<3;x++) {
                        ma[x].fighten(x);
                }
        }
}

class Monster {
        boolean frighten(int x) {
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster {
        boolean frighten (int f) {
                System.out.println("a bite?");
                return 1; //Vampire의 리턴유형이 int여서 컴파일이 안됨
        }
}

class Dragon extends Monster {
        boolean frighten (int degree) {
                System.out.println("breath fire");
                return true;
        }
}
//2번코드는 작동 안됨
}}}

{{{
3.
public class MonsterTestDrive {
        public static void main(String []args) {
                Monster [] ma= new Monster[3];
                ma[0]=new Vampire();
                ma[1]=new Dragon();
                ma[2]=new Monstere();
                for(int x=0;,x<3;x++) {
                        ma[x].fighten(x);
                }
        }
}

class Monster {
        boolean frighten(int x) {
                System.out.println("arrrgh");
                return false;
        }
}

class Vampire extends Monster {
        boolean frighten (int x) {
                System.out.println("a bite?");
                return true;
        }
}

class Dragon extends Monster {
        boolean frighten (int degree) {
                System.out.println("breath fire");
                return true;
        }
} //vampire클래스에서 monster 클래스의 frighten() 메소드를 오버라이드를 하지않아서
arrrgh
breath fire
arrrgh
라는 결과가 나온다.
}}}

{{{
4.
public class MonsterTestDrive {
        public static void main(String []args) {
                Monster [] ma= new Monster[3];
                ma[0]=new Vampire();
                ma[1]=new Dragon();
                ma[2]=new Monstere();
                for(int x=0;,x<3;x++) {
                        ma[x].fighten(x);
                }
        }
}

class Monster {
        boolean frighten(int z) {
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster {
        boolean frighten (byte b) //int가 아닌 byte로 인자를 받아서 
         {
                System.out.println("a bite?");
                return true;
        }
}

class Dragon extends Monster {
        boolean frighten (int degree) {
                System.out.println("breath fire");
                return true;
        }
}

//vampire클래스에서 monster 클래스의 frighten() 메소드를 오버라이드를 하지않아서
arrrgh
breath fire
arrrgh
라는 결과가 나온다.
}}}
= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100% 추상클래스. 자바에서 정말 필수불가결한 부분. 
 * 다형성: '여러형태'를 의미.
 * 추상 클래스: 클래스 선언시 앞에 abstract만 붙이면 됨. 추상클래스란, 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스를 의미. 반드시 확장해야하는 클래스를 의미. 
 * 추상 메소드: 반드시 오버라이드해야하는 메소드를 의미. 중괄호없이 세미콜론을 써서 선언을 끝냄. 추상 메소드를 만들 때는 클래스도 반드시 추상클래스여야함.
 * 다중 상속:  상위클래스를 두 개 사용하는 접근법. 하지만 여기에는 '죽음의 다이아몬드'라고 알려져 있는 문제가 있다. 


= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객체가 사는 곳이다. 인스턴스 변수는 객체 안에 살기 때문에 즉 인스턴스 변수가 힙 안에 살고 있는 것이다. 
 * 스택에서의 변수: 스택은 메소드 호출과 지역 변수가 사는 곳이다. 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스, 즉 리모컨)만 스택에 들어간다. 객체 자체는 힙 안에 있습니다. (메소드 매개변수도 지역 변수에 포함) 
 * 생성자: 객체를 생성할 때 실행되는 코드가 들어있다. 즉 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있다. 우리가 직접 만들지 않아도 된다.
 * 널 레퍼런스: 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다. 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException? 이 생긴다. 
 
정적 변수에 대한 토론

 * 인스턴스 변수: 정적 변수는 상수에 불가, 특변한 경우에만 많이 사용, 디버깅할때에
만 특별한경우로 사용, 객체지향적이 아님, 전역변수랑 비슷함, 옛 관습에 익숙한 사람
들만 사용함, 가끔 익숙하긴 하지만 여전히 옛습관의 폐해, 프로시저 위주

 * 정적 변수: API에서 많이 사용, 상수만 사용하는 클래스도 존재 특별한 경우라도 중
요함 정적변수가 더 효율적, 전역변수가 아님, 클래스 안에서 존재,필수적인것도 있음

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class StaticSuper{

        static { 
        System.out.println("super static block");
        }

        StaticSuper() { //생성자이므로 ()를 붙입니다.
        System.out.println("super constructor");
        }
}

public class StaticTests extends StaticSuper {//StaticSuper를 상속

        static int rand; 

        static { 
        rand=(int_ (Math.random()*6);
        System.out.println("static block " + rand);
        }

        StaticTests(){ 
        System.out.println("constructor");
        {

        public static void main(String [] args) {
        System.out.println("in main");
        StaticTests st = new StaticTests ();//객체 생성
        }
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{


public void takeRisk() throws BadException
        {
                if(abandonAllHope)//만약 모든 희망을 버리면으로 오류가 생기는 부분입니다.
                {
                        throw new BadException();//BadException이라는 오류를 throw합니다.
                }
        }
        
 public void crossFingers()
        {
                try
                {
                        anObject.takeRisk();//오류가 발생할수 있는 부분입니다.
                }
                catch(BadException ex)//BadException을 잡습니다. 오류가 뜨면 밑의 
부분이 실행됩니다.
                {
                        System.out.println("Aaargh!");
                        ex.printStackTrace();
/*예외 상황을 해결할수 없을때 모든 예외 객체에서 물려받는 printStackTrace()메소드
를 써서 스택 트레이스를 출력합니다.*/
                }
        
        
        }
}
}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

import javax.sound.midi.*;//미디 패키지를 import합니다.

public class MiniMiniMusicApp {
 
	public static void main(String[] args) {
		MiniMiniMusicApp mini = new MiniMiniMusicApp();
		mini.play();
	}

	
	public void play() {
		try{
/*Sequencer를 받아서 엽니다.그래야만 열립니다.*/
			Sequencer player = MidiSystem.getSequencer();
			player.open();
/*Sequencer 생성자로 넘기는 인자에 대해서는 신경 쓰지 않아도 됩니다.*/
			Sequence seq = new Sequence(Sequence.PPQ,4);
/*Sequence에 Track을 요청합니다.*/
			Track track = seq.createTrack();
/*Track에 MidiEvent를 집어넣습니다.*/
			ShortMessage a = new ShortMessage();
			a.setMessage(144, 1, 44, 100);
			MidiEvent noteon = new MidiEvent(a,1);
			track.add(noteon);
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,44,100);
			MidiEvent noteOff = new MidiEvent(b,16);
/*Sequencer에 Sequence를 보냅니다.*/
			player.setSequence(seq);
/*Sequencer의 start()메소드를 호출합니다.*/
			player.start();
		} catch ( Exception ex) {
			ex.printStackTrace();
		}
	}
}

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

import javax.sound.midi.*;


public class MiniMusicCmdLine
{//첫번째
        public static void main(String[] args)
        {
                MiniMusicCmdLine mini = new MiniMusicCmdLine();
                
                if(args.length < 2 )
                        System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
                else
                {
                        int instrument = Integer.parseInt(args[0]);
                        int note = Integer.parseInt(args[1]);
                        mini.play(instrument,note);
                        
                }
        }
        
        public void play(int instrument, int note)
        {
                try
                {
                        Sequencer player = MidiSystem.getSequencer();//시퀀서를 생성
                        player.open();
                        Sequence seq = new Sequence(Sequence.PPQ,4);
                        Track track = seq.createTrack();//track 을 생성
                        
                        MidiEvent event = null;//event 생성, null값을 대입
                        
                        ShortMessage first = new ShortMessage();
            first.setMessage(192,1,instrument,0);
            MidiEvent changeInstrument = new MidiEvent(first, 1);
            track.add(changeInstrument);

            ShortMessage a = new ShortMessage();
            a.setMessage(144,1,note,100);
            MidiEvent noteOn = new MidiEvent(a,1);
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            a.setMessage(128,1,note,100);
            MidiEvent noteOff = new MidiEvent(b,16);
            track.add(noteOff);
            player.setSequence(seq);
            player.start();
                }
                
                catch(Exception ex)
                {
                        ex.printStackTrace();
                }
        }//play 메소드 끝
}//클래스 끝
}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}