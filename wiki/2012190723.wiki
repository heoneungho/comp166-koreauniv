#summary ★☆★☆★☆★☆★☆★☆ [컴퓨터교육과 2012190723 남학생]의 실습페이지입니다. ☆★☆★☆★☆★☆★☆★

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
주어진 코드로 프로그램을 만들게되면 출력 결과에 문제가 생긴다.
후반부에
1 bottles of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
이렇게 출력이 되는데 이때, 1 bottles 라고 복수형으로 출력되는 문제가 발생된다.
따라서, 이 문제를 해결하기 위해서는 if(beerNum==1)조건문의 위치를 바꾸면 된다.

public class BeerSong {    // BeerSong이라는 이름의 클레스를 생성합니다.
   public static void main(String[]args){  // main 메소드를 하나 생성합니다.
      int beerNum=99; // beerNum이라는 정수형 변수에 99를 넣습니다.
      String word="bottles"; // 문자열 word 변수에 "bottles"를 넣습니다.

      while(beerNum>0){ // beerNum이 0이 되기 전까지 반복문을 반복합니다.

          System.out.println(beerNum+""+word+"of beer on the wall");
          System.out.println(beerNum+""+word+"of beer.");
          System.out.println("Take one down.");
          System.out.println("Pass it around.");
          beerNum=beerNum-1;

      if(beerNum==1){
          word="bottle"; // beerNum이 1이되면 word를 단수형인 "bottle"로 바꿉니다.
      }
      if(beerNum>0){
          System.out.println(beerNum+""+word+"of beer on the wall");
      }else{
          System.out.println("No more bottles of beer on the wall");
      } //else문을 종료합니다.
     } //while 순환문을 종료합니다.
    } //main 클래스를 종료합니다.
   } //클래스를 종료합니다.

이렇게 코드를 수정하면,
1 bottle of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
에서 처럼 1개의 병을 단수형(bottle)으로 나타낸다.
따라서, 1개의 병이 bottles로 출력되는 문제를 해결했다.

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic{
 public static void main(String[]args){

//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
  String[]wordListOne={"People","Dog","Fish","Cat","Man","Girl","Boy",
"Computer","Monitor","Butter"};

  String[]wordListTwo={"is","are","were","was","makes","did","be",
"drinks","fires","swim","barks","run","walk","work","sing","fight"};

  String[]wordListThree={"fast","slowly","early","instantly","funny","laugh","human",
"cheese","cake","high","jump","pool","fire","egg","game"};

//각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
int oneLength=wordListOne.length;
int twoLength=wordListTwo.length;
int threeLength=wordListThree.length;

//난수 세 개를 발생시킵니다.
int rand1=(int) (Math.random()*oneLength);
int rand2=(int) (Math.random()*twoLength);
int rand3=(int) (Math.random()*threeLength);

//이제 구문을 만듭니다.
  String phrase=wordListOne[rand1]+""+wordListTwo[rand2]+""+wordListThree[rand3];

//구문을 출력합니다.
  System.out.println("What we need is a"+phrase);
 }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
1. 컴파일러는 파일만 줄뿐 실행은 자바 가상 머신(JVM)이 한다.

2. 프로그래머가 직접 바이트 코드를 작성해도된다.

3. JVM이 ClassCast Exception을 발생시킨다. 

4. JVM은 보안 관련 작업을 처리한다.

5. 바이트코드가 만들어진 다음 실행되기 전까지 다른 사람이 건드리는지 확인한다.

 * 컴파일러:
1. 자바가 인터프리터 언어라면 실행 속도가 느려질 것이다. 즉, 바이트코드 컴파일러를 사용해야한다.

2. 워드 프로세서 없이 포스트스크립트를 직접 작성하는 것과 마찬가지로 바이트코드를 직접 짜는 건 불가능하다.

3. 자바는 type을 지키는 언어이므로 컴파일러가 위반 사항을 막는다.

4. ClassCast Exception은 동적 바인딩을 지원하기 위한 것, 유연성을 확보하기 위해 실행 할 때 일어나면 안 되는 일을 미리 감지하고 방지한다.

5. 비공개 메소드 호출과 수정하면 안 되는 메소드 변경과 같은 접근 위반을 방지한다.
또한, 클래스의 핵심 내용에 접근하는 코드와 함부로 보면 안 되는 코드를 건드리는 것도 방지한다.

6. 컴파일러가 우선적으로 문제점을 잡아낸다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A: 
// big x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){
  int x=1;
  while(x<10){
   x=x+1; // 이 부분이 빠지면 while 반복문이 무한히 순환합니다. 
   if(x>3){
    System.out.println("big x");
   }
  }
 }
}

B:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1a{ // 클래스 정의 부분이 빠져있기때문에 추가했습니다.
 public static void main(String[]args){
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}
  
C:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){ //메소드가 빠져서 추가했습니다.
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것, 객체의 상태(데이터)를 나타낸다.
 * 메소드: 객체에서 자신이 하는 것.
 * 클래스: 객체를 만들기 위한 용도로 사용. 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: color, power, channel
 * 메소드: power(), channelUp(), ChannelDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
/* GuessGame 코드입니다. 게임에 참여하는 사람 수를 4명으로 변경한 코드입니다. */
class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4; // 추가된 4번째 사람입니다.

	public void startGame(){
		p1=new Player();
		p2=new Player();
		p3=new Player();
		p4=new Player();

		int guessp1=0; // 각 객체가 찍은 숫자를 저장하기위한 변수입니다.
		int guessp2=0;
		int guessp3=0;
		int guessp4=0;

		boolean p1isRight=false;
		boolean p2isRight=false;
		boolean p3isRight=false;
		boolean p4isRight=false;

		int targetNumber=(int)(Math.random()*10);
		System.out.println("0이상 9이하의 숫자를 맞춰보세요.");

		while(true){
			System.out.println("맞춰야 할 숫자는"+targetNumber+"입니다.");

			p1.guess(); // 각 사람이 숫자를 추측합니다.
			p2.guess();
			p3.guess();
			p4.guess();

			guessp1=p1.number;
			System.out.println("1번 선수가 찍은 숫자:"+guessp1); // 각 선수가 찍은 숫자를 알아냅니다.

			guessp2=p2.number;
			System.out.println("2번 선수가 찍은 숫자:"+guessp2);

			guessp3=p3.number;
			System.out.println("3번 선수가 찍은 숫자:"+guessp3);

			guessp4=p4.number;
			System.out.println("4번 선수가 찍은 숫자:"+guessp4);

			if(guessp1==targetNumber){ // 따라서, 추측한 숫자가 맞으면 boolean값을 true로 바꿉니다.
				p1isRight=true;
			}

			if(guessp2==targetNumber){
				p2isRight=true;
			}

			if(guessp3==targetNumber){
				p3isRight=true;
			}

			if(guessp4==targetNumber){
				p4isRight=true;
			}

			if(p1isRight|p2isRight|p3isRight|p4isRight){
				System.out.println("맞춘 선수가 없습니다.");
				System.out.println("1번 선수:"+p1isRight);
				System.out.println("2번 선수:"+p2isRight);
				System.out.println("3번 선수:"+p3isRight);
				System.out.println("4번 선수:"+p4isRight);
				break;
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

// Player 클래스입니다.
class Player{
	int number=0;

	public void guess(){
		number=(int)(Math.random()*10);
		System.out.println("찍은 숫자:"+number);
	}
}

// GameLauncher 클래스입니다.
public class GameLauncher{
	public static void main (String[]args){
		GuessGame game=new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A:
class TapeDeck{ // 테입덱이라는 클래스를 생성합니다.

	boolean canRecord=false; // canRecord를 불린 값으로 지정합니다.

	void playTape(){
		System.out.println("tape playing");
	}

	void recordTape(){
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive{ // 테스트 클래스를 만듭니다.
	public static void main(String[]args){

		TapeDeck t=new TapeDeck(); // t객체를 만들어 줍니다.

		t.canRecord=true;
		t.playTape();

		if(t.canRecord==true){
			t.recordTape();
		}
	}
}

B:
class DVDPlayer{
	boolean canRecord=false;
	void recordDVD(){
		System.out.println("DVD recording");
	}
	void playDVD(){ // playDVD 메소드를 설정해야 아래 클래스에서 객체를 사용할 수 있습니다.
		System.out.println("DVD playing");
	}
}
class DVDPlayerTestDrive{
	public static void main(String[]args){
		DVDPlayer d = new DVDPlayer();
		d.canRecord=true;
		d.playDVD();
			if(d.canRecord==true){
				d.recordDVD();
			}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
1) 원시변수: 
원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다.

2) 레퍼런스 변수:
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.


 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog { // Dog 클래스를 생성합니다.
	String name;
	public static void main(String[]args){
		// Dog 객체를 만들고 접근합니다.
		Dog dog1=new Dog();
		dog1.bark();
		dog1.name="Bart";

		Dog[]myDogs=new Dog[10]; // Dog 배열을 만들어 난장판을 만들겁니다.
		myDogs[0]=new Dog();
		myDogs[1]=new Dog();
		myDogs[2]=dog1; // myDogs[2]에 dog1을 넣습니다.
		myDogs[3]=new Dog();
		myDogs[4]=new Dog();
		myDogs[5]=new Dog();
		myDogs[6]=new Dog();
		myDogs[7]=new Dog();
		myDogs[8]=new Dog();
		myDogs[9]=new Dog();

		// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.

		myDogs[0].name="Fred";
		myDogs[3].name="JungGon";
		myDogs[4].name="Chaewon";
		myDogs[5].name="Seohyun";
		myDogs[6].name="kyungMin";
		myDogs[7].name="Heawon";
		myDogs[8].name="Park";
		myDogs[9].name="BongWoo";

		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[9].name); // 마지막 개의 이름을 출력합니다.

		// 순환문을 써서 배열에 있는 개가 짖도록 합니다.

		int x=0;
		while(x<myDogs.length){
			myDogs[x].bark();
			x=x+1;
		}
	}

	public void bark(){
		System.out.println(name+"이(가) 왈!하고 짖습니다.");
	}
	public void eat(){}
	public void chaseCat(){}


}



}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A:
// Books 클래스를 생성합니다.
class Books{
	String title;
	String author;
}

class BooksTestDrive{
	public static void main(String[]args){
		Books[]myBooks=new Books[3]; 
		int x=0;
		// Books 객체를 생성합니다.
		myBooks[0]=new Books();
		myBooks[1]=new Books();
		myBooks[2]=new Books();

		// 객체들의 속성을 채워줍니다.
		myBooks[0].title="The Grapes of Java";
		myBooks[1].title="The Java Gatsby";
		myBooks[2].title="The Java Cookbook";
		myBooks[0].author="bob";
		myBooks[1].author="sue";
		myBooks[2].author="ian";
		while(x<3){
			System.out.print(myBooks[x].title);
			System.out.print("by");
			System.out.println(myBooks[x].author);
			x=x+1;
		}		
	}

}

B:
// Hobbits 클래스를 생성합니다.
class Hobbits {
	String name;
	public static void main (String [] args) {

		Hobbits [] h = new Hobbits[3];
		int z = 0; // 배열의 인덱스는 0에서 시작하므로 0으로 설정합니다.

		while (z<3)     {    // 따라서 z<3입니다.

		h[z] = new Hobbits(); // 객체를 생성합니다.
		h[z].name = "bilbo";
		if (z==1) {
			h[z].name = "frodo";
		}
		if (z==2) {
			h[z].name = "sam";
		}
		System.out.print(h[z].name + " is a ");
		System.out.println("good hobbit name");
		z = z + 1; //Z의 값을 1씩 증가시킵니다.
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 
밥이 이겼습니다.
 * 문제가 된 부분은 어딘가요?:
켄트의 메소드에는 순환문을 한 바퀴 돌 때마다 새로운 객체를 레퍼런스 변수 하나에 대입했기때문에,

전에 참조하고 있던 객체는 버려지게되는 문제가 발생했습니다.

따라서, 레퍼런스 변수하나에 객체 하나씩 연결한 밥이 켄트를 이겼습니다.


= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
객체의 자료와 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것입니다.

캡슐화를 하려면, 인스턴트 변수를 private으로 지정하고

접근 제어를 위해 public으로 지정된 게터와 세터를 만들면 됩니다.

 * 게터와 세터:
캡슐화를 위해 게터와 세터 메소드를 사용합니다.

인스턴트 변수를 private으로 설정하고 게터와 세터로 값을 받고 리턴합니다.

게터와 세터를 이용하면 코드 변경시 다른 코드는 건드리지 않아도 됩니다.


 * 인스턴스 변수 vs 지역 변수:
 
1) 인스턴트 변수

- 클래스 내에서 선업됩니다.

2) 지역 변수

- 메소드 내에서 선업됩니다.

- 기본값이 없습니다. 

- 사용하기 전에 반드시 초기화해야합니다.

*107p Dog* _실행_

{{{

// 여러 개들이 짖는 프로그램입니다.
// Dog 클래스를 생성합니다.
class Dog {
	int size;
	String name;

	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof!");
		}else if(size>14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}

}
class DogTestDrive{

	public static void main(String[]args){
		// Dog 객체들을 생성합니다.
		Dog one=new Dog();
		one.size=70;
		Dog two=new Dog();
		two.size=8;
		Dog three=new Dog();
		three.size=35;
		// 동일한 메소드로 서로 다른 결과가 나오는 것을 확인합니다.
		one.bark();
		two.bark();
		three.bark();

	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A:

// 수(인자)를 메소드에 넘겼다가 리턴받는 코드입니다. 
class XCopy {

	public static void main(String[] args) {
		int orig=42;
		XCopy x=new XCopy(); // XCopy 객체 x를 생성합니다.
		int y= x.go(orig); // y변수에 42를 go 메소드에 넘겨받은 리턴값을 대입합니다.
		System.out.println(orig+""+y); // orig와 y를 출력합니다.
	}

	int go(int arg){ // 이때 orig의 값은 바뀌지 않습니다.
		arg=arg*2;
		return arg;
	}
}


B:

// 게터와 세터를 사용하여 캡슐화를 한 코드입니다.
class Clock{
	String time;
	void setTime(String t){
		time=t;
	}
	String getTime(){ // 게터 메소드에는 리턴 타입을 설정해야합니다.
		return time;
	}
}

class ClockTestDrive {

	public static void main(String[] args) {
		Clock c= new Clock();
		c.setTime("1245");
		String tod=c.getTime();
		System.out.println("time:"+tod);
	}

}


}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

- 90년대 말에 등장한 소프트웨어 개발 방법이다.

- 마지막에 스펙이 변경되어도 고객이 원하는 기한에 맞춰서 제공할 수 있다.

- 모든 일을 단순하게 처리

- 사이클을 반복하여 개발 및 테스트  코드를 먼저 만든다.

- 기회가 생길때 마다 코드를 개선

- 두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업.

- 모든 테스트를 통과하기 전에는 발표하지 않는다.

 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

// SimpleDotCom 게임의 최종 코드입니다.
// 가져오기를 선언합니다.
import java.io.*;

class GameHelper { //GameHelper 클래스를 생성합니다.
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + "");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(
					System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0)
				return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}
class SimpleDotCom { //SimpleDotCom 클래스를 생성합니다.
	int[] locationCells;
	int numOfHits = 0; // 초기 hit 수를 0으로 설정합니다.

	public void setLocationCells(int[] locs) {
		locationCells = locs;

	}

	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess); // string을 int로 변환합니다.
		String result = "miss"; // 리턴할 결과를 저장할 변수입니다. 기본값은 "miss" 입니다.
		for (int i = 0; i < locationCells.length; i++) { // 추측한 값을 배열의 원소와 비교합니다.
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break; // 순환문을 빠져나옵니다.
			}
		}
		if (numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;

	}
}

// 테스트 드라이브 클래스입니다.
public class SimpleDotComTestDrive { 

	public static void main(String[] args) {

		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

		int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;

		while (isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;

			if (result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}

		} 

	}  // 메소드 끝
} // 클래스 끝


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

// 첫번째 옵션을 구현한 코드입니다.

import java.io.*;

class GameHelper { // GameHelper 클래스를 생성합니다.

	public String getUserInput (String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");

		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}

		return inputLine;
	}

}

public class SimpleDotComTestDrive { // SimpleDotComTestDrive클래스를 생성합니다.

	public static void main(String[] args){


		int numOfGuesses=0;

		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};

		boolean[] hitCells = new boolean[3]; // 첫번째 옵션, 사용자가 입력 했던 값을 판단하기 위한  boolean 배열을 생성합니다.

		//닷컴 클래스로 boolean 배열을 넘겨줍니다
		theDotCom.sethitCells(hitCells);

		theDotCom.setLocationCells(locations);

		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + "guesses");
			}

		}
	}

}


class SimpleDotCom { // SimpleDotCom클래스를 생성합니다.

	int[] locationCells;
	boolean[] hitCells = new boolean[3];

	int numOfHits = 0;

	public void setLocationCells(int[] locs){

		locationCells = locs;
	}

	public void sethitCells(boolean[] check){ 
		hitCells = check;
	}


	public String checkYourself(String stringGuess){

		int guess = Integer.parseInt(stringGuess);

		String result = "miss";

		for(int i = 0; i < locationCells.length; i++){

			if(guess == locationCells[i] && hitCells[i]!=true){ // 이미 맞춘 배열인지 확인합니다.
				result = "hit";
				numOfHits++;
				hitCells[i] = true; // 맞춘 배열이기때문에 true로 바꿔줍니다.
				break;

			}

		}

		if (numOfHits == locationCells.length){
			result = "kill";
		}

		System.out.println(result);
		return result;

	}

}



}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

// 두번째 옵션을 구현한 코드입니다.

import java.io.*;

class GameHelper { // GameHelper 클래스를 생성합니다.

	public String getUserInput (String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");

		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}

		return inputLine;
	}

}

public class SimpleDotComTestDrive { // SimpleDotComTestDrive클래스를 생성합니다.

	public static void main(String[] args){


		int numOfGuesses=0;

		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};

		theDotCom.setLocationCells(locations);

		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + "guesses");
			}

		}
	}

}


class SimpleDotCom { // SimpleDotCom클래스를 생성합니다.

	int[] locationCells;


	int numOfHits = 0;

	public void setLocationCells(int[] locs){

		locationCells = locs;
	}

	public String checkYourself(String stringGuess){

		int guess = Integer.parseInt(stringGuess);

		String result = "miss";

		for(int i = 0; i < locationCells.length; i++){

			if(guess == locationCells[i] && locationCells[i]!=-1){ // 이미 맞춘 배열인지 확인합니다. 이미 맞춘 배열은 -1값을 가집니다.
				result = "hit";
				numOfHits++;
				locationCells[i]=-1; // 맞춘 배열은 -1값으로 변경해줍니다.(두번째 옵션)

				break;

			}

		}

		if (numOfHits == locationCells.length){
			result = "kill";
		}

		System.out.println(result);
		return result;

	}

} // 클래스 끝

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
// 세번째 옵션을 구현한 코드입니다.
import java.util.ArrayList; // ArrayList를 이용합니다.

public class DotCom
{
     private ArrayList<String> locationCells;
     // 배역 대신 string이 들어가는 ArrayList를 사용
     // private int numOfHits;
      // 없어도 됩니다.

     public void setLocationCells(ArrayList<String>loc)
     // 배역 대신 string이 들어가는 ArrayList를 사용
    {
         locationCells = loc;
     }
 
     public String checkYourself(String userInput)
     // 새로 바뀐 인자명 입니다.
    {
          String result = "miss";
  
          int index = locationCells.indexOf(userInput);
          // 사용자가 추측한 뒤 위치가 ArrayList에 들어있는지
          // 확인합니다. 들어있으면 인덱스 번호가, 그렇지 않으면
          // 리턴합니다.
  
          if(index >= 0)
          {
                locationCells.remove(userInput);
                // 인덱스가 0 이상이면 사용자가 추측한 
                // 위치가 목록에 들어있는 것이므로 
                // 제거합니다.
   
              if(locationCells.isEmpty())
              // 목록이 비어짔다면 그 닷컴이 죽었다는 것을 알수 있습니다.
             {
                   result = "Kill";
             }
             else
             {
                   result = "hit";
              }        //if문 끝
         }        // 바깥쪽 if문 끝
         return result;
    }        // 메소드 끝
}         // 클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{


/* DotCom 게임 최종 완성 코드입니다.DotCom, DotComBust, GameHelper 클래스들이있습니다. */

import java.io.*;
import java.util.*;

class GameHelper // GameHelper 클래스를 생성합니다.
{
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int [] grid = new int[gridSize];
	private int comCount = 0;
	public String getUserInput(String prompt) 
			throws IOException{
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader
					(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length()==0)   return null;

		}catch(IOException e) {
			System.out.println("OException: " + e);
		}
		return inputLine.toLowerCase();
	}

	public ArrayList<String>placeDotCom(int comSize)
	{
		ArrayList<String> alphaCells = new ArrayList<String>(); 
		// new String [comSize];

		String [] alphacoords = new String[comSize];
		// 'f6'과 같은 좌표가 들어갑니다.

		String temp = null;
		// 나중에 연결하기 위한 임시 String 배열을 생성합니다.

		int [] coords = new int[comSize];
		// 현재 후보 좌표입니다.

		int attempts = 0;
		// 시도 횟수를 세기위한 카운터입니다.

		boolean success = false;
		// 적당한 위치를 찾았는지 표시하기 위한 플래그입니다.

		int location = 0;
		// 현재 시작 위치를 0으로 설정합니다.

		comCount++;
		// n번째 닷컴입니다.

		int incr = 1;
		// 수직 방향으로 증가 시킬 값을 설정합니다.

		if ((comCount % 2) == 1) 
			// 홀수 번째 닷컴인 경우(수직으로 배치합니다.)  
		{
			incr = gridLength;
			// 수직 방향으로 증가시킬 값을 설정합니다.
		}
		while ( !success & attempts++ < 200) 
			// 주 검색 순환문(32)
		{
			location = (int) (Math.random() * gridSize);
			// 임의의 시작위치를 구함. 

			System.out.print("try" + location);
			int x = 0;
			//위치 시킬 닷컴의 n번째 위치.

			success = true;
			// 성공한다고 가정합니다.

			while (success && x < comSize) 
				// 닷컴이 들어갈자리가 비었는지 확인합니다.
			{
				if (grid[location] == 0) 

				{
					coords[x++] = location;
					// 위치 저장.

					location += incr;
					// 다음칸 확인.

					if (location >= gridSize)
						// 경계를 벗어난 경우.
					{
						success = false;
						// 실패.
					}
					if (x>0 & (location % gridLength == 0))
						// 경계를 벗어난 경우(오른쪽)     
					{
						success = false;
						// 실패.
					}
				} else {
					// 이미 사용 중인 경우
					System.out.print("used "+location);
					success = false;
					//실패.
				}
			}
		}  // while문 종료.

		int x = 0;
		// 위치를 알파벳 좌표로 바꿉니다.

		int row = 0;  
		int column = 0;
		System.out.println(" |n");
		while (x < comSize) 
		{
			grid[coords[x]] = 1;
			// 기본 그리드 좌표를 사용합니다.

			row = (int) (coords[x] / gridLength);
			// 행 값을 구합니다.

			column = coords[x] % gridLength;
			// 열 값(숫자)을 구합니다.

			temp = String.valueOf(alphabet.charAt(column));
			// 숫자로 된 열을 알파벳으로 변환합니다.

			alphaCells.add(temp.concat
					(Integer.toString(row))); 
			x++;
			System.out.print(" coord " + x + " = " + 
					alphaCells.get(x-1));
			// 닷컴의 위치를 알려주는 코드입니다.
		}
		System.out.println(" d2|n?");
		return alphaCells;
	}
}

class DotCom
{
	private ArrayList<String> locationCells;
	private String name;
	// DotCom의 인스턴스 변수
	// - 셀위치가 들어있는 ArrayList
	//  - DotCom의 이름
	public void setLocationCells(ArrayList<String> loc)
	{
		locationCells = loc;
	}
	// DotCom의 위치를 갱신하는 세터 메소드 
	// placeDotCom()메소드에서 제공하는 무작위로 만든  위치

	public void setname(String n) 
	{
		name = n;
	}
	// 기초적인 세터 메소드입니다.

	public String checkYourself(String userInput) 
	{
		String status = "miss";
		int index = locationCells.indexOf(userInput);
		/* ArrayList의 indexOf()메소드를 쓰고 있습니다. 사용자가 추측한 
		 위치가 ArrayList에 들어있으면 indexOf()에서 
		 그 항목의 인텟스를 리턴합니다.
		 그렇지 않으면 -1을 리턴합니다. */

		if(index >=0) 
		{
			locationCells.remove(index);
			// ArrayList의 remove메소드를  써서 그 항목을 지웁니다.

			if (locationCells.isEmpty())
				// isEmpty()메소드를 써서 모든 위치를 맞췄는지 확인합니다.
			{  
				status = "kill";
				System.out.println("Ouch! You sunk" +
						name + " : ( ");
				// 닷컴이 가라 앉았음을 알려줍니다.
			}else {
				status = "hit";
			}
		} // if문 종료.
		return status;
		// 'miss','hit'또는 'kill'을 리턴합니다.
	} // method 종료.
} // class 종료.

class DotComBust 
{
	// 사용할 변수를 선언하고 초기화 합니다.
	private GameHelper helper;
	private ArrayList<DotCom> dotComsList;
	private int numOfGuesses;
	/* DotCom객체로 이루어진  ArrayList를 만듭니다.
	(즉 DotCom[]이 DotCom객체들이 들어있는 배열을 뜻하는 것과
	 마찬가지로  ArrayList (DotCom)을 DotCom객체들이 들어
	있는 ArrayList라고 생각하면 됩니다.) */

	public DotComBust()
	{
		helper = new GameHelper();
		dotComsList = new ArrayList<DotCom>();
		numOfGuesses = 0;
	}

	private void setUpGame()
	// 우선 닷컴 객체 몇 개를 만들고 위치를 지정합니다.
	{
		DotCom one = new DotCom();
		one.setname("Pets.com");
		DotCom two = new DotCom();
		two.setname("eToys.com");
		DotCom three = new DotCom();
		three.setname("Go2.com");
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three);
		// DotCom 객체세개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다.

		System.out.println("Your goal is to sink three " +
				"dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in " +
				"the fewest number of guesses");
		// 사용자에게 간단한 게임 방법을 설명합니다.  

		for (DotCom dotComToset : dotComsList) 
			// 목록에 있는 각 DotCom에 대해 반복합니다.   
		{
			ArrayList<String> newLocation 
			= helper.placeDotCom(3);
			// DotCom의 위치를 지정하기 위한 보조 메소드를 호출합니다.

			dotComToset.setLocationCells(newLocation);
			// 이 DotCom 객체의 세터메소드를 호출하여 방금 보조 메소드에서  받아온 위치를 지정합니다.

		} // for문 종료.
	} // setUpgame method 종료.

	private void startPlaying() throws IOException
	{
		while (!dotComsList.isEmpty())
			// DotCom목록이 비어있지 않으면 (1은 부정(NOT)을 의미 합니다. dotComList.isEmpty() == false와 똑같습니다.)
		{
			String userGuess 
			= helper.getUserInput("Enter a guess");
			// 사용자 입력을 받습니다

			checkUserGuess(userGuess);
			// checkUserGuess 메소드를 호출합니다.
		} // while문 종료.
		finishGame();
		// finishGame() 메소드를 호출합니다.
	} // startPlaying method 종료.

	private void checkUserGuess(String userGuess) 
	{
		numOfGuesses++;
		// 사용자가 추측한 횟수를 증가시킵니다.

		String result = "miss";
		// 따로 바꾸지 않으면'miss'라고 가정합니다.

		for (DotCom dotComToTest : dotComsList)
			// 목록에 들어있는모든 DotCom객체에 대해 반복합니다.
		{
			result = dotComToTest.checkYourself(userGuess);
			// DotCom 객체에 사용자가 입력한 위치가 맞는지 또는  그 객체가 죽었는지 물어봅니다.

			if (result.equals("hit"))
			{
				break;
				// 순환문에서 일찍빠져나옵니다. 더 이상 확인하지 않아도 됩니다.
			}
			if (result.equals("kill"))
			{
				dotComsList.remove(dotComToTest);
				// 이것은 죽었으니 DotCom 목록에서 빼고 
				// 순환문을 빠져나갑니다.
				break;
			}
		} // for문 종료.
		System.out.println(result);
		// 결과를 출력합니다.

	} // 메소드 종료.

	private void finishGame()
	{
		System.out.println("All Dots are dead! Your " +
				"stock is now worthless");
		if (numOfGuesses<=18)
		{
			System.out.println("It only took you" + 
					numOfGuesses + "Guesses.");
			System.out.println("You got out before your  " +
					"  options sank");
		}else {
			System.out.println("Took you long enough. " +
					numOfGuesses + "guess.");
			System.out.println("Fish are dancing with " +
					" your options");
		}
		// 게임결과를 알려주는 메시지를 출력합니다.
	}  // method 종료.

	public static void main(String[] args)throws IOException
	{
		DotComBust game = new DotComBust();
		// 게임 객체를 만듭니다.

		game.setUpGame();
		// 게임 객체에게 게임을 설정하라는 명령을 내립니다.

		game.startPlaying();
		// 게임 객체에서 주 게임 진행 순환문을 돌리라는 명령을 내립니다.
		// (사용자에게 계속 위치를 물어보고, 그위치를 확인합니다.)
	}  // method 종료.
} // 클래스 종료.



}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 
 상위클래스로부터 인스턴스 변수와 메소드를 하위클래스에게 넘겨주는 것을 상속이라한다. 이때, 공통적인 코드를 어떤 클래스에 넣은 다음 다른 더 구체적인 클래스에 공통적인 클래스가 상위클래스라는 것을 알려주면 된다.

 * 다형성: 
 여러가지 형태를 하나의 그릇으로 나타낼 수 있다. 즉, 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다. 이때 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가 하더라도 코드를 굳이 바꿀 필요가 없게 된다. 

*208p 클래스 계층 구조* _클래스로 구현_

{{{
// Animal 클래스의 계층 구조입니다.
// Animal이 상위 클래스입니다.
class Animal {
	String picture;
	boolean food;
	int hunger;
	float boundaries;
	float location;

	void makeNoise(){
		// 소리를 낼 때의 행동입니다.
	}
	void eat(boolean food){
		// 동물이 음식을 접했을 때의 행동입니다.
	}
	void sleep(){
		// 동물이 잠들어 있을 때 행동입니다.
	}
	void roam(){
		// 동물이 먹거나 자고 있지 않을 떄의 행동
	}
}

// Feline은 Animal을 상속받습니다.
class Feline extends Animal{
	void roam(){ // roam을 오버라이드합니다.
	}
}

// Lion은 Feline을 상속받습니다.
class Lion extends Feline{
	void makeNoise(){
		// makeNoise를 오버라이드합니다.
	}
	void eat(boolean food){
		// eat을 오버라이드합니다.
	}
}

// Tiger는 Feline을 확장합니다.
class Tiger extends Feline{
	void makeNoise(){
		// makeNoise를 오버라이드합니다.
	}
	void eat(boolean food){
		// eat을 오버라이드합니다.
	}
}

// Cat은 Feline을 확장합니다.
class Cat extends Feline{
	void makeNoise(){
		// makeNoise를 오버라이드합니다.
	}
	void eat(boolean food){
		// eat을 오버라이드합니다.
	}
}

// Hippo는 Animal을 확장합니다.
class Hippo extends Animal{
	void makeNoise(){
		// 오버라이드합니다.
	}
	void eat(boolean food){
		// 오버라이드합니다.
	}
}

// Canine은 Animal을 확장합니다.
class Canine extends Animal{
	void roam(){
		// 오버라이드합니다.
	}
}

// Wolf는 Canine을 확장합니다.
class Wolf extends Canine{
	void makeNoise(){
		// 오버라이드합니다.
	}
	void eat(boolean food){
		// 오버라이드합니다.
	}
}

// Dog는 Canine을 확장합니다.
class Dog extends Canine{
	void makeNoise(){
		//오버라이드합니다.
	}
	void eat(boolean food){
		// 오버라이드합니다.
	}
}


}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 오버라이드는 부모 메소드를 자식 메소드에서 재정의 하는 것입니다.
 * 오버로딩:
 오버로딩이란 하나의 클래스 내에 인수의 개수나 형식이 다른 동일한 이름의 메소드를 여러개 정의하는 것입니다. 즉, 해당 메소드가 이름이 같더라도 안에있는 인수만 다르다면 얼마든지 만들수있다는 뜻입니다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
// 1번 코드가 제대로 작동합니다.
public class MonsterTestDrive {
        public static void main(String [] args) { 
                Monster [] ma = new Monster[3]; // Vampire,Dragon,Monster를 생성합니다.
                ma[0] = new Vampire();
                ma[1] = new Dragon();
                ma[2] = new Monster();
                for(int x = 0; x<3; x++) { // 입력값 0,1,2을 넣어줍니다.
                        ma[x].frighten(x);
                }
        }
}

class Monster {
                boolean frighten(int d) { //int 를 받아 bool로 출력합니다.
                        System.out.println("arrrgh");
                        return true;
                }
}

class Vampire extends Monster { //Monster를 상속받습니다.
                boolean frighten(int x) {  //int 를 받아 bool로 출력합니다.
                        System.out.println("a bite?");
                        return false;
                }
        }

class Dragon extends Monster{
        boolean frighten(int degree) {
                System.out.println("breath fire");
                return true;
        }
}

결과값 : 
a bite?
breath fire
arrrgh
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 상수와 추상 메소드의 집합체이다. 주로 다른 클래스간의 공통적인 기능을 정의할 때 사용하며 인터페이스 내부에 공통기능을 선언한 후, 인터페이스를 상속받는 클래스에서 선언된 메소드를 구현한다. 인터페이스의 특징으로는 아래와 같이 있다.

- 클래스를 사용하려는 쪽(User)과 클래스를 제공하려는 쪽(Provider)이 있을 때, User는 Provider의 메서드 선언부만 알면 된다.
 
- Java에서 지원하지 않는 다중상속을 인터페이스를 활용해 비슷하게 구현하는 것이 가능하다.

- 개발시간을 단축시킬 수 있다.(참조하는 쪽에서 직접 클래스를 작성하게 함으로써 동시 개발 가능)

- 표준화가 가능하다.(기본 틀을 인터페이스로 작성하고 )

- 인터페이스의 멤버변수는 상수이다.

- 인터페이스의 메소드는 추상메소드이다.

- 객체를 생성할 수 없다.

- super키워드를 사용할 수 없다.

- 내부에 구현된 것이 없이, 틀만 존재한다.

- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.

- 독립적인 프로그래밍이 가능하다.
 * 다형성:
 여러가지 형태를 하나의 그릇으로 나타낼 수 있다. 즉, 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다. 이때 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가 하더라도 코드를 굳이 바꿀 필요가 없게 된다. 
 * 추상 클래스: 
 인스턴스를 만들면 안 되는 클래스이며 클래스를 abstract로 지정하면 추상 클래스를 만들 수 있습니다. 또한, 추상 메소드를 만들 때는 클래스도 반드시 추상 클래스로 만들어야하며 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없습니다.  
 * 추상 메소드:
 추상 메소드는 메소드를 abstract로 지정한 것으로, 추상 메소드에는 몸통이 없습니다. 추상 메소드를 만드는 이유는 실제 메소드 코드를 전혀 집어넣지 않아도 일련의 하위클래스를 위한 프로토콜의 일부를 정의하기 위한 것입니다.
 * 다중 상속:
 다중 상속이란 단일 상속과는 달리 하나의 부모 클래스에서 상속받는 것이 아닌 둘 이상의 여러 부모 클래스에서 상속받는 것을 말합니다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 
 힙이란 모든 객체가 사는 곳으로 객체 자체는 힙에 들어있습니다. 즉 레퍼런스가 지역 변수든 인스턴스 변수든 상관없이 모든 객체는 힙에 저장됩니다. 인스턴스 변수는 힙에, 그 변수가 속하는 객체 안에서 산다. 
 * 스택에서의 변수:
 스택은 매소드 호출과 지역 변수가 사는 곳으로 메소드 안에서 선언한 지역 변수가 스택에 저장됩니다. 메소드를 호출하면 스택에 차례대로 쌓입니다. 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스)만 스택에 들어갑니다.
 * 생성자:
 생성자는 메소드와 거의 똑같지만 메소드가 아닙니다. 생성자에는 객체를 생성할때 실행되는 코드가 들어있습니다. 즉, 어떤 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있습니다. 생성자를 호출할 때는 반드시 new라는 키워드를 쓰고 뒤에 클래스 명을 적으며, 생성자의 가장 중요한 특징은 객체가 레퍼런스에 대입되기 전에 실행된다는 점입니다.
 * 널 레퍼런스:
 널 레퍼런스는 레퍼런스 변수에 Null 값을 대입함으로써 아무것도 가리키지 않은 레퍼런스를 널 레퍼런스라고 합니다. 자바에서는 널 레퍼런스에서 점 연산자를 사용할 수 없습니다. 만약 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException이 생깁니다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
- 객체를 지원하는 역할

- 상태는 인스턴스 변수에 저장된 값이다.

- 지역변수는 임시 변수로 불린다.

- 객체와 함게 힙에서 산다. 즉, 객체 안에서 산다.

- 객체의 상태를 저장한다.

- 자신이 속한 객체가 가비지 컬렉터에 의해 처리되면 인스턴스 변수도 함께 삭제된다.

 * 지역 변수: 
- 메소드 안의 알고리즘을 작동시키려면 메소드에 반드시 지역 변수가 있어야합니다.

- 지역변수는 임시 변수로 불린다.

- 지역, 스택, 자동, 영역 제한

- 다른 여러 지역 변수와 함께 스택 프레임에 들어가 있어야한다.

- 자신의 프레임이 스택 맨 위로 올라갈 때 까지 하는 것이 없다.

- 프레임이 사라지지 않는 이상 자신이 저장하고 있는 값도 유지된다.

- 객체를 참조하는 유일한 레퍼런스가 지역 변수에서만있으면 지역 변수가 사라질 때 그 인스턴스 변수도 같이 사라진다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

/* 모듈의 온도를 유지하기 위한 시뮬레이션 코드입니다. */
import java.util.*;
class V2Radiator {
	V2Radiator(ArrayList<SimUnit> list)	{ // ArrayList를 넘겨줍니다.
		for(int x = 5; x < 5 ; x++){
			list.add(new SimUnit("V2Radiator")); // "V2Radiator" 객체를 추가합니다.
		}
	}
}

// 불필요하게 V3를 호출할 때마다 V2생성자를 호출할 때 ArrayList를 전달하는 것을 막기위해 상속을 안합니다.
class V3Radiator {
	V3Radiator(ArrayList<SimUnit> lglist){
		//super(lglist)를 빼줍니다.
		for(int g = 0; g < 10 ; g++){
			lglist.add(new SimUnit("V3Radiator"));//"V3Radiator" 객체를 추가합니다.
		}
	}
}

class RetentionBot{
	RetentionBot(ArrayList<SimUnit> rlist){
		rlist.add(new SimUnit("Rention")); // "Rention" 객체를 추가합니다.
	}
}

public class TestLifeSupportSim{
	public static void main(String[] args){
		ArrayList<SimUnit> aList = new ArrayList<SimUnit>(); // ArrayList를 생성합니다.
		V2Radiator v2 = new V2Radiator(aList);// V2Radiator 객체를  생성합니다.
		V3Radiator v3 = new V3Radiator(aList);// V3Radiator 객체를  생성합니다.
		for(int z = 0 ; z < 20 ; z++){
			RetentionBot ret = new RetentionBot(aList); //RententionBot객체를 생성합니다.
		}
	}
}

class SimUnit {
	String botType;
	SimUnit(String type){
		botType = type;
	}
	int powerUse(){
		if("Retention".equals(botType)){
			return 2;                       
		}else{
			return 4;
		}
	}
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 static이라는 키워드를 사용하여 클래스의 인스턴스 없이 메소드를 실행할 수 있도록 한 것입니다.

 즉, 정적(static)메소드는 인스턴스 변수에 따라 행동이 달라지지 낳기 때문에 인스턴스나 객체가 필요하지 않고 클래스만 있어도 되는 메소드입니다.

 * 정적 메소드를 선언하는 방법:

 정적 메소드를 선언하는 방법은 메소드에 static을 붙이는 것입니다.

 * static final:

1. static final로 선언된 변수는 상수입니다.

2. 변수를 상수로 지정하는 유일한 방법입니다.

3. 이때, 상수의 변수명은 모두 대문자로 씁니다.

 * 널 레퍼런스:

널 레퍼런스는 레퍼런스 변수에 Null 값을 대입함으로써 아무것도 가리키지 않은 레퍼런스를 널 레퍼런스라고 합니다. 자바에서는 널 레퍼런스에서 점 연산자를 사용할 수 없습니다. 만약 널 레퍼런스에 대해 점 연산자를 사용하면 실행 중에 NullPointerException이 생깁니다.
 

 * 오토 박싱:

모든 기본형에는 포장 클래스가 존재합니다. 기존에는 기본형에 상응되는 포장 클래스 타입간의 자료 변환 작업이 불필요할 정도로 많은 코드를 요구했습니다.  하지만 자바 5.0에서는 int와 integer간의 변환 작업을 컴파일러가 맡아서 처리하므로 불편함이 줄었습니다. 이런 변환 작업을 자동으로 제공하는 것을 *"오토 박싱"*이라 합니다.


 * 정적 임포트:

자바 5.0에서 추가된 기능으로 타이핑을 전부 할 필요 없이 정적 임포트(static import)를 사용하면 짧게 코드를 작성할 수 있습니다.
주의할 점은 정적 임포트 기능을 잘못 사용하면 코드의 가독성이 크게 떨어 질 수 있다는 것입니다.

*339p Calendar* _구현후 주석달기_

{{{
/* 설정된 날로부터 몇 시간,  특정 날짜가 지났는지 출력하는 프로그램입니다. */
import java.util.*;

public class DDA {
	public static void main(String args[]){
		Calendar c=Calendar.getInstance();
		c.set(2012, 0, 7, 15, 40); // 시작을 2012년 1월 7일 15:40으로 설정

		long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴합니다.
		day1 += 1000*60*60;

		c.setTimeInMillis(day1); // 한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
		System.out.println("new hour"+c.get(Calendar.HOUR_OF_DAY));
		c.add(Calendar.DATE, 35); // 35일을 더합니다.
		System.out.println("add 35 days"+c.getTime());
		c.roll(Calendar.DATE, 35); // 35일 뒤로 넘깁니다. 달은 바뀌지 않습니다.
		System.out.println("roll 35 days"+c.getTime());
		c.set(Calendar.DATE,1); // 날짜를 1로 설정합니다.
		System.out.println("set to 1"+c.getTime());
	}

}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:

- 정적 변수는 상수에 불과하다. 

- 정적 변수는 객체지향적이지 않다, 전역 변수랑 비슷하다.

- 정적 메소드는 프로그래머가 고유한 객체의 상태를 바탕으로 해서 객체가 어떤 식으로 일을 처리하는 지를 생각할 때 쓰는게 아니고 프로시저 위주로 생각할 때 쓴다.

 * 지역 변수: 

- API에 정적 변수가 많다.

- 상수만 들어있는 클래스도 있다.

- SwingConstants같은 클래스에는 상수만 잔뜩 들어있다.

- Color 클래스에는 파란, 보라, 하양, 빨간색 같은 색을 상수로 지정했다.

- System.out의 out은 System클래스의 정적 변수다.

- 정적 변수는 클래스마다 하나씩 있다.

- 정적 변수는 클래스 안에서 살고 있다, 객체지향적이다, 한 클래스에 속하는 모든 인스턴스에 의해 공유된다, 시스템에 필수적인 것이 있다.

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class StaticSuper{ 
	static{
		System.out.println("super static block");
	}
	StaticSuper(){ // StaticSuper은 생성자이므로 반드시()가 있어야 합니다.
		System.out.println("super constructor");
	}
}

public class StaticTests extends StaticSuper { // StaticTests는 StaticSuper를 상속받습니다.
	static int rand;
	static{
		rand=(int)(Math.random()*6);
		System.out.println("static block"+rand);
	}
	StaticTests(){
		System.out.println("constructor");
	}
	public static void main(String[]args){
		System.out.println("in main");
	}
	StaticTests st=new StaticTests(); // st를 읽기위해 메인 메소드 밖으로 뺍니다.
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

/*try-catch를 구현한 비트박스를 구성하는 코드입니다.*/

import javax.sound.midi.*;

public class Test { // test 클래스를 생성합니다.
	public void play(){ // play 메소드입니다.
		try{ 
			@SuppressWarnings("unused") // unused를 사용할 수 있도록 컴파일러에게 명령합니다.
			Sequencer sequencer = MidiSystem.getSequencer(); 
			System.out.println("Successfully got a sequencer");
			//getSequencer 메소드를 호출할 때 예외가 발생하지 않으면  메시지를 출력합니다.
		} catch(MidiUnavailableException ex){ 
			System.out.println("Bummer");
			//예외 발생시 메시지가 출력됩니다. 
		}
	}
	public static void main(String[] args){
		Test mu = new Test();  
		mu.play();
	}
}


}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

/* 첫번째 사운드 애플리케이션을 구현한 코드입니다. */
import javax.sound.midi.*; // 미디 패키지를 불러옵니다.

public class MiniMiniMusicApp {

	public static void main(String [] args){
		MiniMiniMusicApp mini = new MiniMiniMusicApp();
		mini.play();
	} // main 메소드 끝
	public void play(){
		try{
			Sequencer player = MidiSystem.getSequencer(); //시퀀서를 받아서 엽니다.
			player.open();

			Sequence seq = new Sequence(Sequence.PPQ, 4); // 시퀀서 생성자로 넘기는 인자.
			Track track = seq.createTrack(); // 시퀀스에 트랙을 요청합니다.

			// 트랙에 미디이벤트를 집어넣습니다. 이 부분은 거의 인스턴트 코드입니다.
			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,44,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);

			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,44,100);
			MidiEvent noteOff = new MidiEvent(b,16);
			track.add(noteOff);

			// 시퀀서에 시퀀스를 보냅니다.
			player.setSequence(seq);

			player.start();

		} catch (Exception ex){
			ex.printStackTrace();
		}

	} // play 메소드 끝
} // 클래스 끝

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

/*  두번째 사운드 어플리케이션 구현 코드입니다. */

import javax.sound.midi.*;

public class MiniMusicCmdLine { // 첫번째

	public static void main(String[]args){
		MiniMusicCmdLine mini = new MiniMusicCmdLine();
		if(args.length<2){
			System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
		}else{
			int instrument = Integer.parseInt(args[0]);
			int note = Integer.parseInt(args[1]);
			mini.play(instrument, note);
		}
	} // main 끝

	// 위 첫번째 애플리케이션 구현 코드와 비슷합니다. 
	public void play (int instrument, int note){
		try{
			Sequencer player = MidiSystem.getSequencer();
			player.open();
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack();

			MidiEvent event = null;

			ShortMessage first = new ShortMessage();
			first.setMessage(192,1,instrument,0);
			MidiEvent changeInstrument = new MidiEvent(first, 1);
			track.add(changeInstrument);

			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,note,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);

			ShortMessage b = new ShortMessage();
			a.setMessage(128,1,note,100);
			MidiEvent noteOff = new MidiEvent(b,16);
			track.add(noteOff);
			player.setSequence(seq);
			player.start();
		}catch(Exception ex){ex.printStackTrace();}
	} // play 메소드 끝
} // 클래스 끝


}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
/* 첫번째 버튼 구현 */
import javax.swing.*;

public class SimpleGui1B{
	public static void main(String []args){
		JFrame frame = new JFrame(); // J프레임을 생성합니다.
		JButton button = new JButton("click me");  // J버튼을 생성합니다.

		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 이것을 하면 창을 닫았을 때 프로그램이 종료됩니다.

		frame.getContentPane().add(button); // 내용 틀에 버튼을 추가합니다.

		frame.setSize(300,300); // 프레임의 크기를 픽셀단위로 지정합니다.

		frame.setVisible(true); // 화면에 표시되도록 설정합니다.
	}
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
/* 버튼에 액션 리스너와 액션 이벤트를 구현합니다 */
import javax.swing.*;
import java.awt.event.*; // Actionlistener와 이벤트가 들어있는 패키지를 사용

public class SimpleGui1B implements ActionListener {
	JButton button; // 버튼을 생성합니다. 

	public static void main(String []args){
		SimpleGui1B gui=new SimpleGui1B();
		gui.go();

	}

	public void go(){
		JFrame frame= new JFrame();
		button=new JButton("cliick me"); // 버튼에 click me 라는 내용을 입력합니다.

		button.addActionListener(this); // 버튼에 action리스너를 등록합니다.

		frame.getContentPane().add(button);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	public void actionPerformed(ActionEvent event){ // 버튼이 클릭됐을 때 실행되는 이벤트입니다.
		button.setText("I've been clicked!");
	}
}
}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{
/* 버튼 클릭시 원의 색이 바뀌는 자바 프로그램입니다. */
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener{
	JFrame frame; // 프레임을 생성합니다.

	public static void main(String [] args){
		SimpleGui3C gui=new SimpleGui3C();
		gui.go();
	}

	public void go() {
		frame=new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		JButton button = new JButton("Change colors"); // change color라는 안내 문구가 있는 버튼을 생성합니다.
		button.addActionListener(this); // 액션 리스너를 설정합니다.

		MyDrawPanel drawPanel = new MyDrawPanel(); // drawPanel 객체를 생성합니다.

		frame.getContentPane().add(BorderLayout.SOUTH,button); // 버튼을 프레임에 추가합니다.
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel); // 그림 패널을 프레임에 추가합니다.
		frame.setSize(300,300);
		frame.setVisible(true);
	}
	public void actionPerformed(ActionEvent event){
		frame.repaint(); // 사용자가 버튼을 클릭하면 repaint메소드를 호출합니다. 그 프레임에 들어있는 모든 위젯의 paintComponent가 호출됩니다.
	}
}
// 그래디언트의 시작과 끝 색을 무작위로 지정합니다.
class MyDrawPanel extends JPanel{
	public void paintComponent(Graphics g){
		Graphics2D g2d = (Graphics2D) g;

		int red = (int)(Math.random()*256); 
		int green = (int)(Math.random()*256);
		int blue = (int)(Math.random()*256);
		Color startColor = new Color(red,green,blue);

		red = (int)(Math.random()*256);
		green = (int)(Math.random()*256);
		blue = (int)(Math.random()*256);
		Color endColor = new Color(red,green,blue);

		GradientPaint gradient = new GradientPaint(70,70,startColor,150,150,endColor);
		g2d.setPaint(gradient);
		g2d.fillOval(70,70,100,100);
	}
}
}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

/* 버튼 두 개를 처리하는 코드입니다. */
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButtons {

	JFrame frame; 
	JLabel label; 

	public static void main(String args[]){
		TwoButtons gui = new TwoButtons();
		gui.go();
	}

	public void go(){
		frame=new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);


		JButton labelButton = new JButton ("Change Label");
		// 버튼의 리스너 등록 메소드에 내부 클래스를 갖고 만든 객체를 전달 합니다.
		labelButton.addActionListener(new LabelListener());

		JButton colorButton = new JButton ("Change Circle");
		// 버튼의 리스너 등록 메소드에 내부 클래스를 갖고 만든 객체를 전달 합니다.
		colorButton.addActionListener(new ColorListener());

		label = new JLabel("I'm a lebel");
		MyDrawPanel drawPanel = new MyDrawPanel();

		// 프레임에서 각 버튼과 판넬의 위치를 설정합니다.
		frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.getContentPane().add(BorderLayout.EAST, labelButton);
		frame.getContentPane().add(BorderLayout.WEST, label);

		frame.setSize(300,300);
		frame.setVisible(true);
	}

	class LabelListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			label.setText("Ouch!"); // 내부 클래스에서도 label 변수를 사용할 수 있습니다.
		}
	} // 내부 클래스 끝

	class ColorListener implements ActionListener{
		public void actionPerformed(ActionEvent event){
			frame.repaint(); // 내부 클래스에서 외부 클래스 객체에 대한 레퍼런스 없이 그냥 frame 인스턴스 변수를 사용합니다.
		}
	} // 내부 클래스 끝
}

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

/* 간단한 애니메이션 코드입니다. 원이 움직입니다. */
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation{

	// 원의 x와 y좌표를 저장하기 위한 인스턴스 변수입니다.
	int x=70;
	int y=70;

	public static void main(String args[]){
		SimpleAnimation gui = new SimpleAnimation();
		gui.go();
	}

	public void go(){

		JFrame frame=new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// 위젯을 만들고, 프레임에 집어 넣습니다.
		MyDrawPanel drawPanel = new MyDrawPanel();

		frame.getContentPane().add(drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);

		// 애니메이션을 수행하는 부분입니다. 300번 반복합니다.
		for(int i=0;i<300;i++){
			//x와 y 좌표를 증가시킵니다.
			x++;
			y++;

			drawPanel.repaint(); // 스스로 다시 칠하도록 패널에게 말합니다.
			try{
				Thread.sleep(50); //속도를 약간 줄입니다.
			}catch(Exception ex){}
		}
	} // go()메소드 끝

	@SuppressWarnings("serial") // 컴파일러에 명령하여 오류를 수정했습니다.
	// 내부클래스입니다.
	class MyDrawPanel extends JPanel{
		public void paintComponent(Graphics g){
			g.setColor(Color.white);
			// 지나온 흔적을 배경색으로 칠합니다.
			g.fillRect(0,0,this.getWidth(),this.getHeight());

			g.setColor(Color.green);
			//지속적으로 갱신되는 외부클래스의 x, y 좌표를 사용합니다.
			g.fillOval(x, y, 40, 40); 
		}
	} // 내부 클래스 끝
} // 외부 클래스 끝

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

/* 뮤직 비디오를 구현하는 코드입니다. 음악과 함께 도형이 그려집니다. */
import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {

	static JFrame f = new JFrame("My First Music Video");
	static MyDrawPanel m1;

	public static void main(String [] args){
		MiniMusicPlayer3 mini = new MiniMusicPlayer3();
		mini.go();
	}// 메소드 끝

	// GUI를 세팅합니다.
	public void setUpGui(){
		m1 = new MyDrawPanel();
		f.setContentPane(m1);
		f.setBounds(30, 30, 300, 300);
		f.setVisible(true);
	}// 메소드 끝

	public void go(){
		setUpGui();

		// 음악을 재생하기 위한 코드입니다.
		try{
			Sequencer sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequencer.addControllerEventListener(m1, new int[] {127});
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack();

			int r = 0; 
			for(int i = 0; i<60 ; i+=4){

				r=(int)((Math.random()*50)+1);
				track.add(makeEvent(144,1,r,100,i));
				track.add(makeEvent(176,1,127,0,i));
				track.add(makeEvent(128,1,r,100,i+2));
			}// 순환문 끝

			sequencer.setSequence(seq);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		} catch(Exception ex) {ex.printStackTrace();}
	}// 메소드 끝

	// Midi 이벤트 부분입니다.
	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
		MidiEvent event = null;
		try{
			ShortMessage a = new ShortMessage();
			a. setMessage(comd,chan,one,two);
			event = new MidiEvent(a, tick);
		}catch(Exception e){}
		return event;

	}// 메소드 끝


	class MyDrawPanel extends JPanel implements ControllerEventListener{
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		boolean msg=false;
		@SuppressWarnings("unused")
		private Graphics2D g2;

		public void controlChange(ShortMessage evet){
			msg= true; // 이벤트를 받았으므로 플래그를 true로 설정합니다.
			repaint(); // repaint를 호출합니다.
		}

		public void paintComponent(Graphics g){
			if(msg){ // ControllerEvent가 발생한 경우에만 그림을 다시 그려야하므로 플래그를 씁니다.

				g2 = (Graphics2D)g;

				// 무작위적으로 색을 생성한후 무작위적으로 직사각형을 그리기 위한 코드입니다.
				int r = (int) (Math.random()*250);
				int gr=(int) (Math.random()*250);
				int b= (int ) (Math.random()*250);

				g.setColor(new Color(r,gr,b));

				int ht=(int) ((Math.random()*120)+10);
				int width=(int) ((Math.random()*120)+10);

				int x=(int) ((Math.random()*40)+10);
				int y=(int) ((Math.random()*40)+10);

				g.fillRect(x, y, ht, width);
				msg = false;
			}//if문 끝
		}// 메소드 끝
	}// 내부 클래스 끝
}//클래스 끝

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

/* 비트박스 코드입니다. */
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {


	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;

	// GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
	String[]instrumentNames = {"Bass Drum","Closed Hi-Hat",
			"Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap",
			"High Tom","Hi Bongo","Maracas","Whistle","Low Conga",
			"Cowbell","Vibraslap","Low-mid Tom","High Agogo",
	"Open Hi Conga"};
	// 실제 드럼 '건반'을 나타냅니다. 드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다.
	// 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다.
	int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};

	public static void main(String [] args){
		new BeatBox().buildGUI();
	}

	public void buildGUI(){
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		// 비어있는 경계선(empty border)을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에
		// 빈 공간을 만듭니다.
		background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);

		// 버튼들을 추가하고 actionlistener를 부착합니다.
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);

		JButton stop = new JButton("Stop");
		stop.addActionListener (new MyStopListener());
		buttonBox.add(stop);

		JButton upTempo = new JButton("upTempo");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo, "upTempo");

		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo, "downTempo");

		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for(int i=0; i<16; i++){
			nameBox.add(new Label(instrumentNames[i]));
		}

		// 버튼박스, 이름박스의 위치를 정합니다.
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);

		theFrame.getContentPane().add(background);

		GridLayout grid = new GridLayout(16,16); //그리드레이아웃을 생성합니다.
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER,mainPanel);

		for(int i=0;i<256;i++)
		{
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		}//순환문 끝

		setUpMidi();

		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);      

	}// buildGUI 메소드 끝

	// 시퀀서, 시퀀스, 트랙을 만들기 위한 이랍ㄴ적인 미디 관련 코드입니다.
	public void setUpMidi(){
		try{
			sequencer= MidiSystem. getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){e.printStackTrace();}
	}//setUpMidi 메소드 끝

	// 체크상자의 상태를 MIDI이벤트로 바꾼 후 이벤트를 트랙에 추가합니다.
	public void buildTrackAndStart(){
		int [] trackList = null; // 각 악기의 열여섯 박자에 대한 값을 원소가 16개인
		// 배열에 저장합니다. 어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를
		// 넣습니다. 반대로 연주되어야 하지 않는다면 0을 집어넣습니다.

		// 기존 트랙을 제거하고 트랙을 새로 만듭니다.
		sequence.deleteTrack(track);
		track = sequence.createTrack();

		//열 16개 모두에 대해 같은 작업을 처리합니다.
		for(int i = 0; i< 16; i++){
			trackList = new int[16];

			int key = instruments[i]; // 어떤 악기인지 정하는 번호를 설정합니다.


			for(int j = 0; j<16 ; j ++) // 모든 박자에 대해 같은 작업을 반복합니다.
			{
				JCheckBox jc = checkboxList.get(j + (16*i));
				if(jc.isSelected()){
					trackList[j] = key;
				}else{
					trackList[j] = 0;
				}
			}//안쪽 for문 끝

			makeTracks(trackList);
			track.add(makeEvent(176,1,127,0,16));
		}// 바깥쪽 for문 끝

		track.add(makeEvent(192,9,1,0,15));
		try{
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){e.printStackTrace();}
	} // buildTrackAndStart 메소드 끝

	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			buildTrackAndStart();
		}
	} // 내부 클래스 끝

	public class MyStopListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			sequencer.stop();
		}
	}// 내부 클래스 끝

	public class MyUpTempoListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * 1.03));
		}
	}// 내부 클래스 끝
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor* .97));
		}
	}// 내부 클래스 끝

	// 한 악기의 16박자 전체에 대해 이벤트를 생성. int배열에는 악기에 해당하는
	// 건반 번호 또는 0이 들어갑니다. 0이 들어있다면 그 박자에서는 해당 악기가
	// 연주되지 않아야 합니다. 0이 아닌 값이 들어있다면 이벤트를 만들어서
	// 트랙에 추가합니다.
	public void makeTracks(int [] list){
		for(int i=0;i<16;i++){
			int key = list[i];

			if(key!=0){

				// Note on과 note off 이벤트를 만들고 트랙에 추가합니다. 		
				track.add(makeEvent(144,9,key,100,i));
				track.add(makeEvent(128,9,key,100,i+1));
			}
		}
	}

	public MidiEvent makeEvent(int comd, int chan , int one, int two, int tick){
		MidiEvent event = null;
		try{
			ShortMessage a = new ShortMessage();
			a.setMessage(comd,chan,one,two);
			event = new MidiEvent ( a, tick);

		}catch(Exception e){e.printStackTrace();}
		return event;

	}
}//클래스 끝

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

/* 비트박스 코드입니다. */
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import javax.swing.JCheckBox;

public class BeatBox {


	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
	Sequencer sequencer;
	Sequence sequence;
	Track track;
	JFrame theFrame;

	// GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
	String[]instrumentNames = {"Bass Drum","Closed Hi-Hat",
			"Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap",
			"High Tom","Hi Bongo","Maracas","Whistle","Low Conga",
			"Cowbell","Vibraslap","Low-mid Tom","High Agogo",
	"Open Hi Conga"};
	// 실제 드럼 '건반'을 나타냅니다. 드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다.
	// 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다.
	int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};

	public static void main(String [] args){
		new BeatBox().buildGUI();
	}

	public void buildGUI(){
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		// 비어있는 경계선(empty border)을 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에
		// 빈 공간을 만듭니다.
		background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);

		// 버튼들을 추가하고 actionlistener를 부착합니다.
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);

		JButton stop = new JButton("Stop");
		stop.addActionListener (new MyStopListener());
		buttonBox.add(stop);

		JButton upTempo = new JButton("upTempo");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo, "upTempo");

		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo, "downTempo");

		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for(int i=0; i<16; i++){
			nameBox.add(new Label(instrumentNames[i]));
		}

		// 버튼박스, 이름박스의 위치를 정합니다.
		background.add(BorderLayout.EAST, buttonBox);
		background.add(BorderLayout.WEST, nameBox);

		theFrame.getContentPane().add(background);

		GridLayout grid = new GridLayout(16,16); //그리드레이아웃을 생성합니다.
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER,mainPanel);

		for(int i=0;i<256;i++)
		{
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		}//순환문 끝

		setUpMidi();

		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);      

	}// buildGUI 메소드 끝

	// 시퀀서, 시퀀스, 트랙을 만들기 위한 이랍ㄴ적인 미디 관련 코드입니다.
	public void setUpMidi(){
		try{
			sequencer= MidiSystem. getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){e.printStackTrace();}
	}//setUpMidi 메소드 끝

	// 체크상자의 상태를 MIDI이벤트로 바꾼 후 이벤트를 트랙에 추가합니다.
	public void buildTrackAndStart(){
		int [] trackList = null; // 각 악기의 열여섯 박자에 대한 값을 원소가 16개인
		// 배열에 저장합니다. 어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를
		// 넣습니다. 반대로 연주되어야 하지 않는다면 0을 집어넣습니다.

		// 기존 트랙을 제거하고 트랙을 새로 만듭니다.
		sequence.deleteTrack(track);
		track = sequence.createTrack();

		//열 16개 모두에 대해 같은 작업을 처리합니다.
		for(int i = 0; i< 16; i++){
			trackList = new int[16];

			int key = instruments[i]; // 어떤 악기인지 정하는 번호를 설정합니다.


			for(int j = 0; j<16 ; j ++) // 모든 박자에 대해 같은 작업을 반복합니다.
			{
				JCheckBox jc = checkboxList.get(j + (16*i));
				if(jc.isSelected()){
					trackList[j] = key;
				}else{
					trackList[j] = 0;
				}
			}//안쪽 for문 끝

			makeTracks(trackList);
			track.add(makeEvent(176,1,127,0,16));
		}// 바깥쪽 for문 끝

		track.add(makeEvent(192,9,1,0,15));
		try{
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch(Exception e){e.printStackTrace();}
	} // buildTrackAndStart 메소드 끝

	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			buildTrackAndStart();
		}
	} // 내부 클래스 끝

	public class MyStopListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			sequencer.stop();
		}
	}// 내부 클래스 끝

	public class MyUpTempoListener implements ActionListener{
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor * 1.03));
		}
	}// 내부 클래스 끝
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a){
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor* .97));
		}
	}// 내부 클래스 끝

	/* 비트박스 프로그램 패턴 복구 구현입니다. */
	public	class MyReadInListener implements ActionListener {

		public void actionPerformed(ActionEvent a){
			boolean [] checkboxState = null;
			try{
				FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
				ObjectInputStream is = new ObjectInputStream(fileIn);
				checkboxState = (boolean [])is.readObject();
				// 파일에서 객체 하나를 읽은 다음 부울 배열로 다시 캐스트합니다.
			}catch(Exception ex){ex.printStackTrace();}

			for(int i = 0; i<256; i++){
				JCheckBox check = (JCheckBox) checkboxList.get(i);
				// 실제 JCheckBox 객체로 구성된 ArrayList에 들어있는 각각의 체크상자의 상태를 
				// 원래대로 복구합니다.
				if(checkboxState[i]){
					check.setSelected(true);
				}else{
					check.setSelected(false);
				}
			}
			// 현재 연주 중인 것을 멈추고 ArrayList에 들어있는 체크상자의 새로운 상태를
			// 이용하여 시퀀스를 재구성합니다.
			sequencer.stop();
			buildTrackAndStart();
		} // 메소드 끝
	} // 내부 클래스 끝

	// 한 악기의 16박자 전체에 대해 이벤트를 생성. int배열에는 악기에 해당하는
	// 건반 번호 또는 0이 들어갑니다. 0이 들어있다면 그 박자에서는 해당 악기가
	// 연주되지 않아야 합니다. 0이 아닌 값이 들어있다면 이벤트를 만들어서
	// 트랙에 추가합니다.
	public void makeTracks(int [] list){
		for(int i=0;i<16;i++){
			int key = list[i];

			if(key!=0){

				// Note on과 note off 이벤트를 만들고 트랙에 추가합니다.                
				track.add(makeEvent(144,9,key,100,i));
				track.add(makeEvent(128,9,key,100,i+1));
			}
		}
	}

	public MidiEvent makeEvent(int comd, int chan , int one, int two, int tick){
		MidiEvent event = null;
		try{
			ShortMessage a = new ShortMessage();
			a.setMessage(comd,chan,one,two);
			event = new MidiEvent ( a, tick);

		}catch(Exception e){e.printStackTrace();}
		return event;

	}
}//클래스 끝


}}}