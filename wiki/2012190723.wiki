#summary ★☆★☆★☆★☆★☆★☆ [컴퓨터교육과 2012190723 남학생]의 실습페이지입니다. ☆★☆★☆★☆★☆★☆★

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
주어진 코드로 프로그램을 만들게되면 출력 결과에 문제가 생긴다.
후반부에
1 bottles of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
이렇게 출력이 되는데 이때, 1 bottles 라고 복수형으로 출력되는 문제가 발생된다.
따라서, 이 문제를 해결하기 위해서는 if(beerNum==1)조건문의 위치를 바꾸면 된다.

public class BeerSong {    // BeerSong이라는 이름의 클레스를 생성합니다.
   public static void main(String[]args){  // main 메소드를 하나 생성합니다.
      int beerNum=99; // beerNum이라는 정수형 변수에 99를 넣습니다.
      String word="bottles"; // 문자열 word 변수에 "bottles"를 넣습니다.

      while(beerNum>0){ // beerNum이 0이 되기 전까지 반복문을 반복합니다.

          System.out.println(beerNum+""+word+"of beer on the wall");
          System.out.println(beerNum+""+word+"of beer.");
          System.out.println("Take one down.");
          System.out.println("Pass it around.");
          beerNum=beerNum-1;

      if(beerNum==1){
          word="bottle"; // beerNum이 1이되면 word를 단수형인 "bottle"로 바꿉니다.
      }
      if(beerNum>0){
          System.out.println(beerNum+""+word+"of beer on the wall");
      }else{
          System.out.println("No more bottles of beer on the wall");
      } //else문을 종료합니다.
     } //while 순환문을 종료합니다.
    } //main 클래스를 종료합니다.
   } //클래스를 종료합니다.

이렇게 코드를 수정하면,
1 bottle of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
에서 처럼 1개의 병을 단수형(bottle)으로 나타낸다.
따라서, 1개의 병이 bottles로 출력되는 문제를 해결했다.

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic{
 public static void main(String[]args){

//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
  String[]wordListOne={"People","Dog","Fish","Cat","Man","Girl","Boy",
"Computer","Monitor","Butter"};

  String[]wordListTwo={"is","are","were","was","makes","did","be",
"drinks","fires","swim","barks","run","walk","work","sing","fight"};

  String[]wordListThree={"fast","slowly","early","instantly","funny","laugh","human",
"cheese","cake","high","jump","pool","fire","egg","game"};

//각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
int oneLength=wordListOne.length;
int twoLength=wordListTwo.length;
int threeLength=wordListThree.length;

//난수 세 개를 발생시킵니다.
int rand1=(int) (Math.random()*oneLength);
int rand2=(int) (Math.random()*twoLength);
int rand3=(int) (Math.random()*threeLength);

//이제 구문을 만듭니다.
  String phrase=wordListOne[rand1]+""+wordListTwo[rand2]+""+wordListThree[rand3];

//구문을 출력합니다.
  System.out.println("What we need is a"+phrase);
 }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
1. 컴파일러는 파일만 줄뿐 실행은 자바 가상 머신(JVM)이 한다.

2. 프로그래머가 직접 바이트 코드를 작성해도된다.

3. JVM이 ClassCast Exception을 발생시킨다. 

4. JVM은 보안 관련 작업을 처리한다.

5. 바이트코드가 만들어진 다음 실행되기 전까지 다른 사람이 건드리는지 확인한다.

 * 컴파일러:
1. 자바가 인터프리터 언어라면 실행 속도가 느려질 것이다. 즉, 바이트코드 컴파일러를 사용해야한다.

2. 워드 프로세서 없이 포스트스크립트를 직접 작성하는 것과 마찬가지로 바이트코드를 직접 짜는 건 불가능하다.

3. 자바는 type을 지키는 언어이므로 컴파일러가 위반 사항을 막는다.

4. ClassCast Exception은 동적 바인딩을 지원하기 위한 것, 유연성을 확보하기 위해 실행 할 때 일어나면 안 되는 일을 미리 감지하고 방지한다.

5. 비공개 메소드 호출과 수정하면 안 되는 메소드 변경과 같은 접근 위반을 방지한다.
또한, 클래스의 핵심 내용에 접근하는 코드와 함부로 보면 안 되는 코드를 건드리는 것도 방지한다.

6. 컴파일러가 우선적으로 문제점을 잡아낸다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A: 
// big x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){
  int x=1;
  while(x<10){
   x=x+1; // 이 부분이 빠지면 while 반복문이 무한히 순환합니다. 
   if(x>3){
    System.out.println("big x");
   }
  }
 }
}

B:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1a{ // 클래스 정의 부분이 빠져있기때문에 추가했습니다.
 public static void main(String[]args){
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}
  
C:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){ //메소드가 빠져서 추가했습니다.
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것, 객체의 상태(데이터)를 나타낸다.
 * 메소드: 객체에서 자신이 하는 것.
 * 클래스: 객체를 만들기 위한 용도로 사용. 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: color, power, channel
 * 메소드: power(), channelUp(), ChannelDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame(){
		p1=new Player();
		p2=new Player();
		p3=new Player();
		p4=new Player();

		int guessp1=0;
		int guessp2=0;
		int guessp3=0;
		int guessp4=0;

		boolean p1isRight=false;
		boolean p2isRight=false;
		boolean p3isRight=false;
		boolean p4isRight=false;

		int targetNumber=(int)(Math.random()*10);
		System.out.println("0이상 9이하의 숫자를 맞춰보세요.");

		while(true){
			System.out.println("맞춰야 할 숫자는"+targetNumber+"입니다.");

			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();

			guessp1=p1.number;
			System.out.println("1번 선수가 찍은 숫자:"+guessp1);

			guessp2=p2.number;
			System.out.println("2번 선수가 찍은 숫자:"+guessp2);

			guessp3=p3.number;
			System.out.println("3번 선수가 찍은 숫자:"+guessp3);

			guessp4=p4.number;
			System.out.println("4번 선수가 찍은 숫자:"+guessp4);

			if(guessp1==targetNumber){
				p1isRight=true;
			}

			if(guessp2==targetNumber){
				p2isRight=true;
			}

			if(guessp3==targetNumber){
				p3isRight=true;
			}

			if(guessp4==targetNumber){
				p4isRight=true;
			}

			if(p1isRight|p2isRight|p3isRight|p4isRight){
				System.out.println("맞춘 선수가 없습니다.");
				System.out.println("1번 선수:"+p1isRight);
				System.out.println("2번 선수:"+p2isRight);
				System.out.println("3번 선수:"+p3isRight);
				System.out.println("4번 선수:"+p4isRight);
				break;
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

class Player{
	int number=0;

	public void guess(){
		number=(int)(Math.random()*10);
		System.out.println("찍은 숫자:"+number);
	}
}

public class GameLauncher{
	public static void main (String[]args){
		GuessGame game=new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A:
class TapeDeck{ // 테입덱이라는 클래스를 생성합니다.

	boolean canRecord=false; // canRecord를 불린 값으로 지정합니다.

	void playTape(){
		System.out.println("tape playing");
	}

	void recordTape(){
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive{ // 테스트 클래스를 만듭니다.
	public static void main(String[]args){

		TapeDeck t=new TapeDeck(); // t객체를 만들어 줍니다.

		t.canRecord=true;
		t.playTape();

		if(t.canRecord==true){
			t.recordTape();
		}
	}
}

B:
class DVDPlayer{
	boolean canRecord=false;
	void recordDVD(){
		System.out.println("DVD recording");
	}
	void playDVD(){ // playDVD 메소드를 설정해야 아래 클래스에서 객체를 사용할 수 있습니다.
		System.out.println("DVD playing");
	}
}
class DVDPlayerTestDrive{
	public static void main(String[]args){
		DVDPlayer d = new DVDPlayer();
		d.canRecord=true;
		d.playDVD();
			if(d.canRecord==true){
				d.recordDVD();
			}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
1) 원시변수: 
원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어간다.

2) 레퍼런스 변수:
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.


 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog { // Dog 클래스를 생성합니다.
	String name;
	public static void main(String[]args){
		// Dog 객체를 만들고 접근합니다.
		Dog dog1=new Dog();
		dog1.bark();
		dog1.name="Bart";

		Dog[]myDogs=new Dog[10]; // Dog 배열을 만들어 난장판을 만들겁니다.
		myDogs[0]=new Dog();
		myDogs[1]=new Dog();
		myDogs[2]=dog1; // myDogs[2]에 dog1을 넣습니다.
		myDogs[3]=new Dog();
		myDogs[4]=new Dog();
		myDogs[5]=new Dog();
		myDogs[6]=new Dog();
		myDogs[7]=new Dog();
		myDogs[8]=new Dog();
		myDogs[9]=new Dog();

		// 배열 레퍼런스를 써서 Dog 객체에 접근합니다.

		myDogs[0].name="Fred";
		myDogs[3].name="JungGon";
		myDogs[4].name="Chaewon";
		myDogs[5].name="Seohyun";
		myDogs[6].name="kyungMin";
		myDogs[7].name="Heawon";
		myDogs[8].name="Park";
		myDogs[9].name="BongWoo";

		System.out.print("마지막 개의 이름:");
		System.out.println(myDogs[9].name); // 마지막 개의 이름을 출력합니다.

		// 순환문을 써서 배열에 있는 개가 짖도록 합니다.

		int x=0;
		while(x<myDogs.length){
			myDogs[x].bark();
			x=x+1;
		}
	}

	public void bark(){
		System.out.println(name+"이(가) 왈!하고 짖습니다.");
	}
	public void eat(){}
	public void chaseCat(){}


}



}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A:
// Books 클래스를 생성합니다.
class Books{
	String title;
	String author;
}

class BooksTestDrive{
	public static void main(String[]args){
		Books[]myBooks=new Books[3]; 
		int x=0;
		// Books 객체를 생성합니다.
		myBooks[0]=new Books();
		myBooks[1]=new Books();
		myBooks[2]=new Books();

		// 객체들의 속성을 채워줍니다.
		myBooks[0].title="The Grapes of Java";
		myBooks[1].title="The Java Gatsby";
		myBooks[2].title="The Java Cookbook";
		myBooks[0].author="bob";
		myBooks[1].author="sue";
		myBooks[2].author="ian";
		while(x<3){
			System.out.print(myBooks[x].title);
			System.out.print("by");
			System.out.println(myBooks[x].author);
			x=x+1;
		}		
	}

}

B:
// Hobbits 클래스를 생성합니다.
class Hobbits {
	String name;
	public static void main (String [] args) {

		Hobbits [] h = new Hobbits[3];
		int z = 0; // 배열의 인덱스는 0에서 시작하므로 0으로 설정합니다.

		while (z<3)     {    // 따라서 z<3입니다.

		h[z] = new Hobbits(); // 객체를 생성합니다.
		h[z].name = "bilbo";
		if (z==1) {
			h[z].name = "frodo";
		}
		if (z==2) {
			h[z].name = "sam";
		}
		System.out.print(h[z].name + " is a ");
		System.out.println("good hobbit name");
		z = z + 1; //Z의 값을 1씩 증가시킵니다.
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 
밥이 이겼습니다.
 * 문제가 된 부분은 어딘가요?:
켄트의 메소드에는 순환문을 한 바퀴 돌 때마다 새로운 객체를 레퍼런스 변수 하나에 대입했기때문에,

전에 참조하고 있던 객체는 버려지게되는 문제가 발생했습니다.

따라서, 레퍼런스 변수하나에 객체 하나씩 연결한 밥이 켄트를 이겼습니다.


= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
객체의 자료와 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것입니다.

캡슐화를 하려면, 인스턴트 변수를 private으로 지정하고

접근 제어를 위해 public으로 지정된 게터와 세터를 만들면 됩니다.

 * 게터와 세터:
캡슐화를 위해 게터와 세터 메소드를 사용합니다.

인스턴트 변수를 private으로 설정하고 게터와 세터로 값을 받고 리턴합니다.

게터와 세터를 이용하면 코드 변경시 다른 코드는 건드리지 않아도 됩니다.


 * 인스턴스 변수 vs 지역 변수:
 
1) 인스턴트 변수

- 클래스 내에서 선업됩니다.

2) 지역 변수

- 메소드 내에서 선업됩니다.

- 기본값이 없습니다. 

- 사용하기 전에 반드시 초기화해야합니다.

*107p Dog* _실행_

{{{

// 여러 개들이 짖는 프로그램입니다.
// Dog 클래스를 생성합니다.
class Dog {
	int size;
	String name;

	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof!");
		}else if(size>14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}

}
class DogTestDrive{

	public static void main(String[]args){
		// Dog 객체들을 생성합니다.
		Dog one=new Dog();
		one.size=70;
		Dog two=new Dog();
		two.size=8;
		Dog three=new Dog();
		three.size=35;
		// 동일한 메소드로 서로 다른 결과가 나오는 것을 확인합니다.
		one.bark();
		two.bark();
		three.bark();

	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A:

// 수(인자)를 메소드에 넘겼다가 리턴받는 코드입니다. 
class XCopy {

	public static void main(String[] args) {
		int orig=42;
		XCopy x=new XCopy(); // XCopy 객체 x를 생성합니다.
		int y= x.go(orig); // y변수에 42를 go 메소드에 넘겨받은 리턴값을 대입합니다.
		System.out.println(orig+""+y); // orig와 y를 출력합니다.
	}

	int go(int arg){ // 이때 orig의 값은 바뀌지 않습니다.
		arg=arg*2;
		return arg;
	}
}


B:

// 게터와 세터를 사용하여 캡슐화를 한 코드입니다.
class Clock{
	String time;
	void setTime(String t){
		time=t;
	}
	String getTime(){ // 게터 메소드에는 리턴 타입을 설정해야합니다.
		return time;
	}
}

class ClockTestDrive {

	public static void main(String[] args) {
		Clock c= new Clock();
		c.setTime("1245");
		String tod=c.getTime();
		System.out.println("time:"+tod);
	}

}


}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

- 90년대 말에 등장한 소프트웨어 개발 방법이다.

- 마지막에 스펙이 변경되어도 고객이 원하는 기한에 맞춰서 제공할 수 있다.

- 모든 일을 단순하게 처리

- 사이클을 반복하여 개발 및 테스트  코드를 먼저 만든다.

- 기회가 생길때 마다 코드를 개선

- 두 명씩 팀을 편성하고 모든 사람이 대부분의 코드를 알 수 있도록 돌아가면서 작업.

- 모든 테스트를 통과하기 전에는 발표하지 않는다.

 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

// SimpleDotCom 게임의 최종 코드입니다.
// 가져오기를 선언합니다.
import java.io.*;

class GameHelper { //GameHelper 클래스를 생성합니다.
	public String getUserInput(String prompt) {
		String inputLine = null; 
		System.out.print(prompt + "");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(
					System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0)
				return null;
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}
class SimpleDotCom { //SimpleDotCom 클래스를 생성합니다.
	int[] locationCells;
	int numOfHits = 0; // 초기 hit 수를 0으로 설정합니다.

	public void setLocationCells(int[] locs) {
		locationCells = locs;

	}

	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess); // string을 int로 변환합니다.
		String result = "miss"; // 리턴할 결과를 저장할 변수입니다. 기본값은 "miss" 입니다.
		for (int i = 0; i < locationCells.length; i++) { // 추측한 값을 배열의 원소와 비교합니다.
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break; // 순환문을 빠져나옵니다.
			}
		}
		if (numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;

	}
}

public class SimpleDotComTestDrive { 

	public static void main(String[] args) {

		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

		int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;

		while (isAlive == true) {
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;

			if (result.equals("kill")) {
				isAlive = false;
				System.out.println(numOfGuesses + " guesses");
			}

		} 

	}  // 메소드 끝
} // 클래스 끝


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

// 첫번째 옵션을 구현한 코드입니다.

import java.io.*;

class GameHelper { // GameHelper 클래스를 생성합니다.

	public String getUserInput (String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");

		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}

		return inputLine;
	}

}

public class SimpleDotComTestDrive { // SimpleDotComTestDrive클래스를 생성합니다.

	public static void main(String[] args){


		int numOfGuesses=0;

		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};

		boolean[] hitCells = new boolean[3]; // 첫번째 옵션, 사용자가 입력 했던 값을 판단하기 위한  boolean 배열을 생성합니다.

		//닷컴 클래스로 boolean 배열을 넘겨줍니다
		theDotCom.sethitCells(hitCells);

		theDotCom.setLocationCells(locations);

		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + "guesses");
			}

		}
	}

}


class SimpleDotCom { // SimpleDotCom클래스를 생성합니다.

	int[] locationCells;
	boolean[] hitCells = new boolean[3];

	int numOfHits = 0;

	public void setLocationCells(int[] locs){

		locationCells = locs;
	}

	public void sethitCells(boolean[] check){ 
		hitCells = check;
	}


	public String checkYourself(String stringGuess){

		int guess = Integer.parseInt(stringGuess);

		String result = "miss";

		for(int i = 0; i < locationCells.length; i++){

			if(guess == locationCells[i] && hitCells[i]!=true){ // 이미 맞춘 배열인지 확인합니다.
				result = "hit";
				numOfHits++;
				hitCells[i] = true; // 맞춘 배열이기때문에 true로 바꿔줍니다.
				break;

			}

		}

		if (numOfHits == locationCells.length){
			result = "kill";
		}

		System.out.println(result);
		return result;

	}

}



}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

// 두번째 옵션을 구현한 코드입니다.

import java.io.*;

class GameHelper { // GameHelper 클래스를 생성합니다.

	public String getUserInput (String prompt){
		String inputLine = null;
		System.out.print(prompt + " ");

		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length() == 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}

		return inputLine;
	}

}

public class SimpleDotComTestDrive { // SimpleDotComTestDrive클래스를 생성합니다.

	public static void main(String[] args){


		int numOfGuesses=0;

		GameHelper helper = new GameHelper();

		SimpleDotCom theDotCom = new SimpleDotCom();

		int randomNum = (int) (Math.random() * 5);

		int[] locations = {randomNum, randomNum+1, randomNum+2};

		theDotCom.setLocationCells(locations);

		boolean isAlive = true;

		while(isAlive == true){
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			if(result.equals("kill")){
				isAlive = false;
				System.out.println(numOfGuesses + "guesses");
			}

		}
	}

}


class SimpleDotCom { // SimpleDotCom클래스를 생성합니다.

	int[] locationCells;


	int numOfHits = 0;

	public void setLocationCells(int[] locs){

		locationCells = locs;
	}

	public String checkYourself(String stringGuess){

		int guess = Integer.parseInt(stringGuess);

		String result = "miss";

		for(int i = 0; i < locationCells.length; i++){

			if(guess == locationCells[i] && locationCells[i]!=-1){ // 이미 맞춘 배열인지 확인합니다. 이미 맞춘 배열은 -1값을 가집니다.
				result = "hit";
				numOfHits++;
				locationCells[i]=-1; // 맞춘 배열은 -1값으로 변경해줍니다.(두번째 옵션)

				break;

			}

		}

		if (numOfHits == locationCells.length){
			result = "kill";
		}

		System.out.println(result);
		return result;

	}

} // 클래스 끝

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
// 세번째 옵션을 구현한 코드입니다.
import java.util.ArrayList;

public class DotCom
{
     private ArrayList<String> locationCells;
     // 배역 대신 string이 들어가는 ArrayList를 사용
     // private int numOfHits;
      // 없어도 됩니다.

     public void setLocationCells(ArrayList<String>loc)
     // 배역 대신 string이 들어가는 ArrayList를 사용
    {
         locationCells = loc;
     }
 
     public String checkYourself(String userInput)
     // 새로 바뀐 인자명 입니다.
    {
          String result = "miss";
  
          int index = locationCells.indexOf(userInput);
          // 사용자가 추측한 뒤 위치가 ArrayList에 들어있는지
          // 확인합니다. 들어있으면 인덱스 번호가, 그렇지 않으면
          // 리턴합니다.
  
          if(index >= 0)
          {
                locationCells.remove(userInput);
                // 인덱스가 0 이상이면 사용자가 추측한 
                // 위치가 목록에 들어있는 것이므로 
                // 제거합니다.
   
              if(locationCells.isEmpty())
              // 목록이 비어짔다면 그 닷컴이 죽었다는 것을 알수 있습니다.
             {
                   result = "Kill";
             }
             else
             {
                   result = "hit";
              }        //if문 끝
         }        // 바깥쪽 if문 끝
         return result;
    }        // 메소드 끝
}         // 클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{


/* DotCom 게임 최종 완성 코드입니다.DotCom, DotComBust, GameHelper 클래스들이있습니다. */

import java.io.*;
import java.util.*;

class GameHelper // GameHelper 클래스를 생성합니다.
{
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int [] grid = new int[gridSize];
	private int comCount = 0;
	public String getUserInput(String prompt) 
			throws IOException{
		String inputLine = null;
		System.out.print(prompt + " ");
		try{
			BufferedReader is = new BufferedReader
					(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length()==0)   return null;

		}catch(IOException e) {
			System.out.println("OException: " + e);
		}
		return inputLine.toLowerCase();
	}

	public ArrayList<String>placeDotCom(int comSize)
	{
		ArrayList<String> alphaCells = new ArrayList<String>(); 
		// new String [comSize];

		String [] alphacoords = new String[comSize];
		// 'f6'과 같은 좌표가 들어갑니다.

		String temp = null;
		// 나중에 연결하기 위한 임시 String 배열을 생성합니다.

		int [] coords = new int[comSize];
		// 현재 후보 좌표입니다.

		int attempts = 0;
		// 시도 횟수를 세기위한 카운터입니다.

		boolean success = false;
		// 적당한 위치를 찾았는지 표시하기 위한 플래그입니다.

		int location = 0;
		// 현재 시작 위치를 0으로 설정합니다.

		comCount++;
		// n번째 닷컴입니다.

		int incr = 1;
		// 수직 방향으로 증가 시킬 값을 설정합니다.

		if ((comCount % 2) == 1) 
			// 홀수 번째 닷컴인 경우(수직으로 배치합니다.)  
		{
			incr = gridLength;
			// 수직 방향으로 증가시킬 값을 설정합니다.
		}
		while ( !success & attempts++ < 200) 
			// 주 검색 순환문(32)
		{
			location = (int) (Math.random() * gridSize);
			// 임의의 시작위치를 구함. 

			System.out.print("try" + location);
			int x = 0;
			//위치 시킬 닷컴의 n번째 위치.

			success = true;
			// 성공한다고 가정합니다.

			while (success && x < comSize) 
				// 닷컴이 들어갈자리가 비었는지 확인합니다.
			{
				if (grid[location] == 0) 

				{
					coords[x++] = location;
					// 위치 저장.

					location += incr;
					// 다음칸 확인.

					if (location >= gridSize)
						// 경계를 벗어난 경우.
					{
						success = false;
						// 실패.
					}
					if (x>0 & (location % gridLength == 0))
						// 경계를 벗어난 경우(오른쪽)     
					{
						success = false;
						// 실패.
					}
				} else {
					// 이미 사용 중인 경우
					System.out.print("used "+location);
					success = false;
					//실패.
				}
			}
		}  // while문 종료.

		int x = 0;
		// 위치를 알파벳 좌표로 바꿉니다.

		int row = 0;  
		int column = 0;
		System.out.println(" |n");
		while (x < comSize) 
		{
			grid[coords[x]] = 1;
			// 기본 그리드 좌표를 사용합니다.

			row = (int) (coords[x] / gridLength);
			// 행 값을 구합니다.

			column = coords[x] % gridLength;
			// 열 값(숫자)을 구합니다.

			temp = String.valueOf(alphabet.charAt(column));
			// 숫자로 된 열을 알파벳으로 변환합니다.

			alphaCells.add(temp.concat
					(Integer.toString(row))); 
			x++;
			System.out.print(" coord " + x + " = " + 
					alphaCells.get(x-1));
			// 닷컴의 위치를 알려주는 코드입니다.
		}
		System.out.println(" d2|n?");
		return alphaCells;
	}
}

class DotCom
{
	private ArrayList<String> locationCells;
	private String name;
	// DotCom의 인스턴스 변수
	// - 셀위치가 들어있는 ArrayList
	//  - DotCom의 이름
	public void setLocationCells(ArrayList<String> loc)
	{
		locationCells = loc;
	}
	// DotCom의 위치를 갱신하는 세터 메소드 
	// placeDotCom()메소드에서 제공하는 무작위로 만든  위치

	public void setname(String n) 
	{
		name = n;
	}
	// 기초적인 세터 메소드입니다.

	public String checkYourself(String userInput) 
	{
		String status = "miss";
		int index = locationCells.indexOf(userInput);
		/* ArrayList의 indexOf()메소드를 쓰고 있습니다. 사용자가 추측한 
		 위치가 ArrayList에 들어있으면 indexOf()에서 
		 그 항목의 인텟스를 리턴합니다.
		 그렇지 않으면 -1을 리턴합니다. */

		if(index >=0) 
		{
			locationCells.remove(index);
			// ArrayList의 remove메소드를  써서 그 항목을 지웁니다.

			if (locationCells.isEmpty())
				// isEmpty()메소드를 써서 모든 위치를 맞췄는지 확인합니다.
			{  
				status = "kill";
				System.out.println("Ouch! You sunk" +
						name + " : ( ");
				// 닷컴이 가라 앉았음을 알려줍니다.
			}else {
				status = "hit";
			}
		} // if문 종료.
		return status;
		// 'miss','hit'또는 'kill'을 리턴합니다.
	} // method 종료.
} // class 종료.

class DotComBust 
{
	// 사용할 변수를 선언하고 초기화 합니다.
	private GameHelper helper;
	private ArrayList<DotCom> dotComsList;
	private int numOfGuesses;
	/* DotCom객체로 이루어진  ArrayList를 만듭니다.
	(즉 DotCom[]이 DotCom객체들이 들어있는 배열을 뜻하는 것과
	 마찬가지로  ArrayList (DotCom)을 DotCom객체들이 들어
	있는 ArrayList라고 생각하면 됩니다.) */

	public DotComBust()
	{
		helper = new GameHelper();
		dotComsList = new ArrayList<DotCom>();
		numOfGuesses = 0;
	}

	private void setUpGame()
	// 우선 닷컴 객체 몇 개를 만들고 위치를 지정합니다.
	{
		DotCom one = new DotCom();
		one.setname("Pets.com");
		DotCom two = new DotCom();
		two.setname("eToys.com");
		DotCom three = new DotCom();
		three.setname("Go2.com");
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three);
		// DotCom 객체세개를 만들고 각각 이름을 부여하고 ArrayList에 저장합니다.

		System.out.println("Your goal is to sink three " +
				"dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in " +
				"the fewest number of guesses");
		// 사용자에게 간단한 게임 방법을 설명합니다.  

		for (DotCom dotComToset : dotComsList) 
			// 목록에 있는 각 DotCom에 대해 반복합니다.   
		{
			ArrayList<String> newLocation 
			= helper.placeDotCom(3);
			// DotCom의 위치를 지정하기 위한 보조 메소드를 호출합니다.

			dotComToset.setLocationCells(newLocation);
			// 이 DotCom 객체의 세터메소드를 호출하여 방금 보조 메소드에서  받아온 위치를 지정합니다.

		} // for문 종료.
	} // setUpgame method 종료.

	private void startPlaying() throws IOException
	{
		while (!dotComsList.isEmpty())
			// DotCom목록이 비어있지 않으면 (1은 부정(NOT)을 의미 합니다. dotComList.isEmpty() == false와 똑같습니다.)
		{
			String userGuess 
			= helper.getUserInput("Enter a guess");
			// 사용자 입력을 받습니다

			checkUserGuess(userGuess);
			// checkUserGuess 메소드를 호출합니다.
		} // while문 종료.
		finishGame();
		// finishGame() 메소드를 호출합니다.
	} // startPlaying method 종료.

	private void checkUserGuess(String userGuess) 
	{
		numOfGuesses++;
		// 사용자가 추측한 횟수를 증가시킵니다.

		String result = "miss";
		// 따로 바꾸지 않으면'miss'라고 가정합니다.

		for (DotCom dotComToTest : dotComsList)
			// 목록에 들어있는모든 DotCom객체에 대해 반복합니다.
		{
			result = dotComToTest.checkYourself(userGuess);
			// DotCom 객체에 사용자가 입력한 위치가 맞는지 또는  그 객체가 죽었는지 물어봅니다.

			if (result.equals("hit"))
			{
				break;
				// 순환문에서 일찍빠져나옵니다. 더 이상 확인하지 않아도 됩니다.
			}
			if (result.equals("kill"))
			{
				dotComsList.remove(dotComToTest);
				// 이것은 죽었으니 DotCom 목록에서 빼고 
				// 순환문을 빠져나갑니다.
				break;
			}
		} // for문 종료.
		System.out.println(result);
		// 결과를 출력합니다.

	} // 메소드 종료.

	private void finishGame()
	{
		System.out.println("All Dots are dead! Your " +
				"stock is now worthless");
		if (numOfGuesses<=18)
		{
			System.out.println("It only took you" + 
					numOfGuesses + "Guesses.");
			System.out.println("You got out before your  " +
					"  options sank");
		}else {
			System.out.println("Took you long enough. " +
					numOfGuesses + "guess.");
			System.out.println("Fish are dancing with " +
					" your options");
		}
		// 게임결과를 알려주는 메시지를 출력합니다.
	}  // method 종료.

	public static void main(String[] args)throws IOException
	{
		DotComBust game = new DotComBust();
		// 게임 객체를 만듭니다.

		game.setUpGame();
		// 게임 객체에게 게임을 설정하라는 명령을 내립니다.

		game.startPlaying();
		// 게임 객체에서 주 게임 진행 순환문을 돌리라는 명령을 내립니다.
		// (사용자에게 계속 위치를 물어보고, 그위치를 확인합니다.)
	}  // method 종료.
} // 클래스 종료.



}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 
 상위클래스로부터 인스턴스 변수와 메소드를 하위클래스에게 넘겨주는 것을 상속이라한다. 이때, 공통적인 코드를 어떤 클래스에 넣은 다음 다른 더 구체적인 클래스에 공통적인 클래스가 상위클래스라는 것을 알려주면 된다.

 * 다형성: 
 여러가지 형태를 하나의 그릇으로 나타낼 수 있다. 즉, 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다. 이때 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가 하더라도 코드를 굳이 바꿀 필요가 없게 된다. 

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
// 1번 코드가 제대로 작동합니다.
public class MonsterTestDrive {
        public static void main(String [] args) { 
                Monster [] ma = new Monster[3]; // Vampire,Dragon,Monster를 생성합니다.
                ma[0] = new Vampire();
                ma[1] = new Dragon();
                ma[2] = new Monster();
                for(int x = 0; x<3; x++) { // 입력값 0,1,2을 넣어줍니다.
                        ma[x].frighten(x);
                }
        }
}

class Monster {
                boolean frighten(int d) { //int 를 받아 bool로 출력합니다.
                        System.out.println("arrrgh");
                        return true;
                }
}

class Vampire extends Monster { //Monster를 상속받습니다.
                boolean frighten(int x) {  //int 를 받아 bool로 출력합니다.
                        System.out.println("a bite?");
                        return false;
                }
        }

 class Dragon extends Monster{
        boolean frighten(int degree) {
                System.out.println("breath fire");
                return true;
        }
}

결과값 : 
a bite?
breath fire
arrrgh
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}