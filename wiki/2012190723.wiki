#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
주어진 코드로 프로그램을 만들게되면 출력 결과에 문제가 생긴다.
후반부에
1 bottles of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
이렇게 출력이 되는데 이때, 1 bottles 라고 복수형으로 출력되는 문제가 발생된다.
따라서, 이 문제를 해결하기 위해서는 if(beerNum==1)조건문의 위치를 바꾸면 된다.

public class BeerSong {    // BeerSong이라는 이름의 클레스를 생성합니다.
   public static void main(String[]args){  // main 메소드를 하나 생성합니다.
      int beerNum=99; // beerNum이라는 정수형 변수에 99를 넣습니다.
      String word="bottles"; // 문자열 word 변수에 "bottles"를 넣습니다.

      while(beerNum>0){ // beerNum이 0이 되기 전까지 반복문을 반복합니다.

          System.out.println(beerNum+""+word+"of beer on the wall");
          System.out.println(beerNum+""+word+"of beer.");
          System.out.println("Take one down.");
          System.out.println("Pass it around.");
          beerNum=beerNum-1;

      if(beerNum==1){
          word="bottle"; // beerNum이 1이되면 word를 단수형인 "bottle"로 바꿉니다.
      }
      if(beerNum>0){
          System.out.println(beerNum+""+word+"of beer on the wall");
      }else{
          System.out.println("No more bottles of beer on the wall");
      } //else문을 종료합니다.
     } //while 순환문을 종료합니다.
    } //main 클래스를 종료합니다.
   } //클래스를 종료합니다.

이렇게 코드를 수정하면,
1 bottle of beer on the wall 
1 bottle of beer on the wall
1 bottle of beer.
에서 처럼 1개의 병을 단수형(bottle)으로 나타낸다.
따라서, 1개의 병이 bottles로 출력되는 문제를 해결했다.

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic{
 public static void main(String[]args){

//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
  String[]wordListOne={"People","Dog","Fish","Cat","Man","Girl","Boy",
"Computer","Monitor","Butter"};

  String[]wordListTwo={"is","are","were","was","makes","did","be",
"drinks","fires","swim","barks","run","walk","work","sing","fight"};

  String[]wordListThree={"fast","slowly","early","instantly","funny","laugh","human",
"cheese","cake","high","jump","pool","fire","egg","game"};

//각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
int oneLength=wordListOne.length;
int twoLength=wordListTwo.length;
int threeLength=wordListThree.length;

//난수 세 개를 발생시킵니다.
int rand1=(int) (Math.random()*oneLength);
int rand2=(int) (Math.random()*twoLength);
int rand3=(int) (Math.random()*threeLength);

//이제 구문을 만듭니다.
  String phrase=wordListOne[rand1]+""+wordListTwo[rand2]+""+wordListThree[rand3];

//구문을 출력합니다.
  System.out.println("What we need is a"+phrase);
 }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
1. 컴파일러는 파일만 줄뿐 실행은 자바 가상 머신(JVM)이 한다.

2. 프로그래머가 직접 바이트 코드를 작성해도된다.

3. JVM이 ClassCast Exception을 발생시킨다. 

4. JVM은 보안 관련 작업을 처리한다.

5. 바이트코드가 만들어진 다음 실행되기 전까지 다른 사람이 건드리는지 확인한다.

 * 컴파일러:
1. 자바가 인터프리터 언어라면 실행 속도가 느려질 것이다. 즉, 바이트코드 컴파일러를 사용해야한다.

2. 워드 프로세서 없이 포스트스크립트를 직접 작성하는 것과 마찬가지로 바이트코드를 직접 짜는 건 불가능하다.

3. 자바는 type을 지키는 언어이므로 컴파일러가 위반 사항을 막는다.

4. ClassCast Exception은 동적 바인딩을 지원하기 위한 것, 유연성을 확보하기 위해 실행 할 때 일어나면 안 되는 일을 미리 감지하고 방지한다.

5. 비공개 메소드 호출과 수정하면 안 되는 메소드 변경과 같은 접근 위반을 방지한다.
또한, 클래스의 핵심 내용에 접근하는 코드와 함부로 보면 안 되는 코드를 건드리는 것도 방지한다.

6. 컴파일러가 우선적으로 문제점을 잡아낸다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A: 
// big x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){
  int x=1;
  while(x<10){
   x=x+1; // 이 부분이 빠지면 while 반복문이 무한히 순환합니다. 
   if(x>3){
    System.out.println("big x");
   }
  }
 }
}

B:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1a{ // 클래스 정의 부분이 빠져있기때문에 추가했습니다.
 public static void main(String[]args){
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}
  
C:
// small x라는 문장을 여러개 출력하는 프로그램입니다.
class Exercise1b{
 public static void main(String[]args){ //메소드가 빠져서 추가했습니다.
  int x=5;
  while(x>1){
   x=x-1;
   if(x<3){
    System.out.println("small x");
   }
  }
 }
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수:
 * 메소드:
 * 클래스:
 * 테스트용 클래스:
 

*68p Television* _채워넣기_

 * 인스턴스 변수:
 * 메소드:


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:
 * 문제가 된 부분은 어딘가요?:

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
 * 게터와 세터:
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_

{{{

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}