#summary 같은 그림 맞추기 게임!
#labels 2013190726임태휘

= Introduction =

4x4 칸의 카드들(8쌍)이 랜덤으로 뒤집은 채로 배치한 뒤, 게임 시작과 동시에 타이머가 작동합니다. 같은 그림의 카드를 연속으로 눌러서 모든 쌍을 찾아내는 게임입니다. 옵션 변경을 통해서 원하시는 그림 이미지로도 게임을 하실 수 있습니다.   

저는 게임도 게임이지만 어플리케이션 내의 부가적인 기능들에 초점을 맞추어 보았습니다. 실제 마켓에서 게임을 받게 되면 여러가지 옵션들이 게임 내에 존재하며, 각 옵션들은 단순 게임자체가 주는 재미에 버금가는 추가적인 흥미를 더해줍니다. 바로 이러한 점에 저의 이번 어플리케이션 개발 의도가 담겨있습니다. 

= 개발의 목적 및 필요성 =

http://comp166-koreauniv.googlecode.com/files/잉여.png


 귀가 시간이나 애매하게 남은 공강시간 참으로 따분하셨죠? 

 그래서 제가 여러분을 위해 준비했습니다. 정답은 바로 같은 그림 맞추기 게임!! 
 
 요즘 스마트폰 게임의 추세에 맞게 *재미*와 더불어 *조작의 단순함*, *짧은 진행시간*을 모두 갖춘 게임입니다. 

 게다가 기억력 강화에 도움을 줄 수 있기 때문에 치매를 예방하고자하시는 어르신들이나 갱년기를 앞두고 기억력 감퇴가 걱정되시는 부모님들께 상당히 유용한 게임입니다. 물론 유아들의 기억력 강화에도 도움이 되겠죠? 

 이와 같은 장점들만 모았습니다. "모두의 매칭"을 여러분께 소개합니다.     

= Requirment = 
 
 * Start Game 버튼 : 

1. Game Activity로 이동한다.

2. 4x4의 게임이 만들어짐과 동시에 타이머가 작동한다.

3. Game Activity 내의 Resume, Stop 버튼으로 게임을 멈추기, 재개하기가 가능하다. 

4. 7위내의 기록 경신 시 랭킹 닉네임 작성화면이 나타난다.
<br>            
<br>    
<br>
 * Option 버튼 :

1. Option Activity로 이동한다.<br>
<br>               
2. BGM on&off 기능, 카드 Image 변경 기능, 랭킹 초기화 기능 제공한다.
<br>
<br>
<br>
 * Ranking 버튼 : 

1. Ranking Activity로 이동한다.

2. 1위부터 7위까지의 랭커들의 닉네임을 순서대로 제공한다.  

= 게임의 구성(각 화면 구성 설명 및 버튼들의 기능 설명) =

자! 이제 본격적으로 본인이 만든 게임의 화면 구성 살펴보도록 하겠다.

== 메인 화면(Main Activity) == 


http://comp166-koreauniv.googlecode.com/files/메인화면1.png


http://comp166-koreauniv.googlecode.com/files/메인화면2.png


 * 첫 화면인 메인화면은 메인 로고와 3개의 버튼으로 구성되어 있다.

 * 메인로고는 가로와 세로 방향으로 80%~ 120%로 축소와 증가를 반복하도록 구성하였고, 반짝이는 것 같은 모습을 연출하기 위해 투명도의 변화를 그에 맞게 설정하였다. 

 * 각 버튼은 각 화면으로 이동하게 해주는 기능을 담당한다.

 * 추가적으로 좋아하는 배경음악을 BGM으로 설정해보았다. 노래 정보 : Better Together-Jack Johnson

== 옵션 화면(Option Activity) ==


http://comp166-koreauniv.googlecode.com/files/옵화.png


 * 옵션 화면은 사운드 on&off toggle 버튼, 카드 교체 radio 버튼, 랭킹 리셋 버튼으로 구성되어 있다. 

 * 사운드 on&off toggle 버튼은 처음에 사운드가 on의 상태로 실행되며 클릭 시 off로 바뀌면서 사운드가 멈춘다. 

 * 사운드의 재생방식은 모든 Activity에서 연결되도록 설정하였다. 따라서 모든 클래스에 onResume 메소드와 onPause 메소드를 동일하게 구성함으로써 사운드가 어디서나 연결되어 들리도록 하였다.

 * 각 카드의 종류에 따라 게임 화면의 카드가 변경된다. 

 * 랭킹 리셋 버튼을 누르면 랭킹에 있던 목록이 모두 설정된 초기값으로 초기화된다.

== 카드의 종류별 게임 화면 ==

 * 교수님카드

http://comp166-koreauniv.googlecode.com/files/교수님카드.png

 * 동물카드

http://comp166-koreauniv.googlecode.com/files/동물카드.png

 * 숫자카드

http://comp166-koreauniv.googlecode.com/files/숫자카드.png
  

== 랭킹화면과 랭킹 리셋 버튼의 동작 확인 ==


 * 랭킹화면


http://comp166-koreauniv.googlecode.com/files/랭킹화면.png


 * 랭킹 초기화화면


http://comp166-koreauniv.googlecode.com/files/랭초화.png


== 게임 화면(Game Activity) ==

 
http://comp166-koreauniv.googlecode.com/files/동물카드.png


 * 게임 화면은 타이머, 카드, 버튼들로 구성되어 있다.

 * 타이머는 게임 시작과 동시에 작동하고, 모든 8쌍의 카드를 맞추면 바로 정지하도록 설정되어 있다. 

 * 각 버튼들에 의해 급한 일이 생긴 경우 정지할 수 있고, 일이 마무리되고 나면 다시 재개가 가능하며, 패가 좋지 않다고 생각되면 새 게임을 진행할 수 있다.


== 게임 화면 내에서 랭킹 진입 성공과 실패 시 결과 화면 ==


 * 랭킹 진입 성공 화면

 * 닉네임을 작성하고 Save 버튼을 누르면 랭킹화면으로 넘어가서 랭킹을 확인할 수 있다. 


http://comp166-koreauniv.googlecode.com/files/성공화면.png



 * 랭킹 진입 실패 화면

 * 실패 화면을 누르면 메인 화면으로 넘어간다.


http://comp166-koreauniv.googlecode.com/files/실패화면.png


= 패키지와 클래스 그리고 레이아웃 =


 * 패키지와 클래스


http://comp166-koreauniv.googlecode.com/files/패키지클래스.png


 패키지는 게임 화면을 구성하는 클래스들이 담긴 기본 패키지, 게임 화면 내의 동작과 관련된 패키지, 그리고 그 밖의 기능을 담당하는 유틸리티 패키지로 구성되어 있다.


 * res 폴더 내의 구성

http://comp166-koreauniv.googlecode.com/files/리쏘쓰.png


 * 제일 위에 보이는 anim 폴더는 메인 로고의 동작을 정의해주는 xml 파일이 들어 있다.

 * drawable-xhdpi 내에 어플리케이션 내과 관련된 이미지들을 모두 저장하였다.

 * layout 폴더 내에는 기본 패키지내의 클래스를 구성하는 화면에 대한 xml 파일이 들어 있다.

 * 마지막으로 raw 폴더에는 BGM으로 재생되는 음악 파일이 담겨 있다.


= 각 클래스에 대한 설명(구성과 출처) =


== 게임 클래스 ==
{{{

package com.example.matchinggame;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.TextView;

import com.example.matchinggame.game.CardManager;
import com.example.matchinggame.game.GameManager;
import com.example.matchinggame.game.GenerateRandom;
import com.example.matchinggame.game.TimeManager;
import com.example.matchinggame.utils.ManagerPreference;
import com.example.matchinggame.utils.ManagerSound;

public class GameActivity extends Activity implements OnClickListener{
	public static final String mPackage="com.example.matchinggame";
	public static final int CARD_SIZE=16;
	
	public CardManager[] Card; 
	
	public static final int IN_GAME=1; // 현재 게임의 진행 상태를 나타내는 변수들
	public static final int PAUSE_GAME=2;
	public static final int FINISH_GAME=3;
	public static final int TIME_INTERVEL=90; // 시간 정보 호출 간격
	public int NowGameStatus;
	
	
	TimeManager tm;
	TextView tv_time;

	public static final int MSG_FIRST_CARD_TURN=0; // 맨 처음 게임 시작 시 카드들을 전체적으로 보여주기 위한 변수
	public static final int FIRST_CARD_TURN_TIME=1500; // 카드 넘어가는데 걸리는 시간으로 보여주는 시간을 설정 : 1.5초
	public static final int MSG_TURN_CARD=1; // 게임 진행 과정에서의 2장의 카드가 서로 다른 경우 뒤집기 위한 변수
	public static final int TURN_CARD_TIME=1500;
	
	GameManager GM;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_game);
		
		mInitLayout(); 
		
		tm=new TimeManager();
		GM=new GameManager();
		
		NowGameStatus=IN_GAME;
		tm.startGame();
		
		mTimeHandler.sendEmptyMessageDelayed(NowGameStatus, TIME_INTERVEL);
		mGameHandler.sendEmptyMessageDelayed(MSG_FIRST_CARD_TURN, FIRST_CARD_TURN_TIME);
		
		findViewById(R.id.restart_btn).setOnClickListener(this);
		findViewById(R.id.pause_btn).setOnClickListener(this);
		findViewById(R.id.resume_btn).setOnClickListener(this);
		findViewById(R.id.resume_btn).setClickable(false);
	}
	
	/**
	 * xml에서 만든 값들을 소스랑 연결시켜주는 부분
	 * onCreate에 들어가면서 바로 실행되는 부분
	 */
	private void mInitLayout(){
		tv_time=(TextView)findViewById(R.id.tv_time);
		
		Card=new CardManager[CARD_SIZE]; 
		int[] randList=GenerateRandom.getRandom(CARD_SIZE); // 카드에 0~7까지의 값을 랜덤하게 생성 
		
		for(int i=0;i<CARD_SIZE;i++){
			
			int resource=0; //카드의 종류에 해당하는 변수
			
			switch (ManagerPreference.getCard()) { //옵션에서 카드를 변경하면 그것을 반영해주는 switch문
			case 0:
				resource=getResources().getIdentifier("card"+randList[i]%(CARD_SIZE/2)+randList[i]%(CARD_SIZE/2)+randList[i]%(CARD_SIZE/2),"drawable",mPackage);
				break; 
			case 1:
				resource=getResources().getIdentifier("card"+randList[i]%(CARD_SIZE/2)+randList[i]%(CARD_SIZE/2),"drawable",mPackage);
				break;
			case 2:
				resource=getResources().getIdentifier("card"+randList[i]%(CARD_SIZE/2),"drawable",mPackage);
				break;
			}
			
			Card[i]=new CardManager(
					i,
					randList[i]%(CARD_SIZE/2), 
					(ImageView)findViewById(getResources().getIdentifier("btn"+i,"id",mPackage)),
					resource);
			
			Card[i].getImageView().setOnClickListener(this);
			
			Card[i].setImage(true); // 처음에는 모든 카드가 앞면(가리개 카드)으로 나온다.
		}
		
	}
	@Override
	public void onResume(){
		super.onResume();
		NowGameStatus=IN_GAME;
		if(ManagerPreference.getSound()){
            ManagerSound.playSound(this);
        }
	}
	@Override
	public void onPause(){
		super.onPause();
		NowGameStatus=PAUSE_GAME;
		ManagerSound.pauseSound();
	}
	
	/**
	 * 게임에서 필요한 핸들러로
	 * 카드를 뒤집는 동작을 제어한다.
	 */
	Handler mGameHandler=new Handler(){
		@Override
		public void handleMessage(Message msg){
			switch (msg.what) {
			case MSG_FIRST_CARD_TURN:
				for(int i=0;i<CARD_SIZE;i++){
					Card[i].setImage(false); // 모두 뒤집어서 뒷면을 전부 보여줌.
				}
				break;
			case MSG_TURN_CARD:
				Card[GM.getTurnCardNum()[0]].setImage(false); // 터치시 카드가 넘어가는 효과
				Card[GM.getTurnCardNum()[1]].setImage(false);
				GM.canTouchCard();
				break;
			
			}
		}
	};
	/**
	 * 시간관련 부분을 제어하는 함수
	 * handleMessage에서 
	 * IN_GAME일 때,
	 * 재귀되는 내용을 받는다.
	 */
	Handler mTimeHandler=new Handler(){
		
		@Override
		public void handleMessage(Message msg){
			switch (msg.what) {
			case IN_GAME:
				tv_time.setText(tm.getNowTime());
				mTimeHandler.sendEmptyMessageDelayed(NowGameStatus, TIME_INTERVEL);
				
				break;
			case PAUSE_GAME:
				
				break;
			case FINISH_GAME:
				setResult();
				break;
			default:
			}
		}
	};

	/**
	 * 게임이 끝나면 출력되는 결과 메소드
	 * 기록이 랭킹 안에 들면 랭킹 작성 화면 출력
	 * 그렇지 않으면 게임 종료 화면 출력
	 * */
	public void setResult(){
		
		final float nowTime=Float.parseFloat(tv_time.getText().toString()); //게임의 시간 기록에 해당하는 변수
		
		if(ManagerPreference.isInRanking(nowTime)){ 
			
			findViewById(R.id.rl_result).setVisibility(View.VISIBLE); //게임 끝남과 동시에 결과 화면을 보여줌.
			
			findViewById(R.id.btn_save).setOnClickListener(new OnClickListener() {
				// save 버튼과 관련된 동작
				@Override
				public void onClick(View v) {
					// TODO Auto-generated method stub
					EditText et=(EditText)findViewById(R.id.et_name);
					ManagerPreference.setRank(et.getText().toString(), nowTime);
					Intent intent4 = new Intent(GameActivity.this,RankingActivity.class);
					startActivity(intent4);
				}
			});
			
		}else{
			findViewById(R.id.rl_result_no).setVisibility(View.VISIBLE);
			findViewById(R.id.btn_close).setOnClickListener(new OnClickListener() {
				@Override
				public void onClick(View v) {
					// TODO Auto-generated method stub
					finish();
				}
			});
		}
	}
	
	/**
	 * 게임 화면의 버튼들을 눌렀을 경우 
	 * 해당 동작들을 설정해놓은 메소드
	 * */
		@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch (v.getId()) {
		case R.id.restart_btn:
			Intent intent=new Intent(GameActivity.this,GameActivity.class);
			startActivity(intent);
			overridePendingTransition(0, 0);
			finish();
			break;
		case R.id.resume_btn:
			tm.resumeTime();
			NowGameStatus=IN_GAME;
			mTimeHandler.sendEmptyMessageDelayed(NowGameStatus, 0);
			findViewById(R.id.resume_btn).setClickable(false); //resume 혹은 pause 를 두 번 누르지 못하게 설정
			findViewById(R.id.pause_btn).setClickable(true);
			break;
		case R.id.pause_btn:
			tm.pauseTime();
			NowGameStatus=PAUSE_GAME;
			findViewById(R.id.resume_btn).setClickable(true);
			findViewById(R.id.pause_btn).setClickable(false);
			break;

		default: //이 부분에서 게임 중 카드 2개씩만 뒤집기, 2개의 카드가 같은 경우와 다른 경우의 동작, 모두 맞춘 경우의 동작 등을 설정   
			if(NowGameStatus==IN_GAME){
				
				if(GM.canTurnCard()){ //카드를 뒤집을 수 있는 경우 터치한 카드의 정보를 저장
					int nowTouchCardNum=Integer.parseInt(v.getTag().toString());
					int nowTouchCardImageValue=Card[nowTouchCardNum].getValue();
					
					if(Card[nowTouchCardNum].turnCard(true)){ //똑같은 카드 혹은 이미 맞춘 카드를 누른경우 누르지 못하게 하기 위함 
						
						GM.turnCard(nowTouchCardNum,nowTouchCardImageValue);
						
						if(GM.needToReturnCard()){
							mGameHandler.sendEmptyMessageDelayed(MSG_TURN_CARD,TURN_CARD_TIME );

						}
						
						if(GM.isAllCorrect())NowGameStatus=FINISH_GAME;
					}
					
				}
			}
		}
	}
	
	

}
}}}

 * 마지막에 기재된 참고 사이트에서 카드 게임의 논리를 참고했다. 논리만 참고하고 지난 1학기때 배운 C언어의 기본 개념을 최대한 활용하여 구성하였다. 핸드폰을 연결하여 계속해서 게임을 해보면서 동작을 제어하기 위한 변수를 하나씩 추가하면서 동작의 오류를 하나 하나 수정해나갔다.

 * 일단 각 카드는 버튼으로 구성하여 터치를 인식할 수 있게 구성 하였고, 변수를 만들어 mod 계산을 통해 카드 자체를 난수 배열할 수 있는 구조로 짰다. 카드에 대한 정보는 난수 배열을 통해 얻은 수에 따라서 정보를 넘겨주게 하였다.

 *  





 

 