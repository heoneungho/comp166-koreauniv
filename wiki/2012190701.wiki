#summary 2012190701 김근영의 실습 페이지입니다. 네 다음 코드
<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class beersong
{

        public static void main (String[] args)
        {

                int beerNum = 99; //맥주의 개수 99
                String word = "bottles"; //복수형

                while ( beerNum > 0)//맥주의 개수가 0보다 클때까지 while순환문을돌림
                {
                       
                System.out.println(beerNum + " " + word + " of beer on the wall");
                System.out.println(beerNum + " " + word + " of beer.");
                System.out.println("Take on down.");
                System.out.println("Pass it around.");
                        //출력문입니다.         

                beerNum = beerNum - 1;//beerNum을 1개 감소시킨 후 저장합니다
                 if(beerNum == 1)//맥주의 개수가 1이면
                 word = "bottle";//단수형(한 병인 경우)if 문의 위치를 바꾸어주어서 맥주가 1개일때 복수로 출력되는것 방지


                if(beerNum > 0)//beerNum이 0보다 크면
                {
                        System.out.println(beerNum + " " + word + " of beer on the wall");
                }
                else
                {
                        System.out.println("No more bottles of beer on the wall");
                }//else 문 끝
                }//while 순환문 끝
        } //main 클래스 끝
}//클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class phraseomatic
{
        public static void main (String[] args)
        {
                //세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
                String[] wordListOne = {"Feel","He","You","Face"};

                String[] wordListTwo = {"So","Are","Arn't","Is"};

                String[] wordListThree = {"Good","Bad","Colorful","Fantastic"};

                //각 단어 목록에 단어가 몇 개씩 들어있는지 확인합니다.
                int oneLength = wordListOne.length;
                int twoLength = wordListTwo.length;
                int threeLength = wordListThree.length;

                //난수 세 개를 발생시킵니다.
                int rand1 = (int) (Math.random() * oneLength);
                int rand2 = (int) (Math.random() * twoLength);
                int rand3 = (int) (Math.random() * threeLength);

                //이제 구문을 만듭니다.
                String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];
                //구문을 출력합니다
                System.out.println("What we need is a " + phrase);
        }//main 끝
}//class 끝


}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:  컴파일러가 바이트코드로 변환시켜서 자바 가상머신에게 넘겨주면 자바 가상머신은 그것을 실행시킨다.
 * 컴파일러:  코드를 바이트코드로 변환해줌. 이상한 유형의 데이터를 저장하려고 하면 컴파일러가 막아준다.비공개 메소드나 건드려서는 안되는 메소드를 호출하려고 하는 것을 막아준다.


*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
//big x 를 여러번 출력하는 프로그램이에요
public class Exercise1b 
{
	public static void main(String[] args)
	{
		int x = 1; // x = 1 대입
		while ( x < 10)//x 가 10 미만일때까지 계속	
			{
			x++;//x 를 1씩 증가시킨다
			if ( x > 3)//x가 3 보다 크면 출력한다	
				{
				System.out.println("big x");
				break;//반복문을 빠져나간다.
				}
			}
	}
}


//small x 를 여러번 출력하는 코드
public class Exercise2b	//class 명이 없으므로 넣어줍니다
{
	public static void main(String[] args) {
		int x = 5;
		while (x > 1)	{
			x = x - 1;
			if ( x < 3)	{
				System.out.println("small x");
			}
		}
		
	}
}


//small x 를 여러 번 출력하는 프로그램
public class Exercise3b {
	public static void main(String[] args) {//main 이 없기 때문에 main 을 추가해준다.
		int x = 5;
		while (x > 1)	{
			x = x - 1;
			if(x < 3)	{
				System.out.println("small x");
			}
		}
	}

}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트해본다.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: 시간,채널,볼륨
 * 메소드:채널변경,시간이 지나면 텔레비전 끄기,볼륨 줄이기, 볼륨 키우기,녹화하기


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame
{
        Player p1;      //player 변수 4개를 저장하기 위한 인스턴스 변수 네 개
        Player p2;
        Player p3;
        Player p4;

        public void startGame()
        {
                p1 = new Player();
                p2 = new Player();
                p3 = new Player();
                p4 = new Player();//player 객체 네 개를 선언하고 각각을
                                  //player 인스턴수 변수 네 개에 대입한다.

                int guessp1 = 0; //찍은 숫자를 저장해주기 위해 변수를 선언
                int guessp2 = 0;
                int guessp3 = 0;
                int guessp4 = 0;

                boolean p1isRight = false; //정답 여부를 결정하기 위해
                boolean p2isRight = false; //boolean 변수 선언
                boolean p3isRight = false;
                boolean p4isRight = false;

                int targetNumber = (int) (Math.random() * 10);//선수들이 맞출
                                                                //숫자
                System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

                while(true)
                {
                System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.0");

                p1.guess();//각 선수별로 guess 메소드 호출
                p2.guess();
                p3.guess();
                p4.guess();

                guessp1 = p1.number;
                System.out.println("1번 선수가 찍은 숫자: " + guessp1);

                guessp2 = p2.number;
                System.out.println("2번 선수가 찍은 숫자: " + guessp2);

                guessp3 = p3.number;
                System.out.println("3번 선수가 찍은 숫자: " + guessp3);

                guessp4 = p4.number;
                System.out.println("4번 선수가 찍은 숫자: " + guessp4);

                //각 객체의 인스턴수 변수를 접근하여 각 선수가 찍은 숫자를
                //알아낸다

                if ( guessp1 == targetNumber)
                        p1isRight = true;
                if ( guessp2 == targetNumber)
                        p2isRight = true;
                if ( guessp3 == targetNumber)
                        p3isRight = true;
                if ( guessp4 == targetNumber)
                        p4isRight = true;

                //각 선수가 찍은 숫자 중에서 맞춘 숫자가 있는지 확인
                //맞춘 숫자가 있으면 boolean 변수를 true 로 설정

                if ( p1isRight || p2isRight || p3isRight || p4isRight)
                {
                        System.out.println("맞춘 선수가 있습니다.");
                        System.out.println("1번 선수: " + p1isRight);
                        System.out.println("2번 선수: " + p2isRight);
                        System.out.println("3번 선수: " + p3isRight);
                        System.out.println("4번 선수: " + p4isRight);
                        System.out.println("게임 끝.");
                break;
                }
                else
                {
                //아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
                System.out.println("다시 시도해야 합니다.");

                }//if else 순환문 끝
        }//순환문 끝
        }//메소드 끝
}//클래스 끝


public class Player
{
        int number = 0; //찍은 숫자를 저장할 변수

        public void guess()
        {
                number = (int) (Math.random() * 10);
                System.out.println("찍은 숫자: " + number);
        }
}


public class GameLauncher
{
        public static void main(String[] args)
        {
                GuessGame game = new GuessGame();//GuessGame 형 game 객체를 생성한다
                game.startGame();//game객체에서 startGame 을 실행시킨다
        }
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A :
public class TapeDeck 
{

	boolean canRecord = false; //canRecord = false로 세팅
	
	void playTape()//playTape 메소드 생성
	{
		System.out.println("tape playing");		
	}
	
	void recordTape()//recordTape 메소드 생성
	{
		System.out.println("tape recording");
		
	}	

}

public class TapeDeckTestDrive 
{
	public static void main(String[] args) 
	{
		TapeDeck t = new TapeDeck();
		//TapeDeck 타입의 변수 객체t를 만들어줍니다
		t.canRecord = true;//t의 canRecord를 true로
		t.playTape();//t의 playTape메소드 실행
		
		if(t.canRecord == true)
		{
			t.recordTape();
		}
	}
}

B:

public class DVDPlayer
{
	boolean canRecord = false;//canRecord = false로 세팅
	
	void recordDVD()//recordDVD메소드 생성
	{
		System.out.println("DVD recording");
		
	}
	void playDVD()//playDVD메소드 생성
	{
		System.out.println("DVD Playing");
	}
        //playDVD method 를 만들어줍니다
}

public class DVDPlayerTestDrive 
{
	public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();//DVDPlayer형의 새로운 객체 생성
		d.canRecord = true;//d의 canRecord에 true를 넣어줌
		d.playDVD();
		
		if(d.canRecord == true)
		{
			d.recordDVD();
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

 원시변수 : 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어갑니다.

 레퍼런스 변수 : 객체에 대한 레퍼런스가 들어갑니다.

 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
public class Dog {
	
	String name;//String 타입의 변수 name 생성
	
	public static void main(String[] args) {
		
		Dog dog1 = new Dog();//Dog 타입의 객체 dog1생성
		dog1.bark();//dog1이 짖도록 함
		dog1.name = "bart";//dog1의 name에 bart 대입
	
				
		//dog타입의 arraylist를 생성합니다.
		Dog[] myDogs = new Dog[10];
		//0~9까지 객체를 생성합니다
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = dog1;
		int y = 3;
		while(y < 10)//반복문을 통해 객체 생성후 대입
		{
			myDogs[y++] = new Dog();
		}
		
		
		//배열 레퍼런스를 써서 Dog객체에 접근합니다.
                //이름을 지정해줍니다.
		myDogs[0].name = "Fred";
		myDogs[1].name = "Marge";
		myDogs[3].name = "Yoshi";
		myDogs[4].name = "Grand";
		myDogs[5].name = "Season";
		myDogs[6].name = "Hong";
		myDogs[7].name = "SABU";
		myDogs[8].name = "OU";
		myDogs[9].name = "JiRooHae";
		
		//myDogs[2]의 이름
		System.out.print("마지막 개의 이름: ");
		System.out.println(myDogs[2].name);
		
		//이제 순환문을 써서 배열에 들어있는
		//모든 개가 짖도록 합니다.
		int x = 0;//while문 초기 변수
		while(x < myDogs.length)
		{
			myDogs[x].bark();
			x = x + 1;
			
		}
		
			
	}
	
	public void bark()
	{
		System.out.println(name + "");
		
	}
	
	public void eat(){}
	public void chaseCat() {}

}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Books
{
        String title;
        String author;
        //title 과 author 이름의 String 선언

}



class BooksTestDrive
{
        public static void main(String[] args)
        {
                Books[] myBooks = new Books[3];
                //Books 타입의 arraylist 생성
                int x = 0;

                for(;x < 3; x++)
                        myBooks[x] = new Books();
                //Books객체를 생성 후 arraylist에 대입해줍니다

                myBooks[0].title = "The Grappes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java  Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";


                for(x = 0 ; x < 3 ; x++)
                {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                }
                //반복문을 통해서 출력해줍니다.
        }
}


public class Hobbits {

		String name; //name 이름의 String 형성
		
		public static void  main(String[] args) {
			
			Hobbits [] h = new Hobbits[3];//Hobbits 객체를 생성하고 arraylist에 대입
			int z = -1;//초기 z값 지정
			
			while(z < 2)
			{
				z = z + 1;//array 처음의 인덱스가 0이기 때문에 z + 1 을 해주어 0으로 만든다.
				h[z] = new Hobbits();//각각의 list 에 객체 대입
				h[z].name = "bilbo";//h[0]의 이름
				if(z == 1)//h[1]의 이름
					h[z].name = "frodo";
				if(z == 2)//h[2]의 이름
					h[z].name = "sam";
			
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobbit name");
			}
		}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:밥
 * 문제가 된 부분은 어딘가요?:켄트의 메소드에서는 순환문을 돌 때마다 새로운 객체를 레퍼런스 변수 하나에 대입했기 때문에 전에 참조하고 있던 객체는 버림받게 되는 문제가 있었다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 캡슐화를 함으로 인해 인스턴스 변수에 직접적으로 접근하는 것을 방지하여서 부적절한 방법으로 인스턴스 변수를 초기화 하는 것을 방지해준다.

 * 게터와 세터: 정식 명칭은 액세서와 뮤테이터이다. 게터와 세터는 각각 어떤 것을 가져오고 설정하는 역할을 한다. 보통 인스턴스 변수 값에 대해서 그런 작업을 한다. 게터는 게터가 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도로만 쓰인다. 세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰인다.

 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언된다.
지역 변수는 메소드 내에서 선언된다.인스턴스 변수는 초기 값이 모두 o이나 NULL false로 자동으로 초기화된다. 지역 변수에는 기본값이 없어서 지역 변수를 사용하기 전에는 반드시 초기화해야한다.

 
*107p Dog* _실행_

{{{
public class Dog {

	int size;
	String name;
	
	void bark()
	{
		if ( size > 60)//size 가 60보다 크면
		{
			System.out.println("Wooof! Wooof!");//Wooof 하고 짖는다.
			
		}
		else if ( size > 14)//size가 60보다작고 14보다크면
		{
			System.out.println("Ruff! Ruff!");//Ruff하고 짖는다
			
		}
		else//나머지 경우
		{
			System.out.println("Yip! Yip!");//Yip하고 짖는다
		}
	}

}

public class DogTestDrive {

	public static void main(String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		//Dog 객체들을 생성하고 사이즈를 입력한다.

                //1,2,3 순서대로 짖게 한다.		
		one.bark();
		two.bark();
		three.bark();

	}

}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class Clock {

	String name;
	
	void setTime(String t)//세터 메소드를 이용해서 시간을 설정한다.
	{
		time = t;
	}
	
	String getTime()//게터 메소드를 이용해서 시간을 리턴한다.
	{
		return time;
	}

}

public class ClockTestDrive {

	public static void main() {
		
		Clock c = new Clock();
		//Clock 타입의 객체 c 생성
		c.setTime("1245");//세터를 이용해서 시간 설정
		String tod = c.getTime();//게터를 이용해서 리턴값을 받음
		System.out.println("Time: " + tod);
		
	}
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
익스트림 프로그래밍의 법칙
-조금씩,하지만 자주 발표한다.

-사이클을 반복해서 돌리면서 개발한다.

-스펙에 없는 것은 절대 집어넣지 않는다.

-테스트 코드를 먼저 만든다.

-야근은 하지 마라. 항상 정규 일과 시간에만 작업한다.

-기회가 생기는 족족 언제 어디서든 코드를 개선한다.

-모든 테스트를 통과하기 전에는 어떤 것도 발표하지 않는다.

-조금씩 발표하는 것을 기반으로 하여 현실적인 작업 계획을 만든다.

-모든 일을 단순하게 처리한다.

-두 명씩 팀을 편성하고 모든 살마이 대부분의 코드를 알 수 있도록 돌아가면서 작업한다.


 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotCom 
{
	int[] locationCells;//int 형 배열을 선언합니다.
	int numOfHits = 0;//힛 수를 0으로 초기화
	
	public void setLocationCells(int [] locs)
	{
		locationCells = locs;//locationCells 를 입력값으로 설정합니다.
	}
	
	public String checkYourself(String stringGuess)
	{
		int guess = Integer.parseInt(stringGuess);
		//String 타입의 수를 int 형으로 변환해주어 guess에 대입합니다.
		String result = "miss";//결과를 맞추지 못함으로 선언.
		for(int i = 0 ;i < locationCells.length; i++)//반복문
		{
			if(guess == locationCells[i])//만약이 추측한 숫자와 위치의 수가 같으면
			{
				result = "hit";//결과를 맞춤으로 설정하고
				numOfHits++;//맞춘 수를 하나 증가시킵니다.
				break;//반복문을 빠져나옵니다.
			}
		}

	
	if(numOfHits == locationCells.length)//맞춘 개수가 배열의 길이와 같으면
	{
		result = "kill";//결과를 kill로 설정합니다
	}
	System.out.println(result);//결과를 출력합니다.
	return result;//결과를 반환합니다.

	}
}


public class SimpleDotComGame 
{

	public static void main(String[] args) 
	{
		int numOfGuesses = 0;//사용자가 추측한 횟수를 추적하기 위한 변수를 만듭니다.
		GameHelper helper = new GameHelper();//GameHelper 타입의 객체를 만듭니다
		
		SimpleDotCom theDotCom = new SimpleDotCom();//닷컴 객체를 만듭니다.
		int randomNum = (int) (Math.random() * 5);//첫번째 셀 위치를 정할 난수를 발생시킵니다
	
		int[] locations = {randomNum, randomNum + 1,randomNum + 2};
		//처음 셀 위치를 정하는 난수를 통해서 셀 위치 배열을 만듭니다.
		theDotCom.setLocationCells(locations);//닷컴의 위치를 지정합니다.
		boolean isAlive = true;//닷컴이 살아있는지 추적하기 위한 변수입니다.
		
		while(isAlive == true)//닷컴이 살아있다면 계속 실행됩니다.
		{
			String guess = helper.getUserInput("enter a number");//사용자 입력을 받습니다.
			String result = theDotCom.checkYourself(guess);//추측한 값이 맞는지 확인합니다.
			numOfGuesses++;//추측 횟수를 증가시킵니다.
			
			if(result.equals("kill"))//만약에 kill이면 닷컴이 살아있지 않다고 설정합니다.
			{
				isAlive = false;//닷컴이 살아있지 않음
				System.out.println(numOfGuesses + " guesses");//추측한 횟수를 출력합니다.
			}
		}
		
	}

}

import java.io.*;
//가져오기를 선언해줍니다. System.in을 사용하기 위함입니다.

public class GameHelper 
{
	public String getUserInput(String prompt)
	{
		String inputLine = null;
		System.out.println(prompt + " ");
		try
		{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0)
				return null;
			
		}
		catch (IOException e)
		{
			System.out.println("IOException: " + e);
			
		}
		return inputLine;
	}
}


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 한 클래스가 다른 클래스를 상속하는 것을 하위클래스가 상위클래스로부터 상속받는다고 한다. 자바에서는 하위클래스가 상위클래스를 확장한다고 이야기합니다. 상속은 하위클래스가 상위클래스의 멤버를 물려받는 것을 의미합니다. 인스턴스 변수는 오버라이드할 필요가 없기 때문에 하지 않습니다.상위 클래스는 추상적이고 하위 클래스는 조금 더 구체적입니다.


 * 다형성:     여러가지 형태의 변수들이나 객체를 하나의 배열같은 것 안에서 나타낼 수 있다. 부모의 레퍼런스 변수가 자식을 가리키도록 하는 것이 다형성이다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이딩은 하위클래스에서 메소드의 역할을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것이다.인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 한다. 메소드를 더 접근하기 어렵게 만들면 안 된다.


 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것입니다.리턴 유형이 달라도 된다. 리턴 유형만 바꿀 수는 없다. 접근 단계를 마음대로 바꿀 수는 없다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 인터페이스는 곧 추상 클래스 입니다.
 
 * 다형성: 다형성은 여러 형태를 의미합니다.

 * 추상 클래스: 추상클래스는 abstract 을 앞에 붙임으로써 만들 수 있다. 추상 클래스는 반드시 확장해야만 하는 클래스이다.
 
 * 추상 메소드: 추상 메소드는 반드시 오버라이드해야만 하는 메소드이다. 추상메소드를 만들 때에는 클래스도 반드시 추상 클래스로 만들어야 한다. 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없다.
 
 * 다중 상속: 상위 크랠스를 두 개 사용하는 접근법이다. 

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객체가 사는 곳인데 인스턴스 변수는 객체 안에 삽니다. 그러므로 인스턴스 변수는 힙 안에서 삽니다.

 * 스택에서의 변수: 스택은 메소드가 호출되면 쌓이는 곳입니다 그리고 그 안에서는 지역 변수가 삽니다. 지역 변수로 들어있는 객체는 리모컨만 스택에 들어갑니다. 객체 자체는 힙 안에 있습니다.

 * 생성자: 생성자에는 객체를 생성할 때 실행되는 코드가 들어있습니다. 즉, 어떤 클래스 유형에 대해 new 키워드를 사용했을 때 실행되는 코드가 들어있죠. 사용자가 직접 생성자를 만들지 않아도 자바에서는 알아서 default 생성자를 생성해줍니다.

 * 널 레퍼런스: NULL 레퍼런스를 설정하면 리모컨의 기능을 해제하는 것과 같다. 널 레퍼런스에는 널(아무것도 없음)을 나타내는 비트들이 들어있다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 인스턴수 변수는 객체 내애서 산다. 객체는 힙 안에서 살고 있다. 인스턴스 변수는 객체의 상태를 저장하는 변수이다. 객체가 가비지 컬렉터에 의해 처리된다면 인스턴스 변수도 없어지고 만다.

 * 지역 변수: 지역 변수는 인스턴스 변수에 비해서 수명이 짧다. 지역 변수는 자신의 프레임이 스택 맨 위로 올라갈 때 까지 아무것도 하지 않는다. 인스턴스가 변수가 들어있는 객체를 지역 변수에서만 참조할 수도 있다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}