#summary 시간표캘린더
#labels 2013190714김명준

= Introduction =

대학생이라면 누구나 가지고 있는 시간표, 하지만 새로운 일정이 생길때마다 기존의 시간표 사진과 대조하면서 시간표를 짜는것은 불편하기만 합니다. 또한 kutime에서 시간표를 만들고 이를 사진으로 저장하며 핸드폰으로 보내는것 또한 불편합니다. 이러한 점을 개선하기 위하여 시간표와 달력을 한개의 어플로 만들 계획입니다.

= Details =

*기능 1* 캘린더의 기본화면을 시간표처럼 구성,kutime에서의 디자인을 채택

*기능 2* 일정을 짤때 [9월 첫째주 부터 12월 말까지의 월요일 1교시]같이 일정을 만들 수 있어 시간표 같은 캘린더를 만듬

*기능 3* 힘들겠지만 가능하다면 kutime과의 연동하여 자동으로 시간표를 받음

*기능 4* 시간표 마다 색을 지정할 수 있게 하여 중요한일과 덜중요한일 등등을 구분 할 수 있게 함
고대생이 사용하는 시간표
http://comp166-koreauniv.googlecode.com/files/2%EC%B0%A8%20-%20%EB%B3%B5%EC%82%AC%EB%B3%B8.JPG

이 시간표를 깔끔하게 하여 기본 ui를 만들고
http://comp166-koreauniv.googlecode.com/files/%EA%B8%B0%EB%B3%B8%20%ED%8F%AC%EB%A7%B7.png

이런식으로 시간표 말고도 일정을 만들수도 있음
http://comp166-koreauniv.googlecode.com/files/%EC%A0%9C%EB%AA%A9%20%EC%97%86%EC%9D%8C.png

=소스코드=

저는 이번 텀과제를 하면서 만든 모든 소스는 제가 직접 코드하나하나 써가면서 공부하고 모르는것은 질문하면서 하였는데요.
공부한 책은 교수님이 추천해주신

Do it안드로이드 프로그래밍이라는 책과

안드로이드 프로그래밍 정복 1,2입니다.

출처랄것까지는 없겠지만 책을보면서 공부했기때문에 출처는 책이 되겠네요.

저도 처음에는 너무 힘들어서 다른애들처럼 배낄까도 생각해봣는데 한번해보니까 그대로 복사 붙여넣기 하면 전체에서 오류가 뜨고 오류를 하나하나 지우려해도 결국은 다시 써야하더군요. 그리고 복사를 하게되면 gen폴더에 있는 R.java라는 데이터공간을 할당해주는 클래스파일이 있는것같은데 이게 바로바로 반응을 해주지 않더군요. 그렇다고 제가 직접 데이터를 할당해준다고하면 치명적인 오류가 뜰수있을것 같아서 무섭고도해서 그냥 공부하는겸 해서 직접 책을보면서 하였습니다.

=클래스 소개=

https://comp166-koreauniv.googlecode.com/files/%E3%85%87%E3%85%87.png

제 캘린더에 사용되는 클래스는 그리드뷰와 리스트뷰를 사용합니다.

그리드뷰와 리스트뷰에대한 설명은 밑에서 하기로 하겠습니다.

이 두가지 뷰의 특성상 많은 클래스를 사용하게 됩니다.

그리고 캘린더의 정보를 저장할 전역 객체로 사용되는 Schedule클래스가 존재합니다.

*1.메인클래스*

https://comp166-koreauniv.googlecode.com/files/%E3%85%81%E3%84%B7.png

https://comp166-koreauniv.googlecode.com/files/%E3%85%81%E3%85%81.png

그림을 보면 메인클래스에서 많은 전역 변수들을 사용하고 있는데요.

캘린더를 사용하는 메인클래스의 특성상 많은 정보들이 오가고 그리드뷰를 사용하는 캘린더 객체를 만들어야하는 특성상 많은 전역 변수들을 사용하게 되었습니다.

{{{

package com.example.hi;

import java.util.ArrayList;
import java.util.Calendar;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.Button;
import android.widget.GridView;
import android.widget.TextView;
import android.widget.Toast;

import android.util.Log;

public class MainActivity extends Activity implements OnItemClickListener,
		OnClickListener {
	public int pos;
	public int y;
	public int m;
	public String d;
	public static int p1 = -1;
	public static int y1;
	public static int m1;
	public static String d1;
	public static int SUNDAY = 1;
	public static int MONDAT = 2;
	public static int TUESDAY = 3;
	public static int WEDNSETAY = 4;
	public static int THURSDAY = 5;
	public static int FRIDAY = 6;
	public static int SATURDAY = 7;

	private TextView CalendarTitle;
	private GridView mGvCalendar;

	private ArrayList<DayInfo> mDayList;
	private CalendarAdapter mCalendarAdapter;
	Calendar mLastMonthCalendar;
	Calendar ThisMonth;
	Calendar mNextMonthCalendar;
/*onCreate메소드는 이 클래스가 실행되었을때 바로 실행되는 메소드를 말합니다. 초기
에 필요한 값들을 초기화시켜주고 레이아웃을 설정해줍니다. 이때 잘못설정하면 앱이 실
행되지 않습니다.*/
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Intent intent3 = getIntent();
		p1 = intent3.getIntExtra("pos", -1);
		d1 = intent3.getStringExtra("d");
		y1 = intent3.getIntExtra("y", 0);
		m1 = intent3.getIntExtra("m", 0);
/*p1=-1이라는 뜻은 p1이 초기화되고 한번도 사용되지 않은상태를 말하는것으로 맨처음
클래스가 실행될때를 뜻합니다. 그때에 전역 객체 클래스인 ScheduleList의 Load를 실행
하여 객체를 생성합니다.*/
		if (p1 == -1) {
			ScheduleList.Load();
		}

		pos = p1;
		d = d1;
		y = y1;
		m = m1;

		Button bLastMonth = (Button) findViewById(R.id.b_last);
		Button bNextMonth = (Button) findViewById(R.id.b_next);

		CalendarTitle = (TextView) findViewById(R.id.tv_title);
		CalendarTitle.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				Intent intent = new Intent(getBaseContext(), List.class);
				intent.putExtra("pos", pos);
				intent.putExtra("d", d);
				intent.putExtra("y", y);
				intent.putExtra("m", m);
				startActivity(intent);
			}

		});
		mGvCalendar = (GridView) findViewById(R.id.gv_calendar);

		bLastMonth.setOnClickListener(this);
		bNextMonth.setOnClickListener(this);
		mGvCalendar.setOnItemClickListener(this);
		mDayList = new ArrayList<DayInfo>();
	}
/*onResume메소드는 onCreate메소드와 유사합니다. 앞의 메소드는 새롭게 실행할때 사용
되는 메소드라면 뒤의 메소드는 이 메소드를 만들어주면 onCreate가 실행된후 다시 해당
클래스에 접근을 하게되면 onCreate가 아닌 onResume메소드가 실행됩니다.*/
	protected void onResume() {
		super.onResume();
/*이 메소드의 기능은 다른 액티비티에 들어가서 기존의 사라진 그리드뷰의 포맷을 다시
지정해주는 역할을 합니다.*/
		ThisMonth = Calendar.getInstance();
		ThisMonth.set(Calendar.DAY_OF_MONTH, 1);
		getCalendar(ThisMonth);
	}


/*가장 긴 메소드인 getCalendar입니다.
getCalendar의 중요한 목적은 그리드뷰에 Calendar객체를 보여주기 위함입니다.
return값이 Calendar가 아닌 이유는 이 메소드로 새로운 객체를 생성하는것이 아니라  
받은 Calendar객체를 그리드뷰에 생성하기 위함이기 때문입니다.*/
	private void getCalendar(Calendar calendar) {
		int lastMonthStartDay;
		int dayOfMonth;
		int thisMonthLastDay;

		mDayList.clear();

		dayOfMonth = calendar.get(Calendar.DAY_OF_WEEK);
		thisMonthLastDay = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

		calendar.add(Calendar.MONTH, -1);
		Log.e("지난달 마지막일", calendar.get(Calendar.DAY_OF_MONTH) + "");

		lastMonthStartDay = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

		calendar.add(Calendar.MONTH, 1);
		Log.e("이번달 시작일", calendar.get(Calendar.DAY_OF_MONTH) + "");

		if (dayOfMonth == SUNDAY) {
			dayOfMonth += 7;
		}

		lastMonthStartDay -= (dayOfMonth - 1) - 1;
/*캘린더의 타이틀을 바꾸는 메소드를 호출*/
		CalendarTitle.setText(ThisMonth.get(Calendar.YEAR) + "년 "
				+ (ThisMonth.get(Calendar.MONTH) + 1) + "월");

		DayInfo day;

		Log.e("DayOfMOnth", dayOfMonth + "");

		for (int i = 0; i < dayOfMonth - 1; i++) {
			int date = lastMonthStartDay + i;
			day = new DayInfo();
			day.setDay(Integer.toString(date));
			day.setInMonth(false);

			mDayList.add(day);
		}
		for (int i = 1; i <= thisMonthLastDay; i++) {
			day = new DayInfo();
			day.setDay(Integer.toString(i));
			day.setInMonth(true);

			mDayList.add(day);
		}
		for (int i = 1; i < 42 - (thisMonthLastDay + dayOfMonth - 1) + 1; i++) {
			day = new DayInfo();
			day.setDay(Integer.toString(i));
			day.setInMonth(false);
			mDayList.add(day);
		}

		initCalendarAdapter();
	}

/*getLastMonth메소드는 새로운 이전 달 캘린더 객체를 만드는 메소드입니다.
현재의 캘린더 객체를 받아와서 그를 바탕으로 이전 달의 캘린더 객체를 가져옵니다.
그 후 그 객체를 리턴합니다.*/

	private Calendar getLastMonth(Calendar calendar) {
		calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),
				1);
		calendar.add(Calendar.MONTH, -1);
/*캘린더의 타이틀을 바꾸는 메소드를 호출*/
		CalendarTitle.setText(ThisMonth.get(Calendar.YEAR) + "년 "
				+ (ThisMonth.get(Calendar.MONTH) + 1) + "월");
		return calendar;
	}

/*getNextMonth메소드는 새로운 다음달 캘린더 객체를 만드는 메소드입니다.
현재의 캘린더 객체를 받아와서 그를 바탕으로 다음달의 캘린더 객체를 가져옵니다.
그 후 그 객체를 리턴합니다.*/

	private Calendar getNextMonth(Calendar calendar) {
		calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),
				1);
		calendar.add(Calendar.MONTH, +1);
/*캘린더의 타이틀을 바꾸는 메소드를 호출*/
		CalendarTitle.setText(ThisMonth.get(Calendar.YEAR) + "년 "
				+ (ThisMonth.get(Calendar.MONTH) + 1) + "월");
		return calendar;
	}
/*onClick메소드는 화면에 있는 아이템이 클릭되면 실행되는 메소드입니다. 이 메소드에서는 클릭된 정보를 R.java를 통해서 할당한 id정보를 통해서 받아옵니다.*/
	public void onClick(View v) {
		switch (v.getId()) {
		case R.id.b_last:
/*b_last라는 id는 이전 달로 이동하는 버튼입니다. 따라서 현재의 캘린더 객체정보를 받아서 이전 캘린더 객체를 만들고 그를 다시 현재캘린더 객체로 만들어야합니다.*/
			ThisMonth = getLastMonth(ThisMonth);
			getCalendar(ThisMonth);
			break;
		case R.id.b_next:
/*b_next라는 id는 다음 달로 이동하는 버튼입니다. 따라서 현재의 캘린더 객체정보를 받아서 다음 캘린더 객체를 만들고 그를 다시 현재캘린더 객체로 만들어야합니다.*/
			ThisMonth = getNextMonth(ThisMonth);
			getCalendar(ThisMonth);
			break;
		}
	}
/*initCalendarAdapter메소드입니다.
이 메소드에서는 새로운 캘린더 객체를 만들때에 day라는 레이아웃에 새로운 객체들을 
집어넣는 기능을 합니다.*/
	private void initCalendarAdapter() {
		mCalendarAdapter = new CalendarAdapter(this, R.layout.day, mDayList);
		mGvCalendar.setAdapter(mCalendarAdapter);
	}
/*onItemClick메소드는 그리드뷰나 리스트뷰를 사용하는 클래스에서 사용되는 메소드입니다. 
해당 뷰를 통해서 만든 객체가 클릭되었을때 발생하는 이벤트를 정의해주는 메소드로
만들지 않았다면 해당 객체를 클릭하여도 아무런 반응을 주지 않습니다.*/
	public void onItemClick(AdapterView<?> parent, View v, int position,
			long arg3) {
/*게터 메소드를 통해서 해당 정보를 받아옵니다.*/
		DayInfo day = mDayList.get(position);
		String j = day.getDay();
/*토스트를 사용한 이유는 해당날짜가 올바르게 클릭되었는지 확인해주기 위해서입니다.*/
		Toast.makeText(
				this,
				ThisMonth.get(Calendar.YEAR) + "년"
						+ (ThisMonth.get(Calendar.MONTH) + 1) + "월"
						+ j + "일" + position, Toast.LENGTH_LONG).show();
/*클릭을 한후 그 클릭정보를 저장하는 부분입니다.
이 정보는 이 메소드에서만 사용하는것이 아니므로 전역 변수를 사용합니다.*/
		pos = position;
		d = day.getDay();
		y = ThisMonth.get(Calendar.YEAR);
		m = ThisMonth.get(Calendar.MONTH);

	}
/*onOptionsItemSelected메소드는 onCreateOptionMenu를 통해서 만든 메뉴를 클릭했을때 실행되는 메소드입니다.
이 메소드를 만들지 않으면 메뉴를 클릭하여도 아무런 반응이 뜨질 않습니다.*/
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case 1:/*case1은 일이라는 메뉴를 클릭한 결과로 List라는 클래스로 정보를 가지고 intent를 합니다.*/
			Intent intent = new Intent(this, List.class);
			intent.putExtra("pos", pos);
			intent.putExtra("d", d);
			intent.putExtra("y", y);
			intent.putExtra("m", m);
			startActivity(intent);
			break;
		case 2:/*case2는 새로만들기라는 메뉴를 클릭한 결과로 Make라는 클래스로 정보를 가지고 intent를 합니다.*/
			Intent intent1 = new Intent(this, Make.class);
			intent1.putExtra("pos", pos);
			intent1.putExtra("d", d);
			intent1.putExtra("y", y);
			intent1.putExtra("m", m);
			startActivity(intent1);
			break;
		}
		return true;
	}


/*onCreateOptionMenu 메소드는 클래스가 실행될때 메뉴를 생기게하는 메소드입니다.
클래스를 생성하면 기본적으로 생기는 디폴드값인 메소드입니다.
제 앱에서는 2개의 메뉴를 사용하는데 기본적으로 한 화면에 최대 6가지의 메뉴화면을
보일수 있고 그 메뉴마다 또 다른 메뉴를 내포하여 2차원 배열처럼 메뉴를 만들수 있습니다. 
메뉴의 내용은 onOptionsItemSelected라는 메소드를 통해서 실행시킬수 있습니다.*/
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.main, menu);

		menu.add(0, 1, 2, "일");
		menu.add(0, 2, 2, "새로만들기");

		return true;
	}

}


}}}

*2.그리드뷰 클래스*

*3.리스트뷰 클래스*

*4.Make 클래스*

https://comp166-koreauniv.googlecode.com/files/make.png

Make 클래스입니다.

Make 클래스는 이름과 같이 캘린더에서의 일정을 만드는 클래스입니다.

따라서 이 클래스에서는 메인 클래스에서의 정보를 받아와서 이 정보를 가지고 

새로운 일정을 만들고 그 정보를 Schedule객체에 저장합니다. 

{{{

package com.example.hi;

import android.os.Bundle;
import android.app.Activity;
import android.content.Intent;
import android.view.Menu;
import android.view.View;
/*andoid.widget.*라는 것을 import함으로서 얻는 이득으로는 해당 클래스에서 사용되는 
위젯들을 일일히 하나씩 import하지 않아도 됩니다.*/
import android.widget.*;

public class Make extends Activity {
	public static int yy = 10;
	public static int mm = 12;
	public static int dd = 31;
	public static int tt = 24;
	public static int pp = 42;
/*DatePicker,TimePicker,EditText라는 데이터 형은 레이아웃에서 생성할수있는 위젯입니다.
따라서 이를 선언해주어야 해당되는 위젯의 메소드와 기능들을 사용할수 있습니다.*/
	private DatePicker datePicker;
	private TimePicker timePicker;
	private EditText listname;
	private EditText schedule;
	int m;
	int y;
	int pos;
	String d;
	String list;
	String sche;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_make);
		Intent intent = getIntent();
		pos = intent.getIntExtra("pos", 0);
		d = intent.getStringExtra("d");
		y = intent.getIntExtra("y", 0);
		m = intent.getIntExtra("m", 0);
		Button finish = (Button) findViewById(R.id.finish);
		datePicker = (DatePicker) findViewById(R.id.datePicker);
		timePicker = (TimePicker) findViewById(R.id.timePicker);
		listname = (EditText) findViewById(R.id.edittext1);
		schedule = (EditText) findViewById(R.id.editText4);

		timePicker.setIs24HourView(true);
		finish.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {

				Intent intent = new Intent(getBaseContext(), MainActivity.class);

/*Toast를 import한 메소드를 사용하지 않고 새로 메소드를 지정해주어 한 이유는 
onCreate메소드에서는 toast를 사용할수 없다는 에러가 뜨기 때문입니다.*/
				Toast();
				m = datePicker.getMonth();
				y = datePicker.getYear();
				d = datePicker.getDayOfMonth() + "";
				list = listname.getText().toString();
				sche = schedule.getText().toString();
				intent.putExtra("pos", pos);
				intent.putExtra("d", d);
				intent.putExtra("y", y);
				intent.putExtra("m", m);
				intent.putExtra("list", list);
				intent.putExtra("sche", sche);
				ScheduleList.Sch[y - 2013][m][pos].Sch(list,
						timePicker.getCurrentHour(), sche);
				startActivity(intent);

			}
		});
	}
/*Toast메소드는 화면에 메시지를 출력해주는 메소드입니다. 
이 토스트 메소드를 통하여 만든 정보를 출력해주는 기능을 합니다.*/
	public void Toast() {
		Toast.makeText(
				this,
				+datePicker.getYear() + "년 " + (datePicker.getMonth() + 1)
						+ "월 " + datePicker.getDayOfMonth() + " 일 "
						+ timePicker.getCurrentHour() + "시 "
						+ timePicker.getCurrentMinute() + "분의 일정을 만들었습니다.",
				Toast.LENGTH_LONG).show();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.make, menu);
		return true;
	}
}

}}}

*5.전역 객체 클래스 Schedule*

https://comp166-koreauniv.googlecode.com/files/Schedule.png

이 클래스에서는 전역 객체인 ScheduleList를 선언하고 거기서 사용되는 Sch라는 객체의
내용인 Schedule 클래스가 존재한다. 이러한 클래스를 통하여 다른 클래스 모두가 사용 할수있는 개체를 만들수 있다.

{{{

package com.example.hi;

import java.io.Serializable;

/*static의 객체를 선언한 ScheduleList 메소드
이렇게 선언을 해주면 모든 클래스에서 ScheduleList.Sch[][][]을 통하여 전역 객
체에 접근할수 있다.
클래스 전체를 통틀어서 사용해야할 데이터가있다면 일일히 intent하기 보다는 이런식으
로 하는것이 더욱 효과적이다.*/

class ScheduleList {
	public static int yy = 10;
	public static int mm = 12;
	public static int dd = 5;
	public static int tt = 24;
	public static int pp = 42;
	public static String[] title = new String[24];
	public static String[] Message = new String[24];

	public static Schedule[][][] Sch;

/*Load메소드는 딱 한번 실행되는 메소드로 새로운 Sch라는 객체를 생성한다.*/
	public static void Load() {
		Sch = new Schedule[yy][mm][pp];
		for (int yyy = 0; yyy < yy; yyy++) {
			for (int mmm = 0; mmm < mm; mmm++) {
				for (int ppp = 0; ppp < pp; ppp++) {
					for (int ttt = 0; ttt < tt; ttt++) {
						Sch[yyy][mmm][ppp] = new Schedule();
						Sch[yyy][mmm][ppp].Sch("", ttt, "");
					}
				}
			}
		}
	}
}

public class Schedule implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	/**
	 * 
	 */
/*스케쥴은 24시간이 있고 그에대한 타이틀과 내용이 있으므로 이렇게 만듬*/
	public String time;
	private String[] tt = new String[24];
	private String[] me = new String[24];
/*이 객체의 변수를 세팅해주는 세터 메소드의 역할*/
	public void Sch(String title, int time, String message) {
		this.me[time] = message;
		this.tt[time] = title;

	}
/*String의 tt[time]을 return해주는 게터 메소드*/
	public String gettitle(int time) {
		return tt[time];
	}
/*String의 me[time]을 return해주는 게터 메소드*/
	public String getmessage(int time) {
		return me[time];
	}

	public Schedule() {

	}

	

	

}


}}}



=레이아웃 소개=

https://comp166-koreauniv.googlecode.com/files/%E3%84%B4%E3%84%B4.png

레이아웃입니다. 해당 앱에서는 크게 3개의 레이아웃을 사용해서 3개만 존재하면 되지 
않냐고 생각할수 있지만 그리드뷰와 리스트뷰에서 각각 객체에 대한 레이아웃을 사용하
므로 2개씩의 레이아웃을 사용하게 됩니다.

*activity_main.xml*

https://comp166-koreauniv.googlecode.com/files/mainactivity.png

{{{

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
/*2011년 몇월이라고 적혀있는 텍스트뷰 저렇게 적혀있다고 해서 진짜로 저렇게 나오는
것이 아니라 메소드를 통하여 텍스트의 내용이 바뀐다.*/
    <TextView
        android:id="@+id/tv_title"
        android:layout_width="143dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="20dp"
        android:gravity="center"
        android:text="2011년 몇월"
        android:textColor="#000"
        android:textSize="20sp"
        android:textStyle="bold" />
/*대망의 그리드뷰가 생성되는 공간 사진에는 이상하게 나와있지만 클래스를 통해서 객
체가 할당되면 저렇게 나오지 않는다.*/

    <GridView
        android:id="@+id/gv_calendar"
        android:layout_width="320dp"
        android:layout_height="320dp"
        android:layout_marginTop="30dp"
        android:numColumns="7"
        android:stretchMode="columnWidth"/>
         
    <LinearLayout
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:orientation="horizontal"
        android:gravity="center">
/*지난달로 가게하는 버튼*/
        <Button
            android:id="@+id/b_last"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="지난달"  />
/*다음달로 가게하는 버튼*/
        <Button
            android:id="@+id/b_next"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="다음달"  />
         
    </LinearLayout>
</LinearLayout>

}}}