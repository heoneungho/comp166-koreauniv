#summary 이정우의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_


{{{
public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99 ; //beerNum 값을 99로 초기화
		String word = "bottles"; //word를 bottles로 초기화함,복수형

		while (beerNum > 0 ) {
			if(beerNum ==1 ) {
				word = "bottle"; //word를 bottle로 초기화함,단수형(한 병인 경우)
				
}

			System.out.println(beerNum + " " + word + " of beer on the wall") ; //beerNum에 저장된 값 + word에 저장된 글자 + of 이하를 출력

			System.out.println(beerNum + " " + word + " of beer.") ;//beerNum에 저장된 값 + word에 저장된 글자 + of 이하를 출력


			System.out.println("Take one down.");

			System.out.println("Pass it around.");

			beerNum = beerNum - 1 ;//beerNum숫자를 하나 줄임

			if (beerNum > 0 ) {
				//System.out.println(beerNum + " " + word + " of beer on the wall") ;//문장이 겹치므로 주석처리를 하여 해결한다.

			}else{
				System.out.println("No more bottles of beer on the wall");
			}//else문 끝
		}//while문 끝
	}//main 클래스 끝
}//클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String[] args) {
		String[] wordListOne = {"도","레","미","파","솔"} ;

		String[] wordListTwo = {"레미","미파","파솔","솔라","라시"} ;

		String[] wordListThree = {"미파솔","솔라시","라시도","시도레","도레미"} ;

		//각 단어 목록에 단어 몇 개씩 들어있는지 확인		
		int oneLength = wordListOne.length ;
		int twoLength = wordListTwo.length ;
		int threeLength = wordListThree.length ;

		//난수 세 개 발생시킴
		int rand1 = (int) (Math.random() * oneLength) ;
		int rand2 = (int) (Math.random() * twoLength) ;
		int rand3 = (int) (Math.random() * threeLength) ;

		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + wordListThree[rand3];

		System.out.println("What we dneed is a " + phrase) ;
	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행 시킴. ClassCast Exception(에러)수정, 보안관련 작업을 함
 * 컴파일러: 없으면 자바 프로그램 실행 속도가 느려짐. 심각한 오류를 잡아줌. 핵심적인 보안을 담당

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
/* A */

class Exercise1b{
	public static void main(String [] args) {
		int x = 1 ;
		while (x < 10 ) {
			x = x+1 ; // 이 코드가 빠지면 while문이 끝나지 않아서 무한루프

			if ( x > 3 ) {
				System.out.println("big x") ;
			}
		}
	}
}


/* B */

class Exercise2b{ //클래스명을 선언해 주지 않았으므로 선언해 준다.
	public static void main(String [] args) {
		int x = 5 ;
		
		while(x>1){
			x = x - 1 ;
			
			if(x <3 ) {
				System.out.println("small x") ;
			}
		}
	}
}
 
/* C */

class Exercise3b{
	public static void main (String [] args) { //main을 추가
		int x = 5 ;
		while( x > 1) {
			x = x - 1 ;	
			if (x < 3 ) {
				System.out.println("small x") ;
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 청사진. 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 방법을 알려주는 역할을 한다.
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트해보는 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Channel, Volume, Power
 * 메소드: ChannelUpDown(), VolumeUpDown(), PowerOnOff(), ChangeChannelTo()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame{
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0 ;
		int guessp2 = 0 ;
		int guessp3 = 0 ;
		int guessp4 = 0 ;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random()*10);
		System.out.println("0 이상 9이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝");
				break;
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

public class Player{
	int number = 0 ;
	
	public void guess(){
		number = (int) (Math.random()*10);
		System.out.println("찍은 숫자: " + number);
			}
}

public class GmaeLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}


}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
public class TapeDeck {

	boolean canRecord = false;
    
    void playTape() {
            System.out.println("tape playing");
    }
    
    void recordTape() {
            System.out.println("tape recording");
    }
}

class TapeDeckTestDrive {
    public static void main(String [] args) {
    
            TapeDeck t = new TapeDeck(); //t라는 TapeDeck 객체 선언

            t.canRecord = true;
            t.playTape();
            
            if(t.canRecord == true ) {
                    t.recordTape();
                    }
            }
}
B
public class DVDPlayer {
        
        boolean canRecord = false ;
        
        void recordDVD() {
                System.out.println("DVD recording");
        }
        void playDVD() {//playDVD메소드 선언
                System.out.println("DVD playing");

        }
}
public class DVDPlayerTestDrive {
        public static void main(String [] args) {
        
        DVDPlayer d = new DVDPlayer ();
        d.canRecord = true;
        d.playDVD ();
        
        if(d.canRecord == true) {
                d.recordDVD();
                }
        }
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 
원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값<sub>단순한 비트 패턴으로 나타낼 수 있는 값</sub>이 들어감

레퍼런스변수는 힙에 들어있는 객체를 건드릴 수 있는 방법을 나타내는 비트이다. 즉 리모컨처럼 다른 객체를 제어할 수 있다.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
String name;
public static void main (String[] args){
	//Dog 객체를 만들고 접근
	Dog dog1 = new Dog();
	dog1.bark();
	dog1.name="밥줘";
	
	//이번에는 Dog 배열을 만듭니다.
	Dog[] myDogs = new Dog[3];
	//그리고 멍멍이를 몇 마리 집어 넣습니다.
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;
	
	//배열 레퍼런스를 써서 Dog객체에 접근합니다.
	myDogs[0].name = "밥달라고";
	myDogs[1].name = "배고파";
	
	//myDogs[2]의 이름이 뭐였니?
	System.out.print("마지막 개의 이름 : ");
	System.out.println(myDogs[2].name);
	
	//이제 순환문을 써서 배열에 들어있는 모든 멍멍이가 짖도록 합시다.
	int x = 0 ;
	while(x < myDogs.length){
		myDogs[x].bark();
		x = x + 1 ;
			}
 		}

public void bark() {
	System.out.println(name + "이(가) 바바바바바밥! 하고 짖습니다.");
}
public void eat(){}
public void chaseCat(){}
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
97p 컴파일러가 되어봅시다 구현후 주석달기 
A
class Books {
        String title ;
        String author ;
}

class BooksTestDrive {
        public static void main(String [] args) {
        
                Books [] myBooks = new Books[3] ;
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books(); //객체 생성
                int x = 0;
                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";
        
                while(x<3) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}

B
class Hobbits {
        
        String name ;
        
        public static void main(String [] args) {
        
                Hobbits [] h = new Hobbits[3];
                int z = 0 ;

                while(z<3) {//z<4일 이유가 없으므로 z<3으로 변경
        
                        h[z] = new Hobbits();
                        h[z].name = "bilbo";
                        if(z==1) {
                                h[z].name = "frodo";
                        }
                        if(z==2) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.println("good Hobbit name");
                        z=z+1;//맨앞에 있으면 0번째가 의미가 없으므로 맨 밑으로 내림
                }
        }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 절약할 수 있다. 그러나 순환문을 돌때마다 변수에 다른 값이 들어가기 때문에 전에 저장했던 값이 없어지는 결과를 얻게 되는 문제를 발생시킨다. 

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 캡슐화 하지 않으면 웃음거리가 되기 쉬우니까 private를 사용해 노출 되어 있는 변수를 보호함. 
 * 게터와 세터: 게터 - 정식명칭은 액세서, 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도, 세터 -정식명칭은 뮤테이터, 설정할 값을 인자로 받아서 인스턴트 변수를 그 값으로 설정하기 위한 용도
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수 - 클래스 내에서 선언, 지역 변수 - 매소드 내에서 선언, 사용 전 반드시 초기화
 
*107p Dog* _실행_

{{{

public class Dog {
	int size;
	String name;
	
	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof!");
		}else if (size > 14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}
}

Class DogTestDrive{
	public static void main (String[] args){
		Dog one = new Dog ();
		one.size = 70;
		Dog two = new Dog ();
		two.size = 8;
		Dog three = new Dog () ;
		three.size = 35 ;
		
		one.bark();
		two.bark();
		three.bark();
	}
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
/* A */
public class XCopy {
	public static void main(String [] args){

		int orig = 42;
		
		XCopy x = new XCopy();
		
		int y = x.go(orig); //x에서 go 호출 go에 orig값을 보낸 후 y에 그 값을 리턴
		
		System.out.println(orig + " " + y);
	}
	int go(int arg) {
		
		arg = arg * 2 ;
		
		return arg;
		
	}//출력값은 42 84

}

/* B */


public class Clock {
	
	String time;
	
	void setTime(String t){
		time = t ;
		
	}
	
	String getTime(){//getTime은 게터이고 리턴 받을 time이 string 이므로 getTime을 void가 아닌 String으로 설정 해 주어야 한다.
		return time;
	}
}


public class ClockTestDrive {
	public static void main(String [] args){
		
		Clock c = new Clock();
		
		c.setTime("12345");
		String tod = c.getTime();
		System.out.println("time: " + tod);
	}
}//출력 time: 12345




}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 
    최근의 소프트웨어 개발 방법론 분야에 새로 등장.

    최근에는 높은 사람들을 위한 방법론이다.
 
    테스트를 많이 만드는 것은 xp패러다임에 따른 것이다.

    많은 사람들이 "프로그래머들이 정말 원하는 방법"이라고 함. 


    90년대 말에 등장


     가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공 할 수 있다는 점임.


    규칙 중에 야근은 하지 마라는 아주 좋은 규칙이 있음.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0 ;
	
	public void setLocationCells (int[] locs){
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess){//배열이 맞았나 체크
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0 ; i < locationCells.length; i++){
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}//순환문 끝
		
		if (numOfHits == locationCells.length){
			result = "kill";//다 맞추면 kill이라고 나타나게 함
	 	}
		System.out.println(result) ;
			return result ;
	}//메소드 끝
}//클래스 끝


public class SimpleDotComGame {

	public static void main(String[] args) {
		int numOfGuesses = 0 ; //사용자가 추측한 횟수를 추적하기 위한 변수
		GameHelper helper = new GameHelper();//일단 사용자로부터 입력을 받기 위한 메소드가 들어있는 특별한 클래스가 있다고 생각
		
		SimpleDotCom theDotCom = new SimpleDotCom(); //닷컴 객체 생성
		
		int randomNum = (int)(Math.random()*5);//첫번째 셀 위치를 정하기 위한 난수를 생성하고 그 값을 써서 셀 위치 배열을 만듦
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};//첫번째 셀 위치를 정하기 위한 난수를 생성하고 그 값을 써서 셀 위치 배열을 만듦
		theDotCom.setLocationCells(locations);//닷컴의 위치를 지정(배열사용)
		boolean isAlive = true ;//닷컴이 살아있는지 추적하기 위한 부울 변수를 만듦
		
		while (isAlive == true){//살아 있으면 반복
			String guess = helper.getUserInput("enter a number");//사용자가 입력한 string을 받아옴
			
			String result = theDotCom.checkYourself(guess);
			//닷컴 객체를 통해 추측한 값이 맞는지 확인. 리턴된 결과는 string에 저장
			numOfGuesses++;
			//추측횟수 증가
			if (result.equals("kill")){//kill이면 isAlive를 false로 설정 ->순환문 탈출
				isAlive = false ;
				
				System.out.println(numOfGuesses + "guesses");
			}//if 문 끝
		}//while문 끝
	}//main 끝
}//클래스 끝

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null ;
		System.out.print(prompt + " ") ;
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length()== 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}
//마지막 클래스인 gamehelper는 책에서 그냥 그대로 입력하라고 나옴. 

//결과
enter a number 3
miss
enter a number 5
hit
enter a number 1
miss
enter a number 2
miss
enter a number 3
miss
enter a number 4
hit
enter a number 5
kill
7guesses

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:

 인스턴스를 만들 수 없는 클래스

 반드시 확장해야 함

 추상 유형을 레퍼런스로 사용할 수는 있음

 다형적인 인자, 리턴 유형, 배열 등에 활용

 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}