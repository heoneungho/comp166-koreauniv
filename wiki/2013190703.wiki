#summary 이정우의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_


{{{
public class BeerSong {
	public static void main (String[] args) {
		int beerNum = 99 ; //beerNum 값을 99로 초기화
		String word = "bottles"; //word를 bottles로 초기화함,복수형

		while (beerNum > 0 ) {
			if(beerNum ==1 ) {
				word = "bottle"; //word를 bottle로 초기화함,단수형(한 병인 경우)
				
}

			System.out.println(beerNum + " " + word + " of beer on the wall") ; //beerNum에 저장된 값 + word에 저장된 글자 + of 이하를 출력

			System.out.println(beerNum + " " + word + " of beer.") ;//beerNum에 저장된 값 + word에 저장된 글자 + of 이하를 출력


			System.out.println("Take one down.");

			System.out.println("Pass it around.");

			beerNum = beerNum - 1 ;//beerNum숫자를 하나 줄임

			if (beerNum > 0 ) {
				//System.out.println(beerNum + " " + word + " of beer on the wall") ;//문장이 겹치므로 주석처리를 하여 해결한다.

			}else{
				System.out.println("No more bottles of beer on the wall");
			}//else문 끝
		}//while문 끝
	}//main 클래스 끝
}//클래스 끝
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String[] args) {
		String[] wordListOne = {"도","레","미","파","솔"} ;

		String[] wordListTwo = {"레미","미파","파솔","솔라","라시"} ;

		String[] wordListThree = {"미파솔","솔라시","라시도","시도레","도레미"} ;

		//각 단어 목록에 단어 몇 개씩 들어있는지 확인		
		int oneLength = wordListOne.length ;
		int twoLength = wordListTwo.length ;
		int threeLength = wordListThree.length ;

		//난수 세 개 발생시킴
		int rand1 = (int) (Math.random() * oneLength) ;
		int rand2 = (int) (Math.random() * twoLength) ;
		int rand3 = (int) (Math.random() * threeLength) ;

		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + wordListThree[rand3];

		System.out.println("What we dneed is a " + phrase) ;
	}
}
}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행 시킴. ClassCast Exception(에러)수정, 보안관련 작업을 함
 * 컴파일러: 없으면 자바 프로그램 실행 속도가 느려짐. 심각한 오류를 잡아줌. 핵심적인 보안을 담당

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
/* A */

class Exercise1b{
	public static void main(String [] args) {
		int x = 1 ;
		while (x < 10 ) {
			x = x+1 ; // 이 코드가 빠지면 while문이 끝나지 않아서 무한루프

			if ( x > 3 ) {
				System.out.println("big x") ;
			}
		}
	}
}


/* B */

class Exercise2b{ //클래스명을 선언해 주지 않았으므로 선언해 준다.
	public static void main(String [] args) {
		int x = 5 ;
		
		while(x>1){
			x = x - 1 ;
			
			if(x <3 ) {
				System.out.println("small x") ;
			}
		}
	}
}
 
/* C */

class Exercise3b{
	public static void main (String [] args) { //main을 추가
		int x = 5 ;
		while( x > 1) {
			x = x - 1 ;	
			if (x < 3 ) {
				System.out.println("small x") ;
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것
 * 메소드: 객체에서 자신이 하는 것
 * 클래스: 객체를 만들기 위한 청사진. 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 방법을 알려주는 역할을 한다.
 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어있는 메소드와 변수를 테스트해보는 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: Channel, Volume, Power
 * 메소드: ChannelUpDown(), VolumeUpDown(), PowerOnOff(), ChangeChannelTo()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame{
	Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0 ;
		int guessp2 = 0 ;
		int guessp3 = 0 ;
		int guessp4 = 0 ;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random()*10);
		System.out.println("0 이상 9이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if (guessp1 == targetNumber) {
				p1isRight = true;
			}
			
			if (guessp2 == targetNumber) {
				p2isRight = true;
			}
			
			if (guessp3 == targetNumber) {
				p3isRight = true;
			}
			
			if (guessp4 == targetNumber) {
				p4isRight = true;
			}
			
			if (p1isRight || p2isRight || p3isRight || p4isRight) {
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝");
				break;
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
		}
	}
}

public class Player{
	int number = 0 ;
	
	public void guess(){
		number = (int) (Math.random()*10);
		System.out.println("찍은 숫자: " + number);
			}
}

public class GmaeLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}


}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
public class TapeDeck {

	boolean canRecord = false;
    
    void playTape() {
            System.out.println("tape playing");
    }
    
    void recordTape() {
            System.out.println("tape recording");
    }
}

class TapeDeckTestDrive {
    public static void main(String [] args) {
    
            TapeDeck t = new TapeDeck(); //t라는 TapeDeck 객체 선언

            t.canRecord = true;
            t.playTape();
            
            if(t.canRecord == true ) {
                    t.recordTape();
                    }
            }
}
B
public class DVDPlayer {
        
        boolean canRecord = false ;
        
        void recordDVD() {
                System.out.println("DVD recording");
        }
        void playDVD() {//playDVD메소드 선언
                System.out.println("DVD playing");

        }
}
public class DVDPlayerTestDrive {
        public static void main(String [] args) {
        
        DVDPlayer d = new DVDPlayer ();
        d.canRecord = true;
        d.playDVD ();
        
        if(d.canRecord == true) {
                d.recordDVD();
                }
        }
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 
원시 변수에는 정수, 부울, 부동소수점 수와 같은 기초적인 값<sub>단순한 비트 패턴으로 나타낼 수 있는 값</sub>이 들어감

레퍼런스변수는 힙에 들어있는 객체를 건드릴 수 있는 방법을 나타내는 비트이다. 즉 리모컨처럼 다른 객체를 제어할 수 있다.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
String name;
public static void main (String[] args){
	//Dog 객체를 만들고 접근
	Dog dog1 = new Dog();
	dog1.bark();
	dog1.name="밥줘";
	
	//이번에는 Dog 배열을 만듭니다.
	Dog[] myDogs = new Dog[3];
	//그리고 멍멍이를 몇 마리 집어 넣습니다.
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;
	
	//배열 레퍼런스를 써서 Dog객체에 접근합니다.
	myDogs[0].name = "밥달라고";
	myDogs[1].name = "배고파";
	
	//myDogs[2]의 이름이 뭐였니?
	System.out.print("마지막 개의 이름 : ");
	System.out.println(myDogs[2].name);
	
	//이제 순환문을 써서 배열에 들어있는 모든 멍멍이가 짖도록 합시다.
	int x = 0 ;
	while(x < myDogs.length){
		myDogs[x].bark();
		x = x + 1 ;
			}
 		}

public void bark() {
	System.out.println(name + "이(가) 바바바바바밥! 하고 짖습니다.");
}
public void eat(){}
public void chaseCat(){}
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
97p 컴파일러가 되어봅시다 구현후 주석달기 
A
class Books {
        String title ;
        String author ;
}

class BooksTestDrive {
        public static void main(String [] args) {
        
                Books [] myBooks = new Books[3] ;
                myBooks[0] = new Books();
                myBooks[1] = new Books();
                myBooks[2] = new Books(); //객체 생성
                int x = 0;
                myBooks[0].title = "The Grapes of Java";
                myBooks[1].title = "The Java Gatsby";
                myBooks[2].title = "The Java Cookbook";
                myBooks[0].author = "bob";
                myBooks[1].author = "sue";
                myBooks[2].author = "ian";
        
                while(x<3) {
                        System.out.print(myBooks[x].title);
                        System.out.print(" by ");
                        System.out.println(myBooks[x].author);
                        x = x + 1;
                }
        }
}

B
class Hobbits {
        
        String name ;
        
        public static void main(String [] args) {
        
                Hobbits [] h = new Hobbits[3];
                int z = 0 ;

                while(z<3) {//z<4일 이유가 없으므로 z<3으로 변경
        
                        h[z] = new Hobbits();
                        h[z].name = "bilbo";
                        if(z==1) {
                                h[z].name = "frodo";
                        }
                        if(z==2) {
                                h[z].name = "sam";
                        }
                        System.out.print(h[z].name + " is a " );
                        System.out.println("good Hobbit name");
                        z=z+1;//맨앞에 있으면 0번째가 의미가 없으므로 맨 밑으로 내림
                }
        }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 절약할 수 있다. 그러나 순환문을 돌때마다 변수에 다른 값이 들어가기 때문에 전에 저장했던 값이 없어지는 결과를 얻게 되는 문제를 발생시킨다. 

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 캡슐화 하지 않으면 웃음거리가 되기 쉬우니까 private를 사용해 노출 되어 있는 변수를 보호함. 
 * 게터와 세터: 게터 - 정식명칭은 액세서, 가져오기로 되어있는 값을 리턴값 형태로 받아오기 위한 용도, 세터 -정식명칭은 뮤테이터, 설정할 값을 인자로 받아서 인스턴트 변수를 그 값으로 설정하기 위한 용도
 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수 - 클래스 내에서 선언, 지역 변수 - 매소드 내에서 선언, 사용 전 반드시 초기화
 
*107p Dog* _실행_

{{{

public class Dog {
	int size;
	String name;
	
	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof!");
		}else if (size > 14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}
}

Class DogTestDrive{
	public static void main (String[] args){
		Dog one = new Dog ();
		one.size = 70;
		Dog two = new Dog ();
		two.size = 8;
		Dog three = new Dog () ;
		three.size = 35 ;
		
		one.bark();
		two.bark();
		three.bark();
	}
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
/* A */
public class XCopy {
	public static void main(String [] args){

		int orig = 42;
		
		XCopy x = new XCopy();
		
		int y = x.go(orig); //x에서 go 호출 go에 orig값을 보낸 후 y에 그 값을 리턴
		
		System.out.println(orig + " " + y);
	}
	int go(int arg) {
		
		arg = arg * 2 ;
		
		return arg;
		
	}//출력값은 42 84

}

/* B */


public class Clock {
	
	String time;
	
	void setTime(String t){
		time = t ;
		
	}
	
	String getTime(){//getTime은 게터이고 리턴 받을 time이 string 이므로 getTime을 void가 아닌 String으로 설정 해 주어야 한다.
		return time;
	}
}


public class ClockTestDrive {
	public static void main(String [] args){
		
		Clock c = new Clock();
		
		c.setTime("12345");
		String tod = c.getTime();
		System.out.println("time: " + tod);
	}
}//출력 time: 12345




}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 
    최근의 소프트웨어 개발 방법론 분야에 새로 등장.

    최근에는 높은 사람들을 위한 방법론이다.
 
    테스트를 많이 만드는 것은 xp패러다임에 따른 것이다.

    많은 사람들이 "프로그래머들이 정말 원하는 방법"이라고 함. 


    90년대 말에 등장


     가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공 할 수 있다는 점임.


    규칙 중에 야근은 하지 마라는 아주 좋은 규칙이 있음.
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0 ;
	
	public void setLocationCells (int[] locs){
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess){//배열이 맞았나 체크
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0 ; i < locationCells.length; i++){
			if (guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}//순환문 끝
		
		if (numOfHits == locationCells.length){
			result = "kill";//다 맞추면 kill이라고 나타나게 함
	 	}
		System.out.println(result) ;
			return result ;
	}//메소드 끝
}//클래스 끝


public class SimpleDotComGame {

	public static void main(String[] args) {
		int numOfGuesses = 0 ; //사용자가 추측한 횟수를 추적하기 위한 변수
		GameHelper helper = new GameHelper();//일단 사용자로부터 입력을 받기 위한 메소드가 들어있는 특별한 클래스가 있다고 생각
		
		SimpleDotCom theDotCom = new SimpleDotCom(); //닷컴 객체 생성
		
		int randomNum = (int)(Math.random()*5);//첫번째 셀 위치를 정하기 위한 난수를 생성하고 그 값을 써서 셀 위치 배열을 만듦
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};//첫번째 셀 위치를 정하기 위한 난수를 생성하고 그 값을 써서 셀 위치 배열을 만듦
		theDotCom.setLocationCells(locations);//닷컴의 위치를 지정(배열사용)
		boolean isAlive = true ;//닷컴이 살아있는지 추적하기 위한 부울 변수를 만듦
		
		while (isAlive == true){//살아 있으면 반복
			String guess = helper.getUserInput("enter a number");//사용자가 입력한 string을 받아옴
			
			String result = theDotCom.checkYourself(guess);
			//닷컴 객체를 통해 추측한 값이 맞는지 확인. 리턴된 결과는 string에 저장
			numOfGuesses++;
			//추측횟수 증가
			if (result.equals("kill")){//kill이면 isAlive를 false로 설정 ->순환문 탈출
				isAlive = false ;
				
				System.out.println(numOfGuesses + "guesses");
			}//if 문 끝
		}//while문 끝
	}//main 끝
}//클래스 끝

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt){
		String inputLine = null ;
		System.out.print(prompt + " ") ;
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if (inputLine.length()== 0) return null;
		} catch(IOException e){
			System.out.println("IOException: " + e);
		}
		return inputLine;
	}
}
//마지막 클래스인 gamehelper는 책에서 그냥 그대로 입력하라고 나옴. 

//결과
enter a number 3
miss
enter a number 5
hit
enter a number 1
miss
enter a number 2
miss
enter a number 3
miss
enter a number 4
hit
enter a number 5
kill
7guesses

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive { // SimpleDotComTestDrive클래스를 생성합니다.

        public static void main(String[] args){


                int numOfGuesses=0;

                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5);

                int[] locations = {randomNum, randomNum+1, randomNum+2};

                boolean[] hitCells = new boolean[3]; //입력 값을 판단하기 위한  boolean 배열을 생성

                //닷컴 클래스로 boolean 배열을 넘김
                theDotCom.sethitCells(hitCells);

                theDotCom.setLocationCells(locations);

                boolean isAlive = true;

                while(isAlive == true){
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;
                        if(result.equals("kill")){
                                isAlive = false;
                                System.out.println(numOfGuesses + "guesses");
                        }

                }
        }

}


class SimpleDotCom { 

        int[] locationCells;
        boolean[] hitCells = new boolean[3];

        int numOfHits = 0;

        public void setLocationCells(int[] locs){

                locationCells = locs;
        }

        public void sethitCells(boolean[] check){ 
                hitCells = check;
        }


        public String checkYourself(String stringGuess){

                int guess = Integer.parseInt(stringGuess);

                String result = "miss";

                for(int i = 0; i < locationCells.length; i++){

                        if(guess == locationCells[i] && hitCells[i]!=true){ // 이미 맞춘 배열인지 확인
                                result = "hit";
                                numOfHits++;
                                hitCells[i] = true; // 맞춘 배열은 true로
                                break;

                        }

                }

                if (numOfHits == locationCells.length){
                        result = "kill";
                }

                System.out.println(result);
                return result;

        }

}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{
class SimpleDotCom { 

        int[] locationCells;


        int numOfHits = 0;

        public void setLocationCells(int[] locs){

                locationCells = locs;
        }

        public String checkYourself(String stringGuess){

                int guess = Integer.parseInt(stringGuess);

                String result = "miss";

                for(int i = 0; i < locationCells.length; i++){

               // 이미 맞춘 배열인지 확인
                        if(guess == locationCells[i] && locationCells[i]!=-1){ 
                                result = "hit";
                                numOfHits++;
                                locationCells[i]=-1; // 맞춘 배열은 -1값으로 교체
                                break;

                        }

                }

                if (numOfHits == locationCells.length){
                        result = "kill";
                }

                System.out.println(result);
                return result;

        }

}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList; // ArrayList를 import

public class DotCom
{
     private ArrayList<String> locationCells;
     // ArrayList를 사용
     // private int numOfHits;
      // 없어도 상관 ㄴㄴ

     public void setLocationCells(ArrayList<String>loc)
   
    {
         locationCells = loc;
     }
 
     public String checkYourself(String userInput)
     // 새로 바뀐 인자 이름을 넣어 줍니다.
    {
          String result = "miss";
  
          int index = locationCells.indexOf(userInput);
          // 사용자가 추측한 위치가 ArrayList에 들어있는지 확인, 들어있으면 인덱스 번호가, 그렇지 않으면 리턴
  
          if(index >= 0)
          {
                locationCells.remove(userInput);
                // 인덱스가 0 이상이면 사용자가 추측한 위치가 목록에 들어있는 것이므로 제거
   
              if(locationCells.isEmpty())
              // 목록이 비어짔다면 그 닷컴이 죽었다는 것을 알수 있습니다.
             {
                   result = "Kill";
             }
             else
             {
                   result = "hit";
              }        
         }        
         return result;
    }
}
}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{


import java.util.*;

public class DotComBust{
	
	private GameHelper helper = new GameHelper(); //사용할 변수를 선언하고 초기화
	private ArrayList<DotCom> dotComsList = new ArrayList();
	private int numOfGuesses = 0;
	
	private void setUpGame(){ //우선 닷컴 객체 몇 개를 만들고 위치를 지정합니다.
		DotCom one = new DotCom();
		one.setName("Pets.com");
		DotCom two = new DotCom();
		two.setName("eToys.com");
		DotCom three = new DotCom();
		three.setName("Go2.com");
		dotComsList.add(one);
		dotComsList.add(two);
		dotComsList.add(three); //DotCom 객체 3개 이름 부여, ArrayList에 저장.
	
		System.out.println("Your goal is to sink three dot coms.");
		System.out.println("Pets.com, eToys.com, Go2.com");
		System.out.println("Try to sink them all in the fewest number of guesses"); //사용 방법 설명
	
		for(DotCom dotComToSet : dotComsList){
			ArrayList<String> newlocation = helper.placeDotCom(3); //DotCom의 위치를 지정하기 위한 보조 메소드 호출
			dotComToSet.setLocationCells(newlocation); //DotCom 객체의 세터 메소드를 호출하여 보조 메소드에서 받은 위치를 지정.
		}
	} 
	private void startPlaying(){
		while(!dotComsList.isEmpty()){
			String userGuess = helper.getUserInput("Enter a guess");
			checkUserGuess(userGuess);
		} 		finishGame();
	} 
	
	private void checkUserGuess(String userGuess){
		
		numOfGuesses++; //추축한 횟수 증가
		
		String result = "miss"; //초기값 miss
		
		for(int x= 0; x < dotComsList.size(); x++){
			result = dotComsList.get(x).checkYourself(userGuess);
			if(result.equals("hit")){ //히트하면 순환문 빠져나감.
				break;
			}
				
			if(result.equals("kill")){
				dotComsList.remove(dotComToTest); //죽으면 목록에서 빼고 순환문 빠져나감.
				break;
			}
		} 
		
		System.out.println(result);
	} 
	
	private void finishGame(){ 
		System.out.println("All Dot Coms are dead! Your stock is now worthless");
		
		if(numOfGuesses <= 18){
			System.out.println("It only took you " + numOfGuesses +" guesses");
			System.out.println("You got out before your options sank");
		}else{
			System.out.println("Took you long enough. " +numOfGuesses + " guesses");
			System.out.println("Fish are dancing with your options");
		}
	} 
	public static void main(String args[]){
		DotComBust game = new DotComBust(); //게임 객체 생성
		game.setUpGame();
		game.startPlaying();
	}
}



import java.io.*;
import java.util.*;

public class GameHelper{
	private static final String alphabet = "abcdefg";
	private int gridLength = 7;
	private int gridSize = 49;
	private int	[] grid = new int[gridSize];
	private int comCount = 0;

	public String getUserInput(String prompt){
		String inputLine = null;
		System.out.print(prompt + "  ");
		try{
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			inputLine = is.readLine();
			if(inputLine.length() == 0) return null;
		}catch(IOException e){
			System.out.println("IOException : "+e);
		}
		return inputLine.toLowerCase();
	}	

	public ArrayList<String> placeDotCom (int comSize){
		ArrayList<String> alphaCells = new ArrayList<String>();
		String [] alphacoords = new String [comSize];
		String temp = null;
		int [] coords = new int [comSize];
		int attempts = 0;
		boolean success = false;
		int location = 0;
		
		comCount ++;
		int incr = 1;
		if((comCount % 2) == 1){
			incr = gridLength;
		}

		while(!success & attempts++ < 200){
			location = (int) (Math.random() * gridSize);
			int x = 0;
			success = true;

			while(success && x < comSize){
				if (grid[location] ==0){
					coords[x++] = location;
					location += incr;
					if(location >= gridSize){
						success = false;
					}
			
					if(x >0 && (location % gridLength ==0)){
						success = false;
					}
				} else{
		
					success = false;
				}
				
			}
		}
		int x = 0;
		int row = 0;
		int column = 0;
		while(x <comSize){
			grid[coords[x]] = 1;
			row = (int) (coords [x] /gridLength);
			temp = String.valueOf(alphabet.charAt(column));
			
			alphaCells.add(temp.concat(Integer.toString(row)));
			x++;
			//System.out.print("  coord " + x+ " = " alphaCells.get(x-1)); //DotCom의 위치를 알려주는 코드
		}
			
		
		return alphaCells;
	} 
}
	
	

import java.util.*;

public class DotCom{
	private ArrayList<String> locationCells;
	private String name;
	
	public void setLocationCells(ArrayList<String> loc){
		locationCells = loc;
	}
	
	public void setName(String n){
		name = n;
	}
	
	public String checkYourself(String userInput){
		String status = "miss";
		int index = locationCells.indexOf(userInput);
			if(index >= 0){
				locationCells.remove(index); //ArrayList에서 해당 위치를 없앰.
					
				if(locationCells.isEmpty()){
					status = "kill";
					System.out.println("byebye! You sunk " +name+ " : ( "); //닷컴 ㅂㅂ
				}else{
					status ="hit";
				}
			} 
			
		return status; //결과(miss,hit,kill)를 리턴
	} 
} 

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상위클래스로부터 인스턴스 변수와 메소드를 넘겨주는 것
 * 다형성: 하나의 형태를 각각 다르게 사용할 수 있다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{
class Animal {
        String picture;
        boolean food;
        int hunger;
        float boundaries;
        float location;

        void makeNoise(){
        }
        void eat(boolean food){
        }
        void sleep(){
        }
        void roam(){
        }
}

class Feline extends Animal{
        }
}

class Lion extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Tiger extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Cat extends Feline{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Hippo extends Animal{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Canine extends Animal{
        void roam(){
        }
}

class Wolf extends Canine{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

class Dog extends Canine{
        void makeNoise(){
        }
        void eat(boolean food){
        }
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 부모의 메소드를 자식의 메소드에서 다시 정의 하는 것
 * 오버로딩: 하나의 클래스 내에 인수의 개수나 형식이 다른 동일한 이름의 메소드를 여러개 정의하는 것, 즉 이름이 같은 메소드라도 안에 있는 인수만 다르다면 얼마든지 만들 수 있다는 것

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{


public class MonsterTestDrive {
	public static void main(String[] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++) {
			ma[x].frighten(x); 
	        }
	}
}


public class Monster {
  	boolean frighten(int d) {
  		System.out.println("arrgh");
  		return true;
  	}
}


public class Vampire extends Monster {
	boolean frighten(int x) { //Vampire가 Monster를 오버라이드 해야하기 때문에 입력값 유형(int)와 반환값 유형(boolean)이 같아야 한다.
		System.out.println("a bite?");
		return false;
	}
}


public class Dragon extends Monster {
	boolean frighten(int degree) {
		System.out.println("breath fire");
		return true;
	}
}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:

 모든 메소드가 추상 메소드입니다.

 하위 클래스에서 반드시 구현(상속)해야만 하므로 상속받은 것 중에 어떤 것을 호출해야 할지 결정할 수 없게 되는 문제가 생기지 않습니다.
 
 여러개가 되어도 상관 없다.

 중복문제를 해결하지 못함
 
 다른 클래스들한테 내가 이런 메소드를 갖고있다 라는 것을 알려주기위해 사용.

 인터페이스는 실제로 아무것도 제공해 주지 못한다.

 서로다른 상속트리에서 인터페이스를 구현할 수 있다.

 * 다형성: 하나의 형태를 다르게 사용 할 수 있다.
 * 추상 클래스:

 인스턴스를 만들 수 없는 클래스

 반드시 확장해야 함

 추상 유형을 레퍼런스로 사용할 수는 있음

 다형적인 인자, 리턴 유형, 배열 등에 활용

 * 추상 메소드:

 몸통이 없는 메소드

 반드시 오버라이드해야 합니다.

 추상 메소드를 만들 때는 클래스도 반드시 추상 클래스로 만들어야 합니다.


 추상 클래스가 아닌 클래스에는 추상 메소드를 집어 넣을 수 없습니다.

 아무일도 일어나지 않는 메소드에요.

 얘로부터 상속받은 클래스에서는 이 메소드 이름으로 다른 행동을 하게 만들 수 있다.

 상속받은 클래스에서 무조건 상속받은 메소드를 구현해 놓아야 한다.

 반복을 시킬 수 있다.
 * 다중 상속:
상위클래스가 두개 이상.
자바는 할 수 없다



= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 없어지지 않는다.
 * 스택에서의 변수: 끝나면 없어진다.
 * 생성자: 객체를 생성할 때 실행되는 코드가 들어있습니다. 모든 클래스에 생성자가 있습니다. 직접 만들지 않아도 컴파일러에서 자동으로 생성자를 만들어줍니다.
 * 널 레퍼런스: 가비지 컬렉션 대상이된다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 클래스 내에서 선언한 변수
 * 지역 변수: 메소드내에서 선언한 변수, 매개변수도 지역 변수에 포함

*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.*;

class V2Radiator {
        V2Radiator (ArrayList list) {
                for(int x=0; x<5; x++) {
                        list.add(new SimUnit ("V2Radiator"));
                }
        }
}

class V3Radiator { //V3Radiator가 V2Radiator를 상속하면 안된다!
        V3Radiator (ArrayList lglist) {
                // super(lglist);
                for(int g=0; g<10; g++) {
                        lglist.add(new SimUnit("V3Radiator"));
                }
        }
}

class RetentionBot {
        RetentionBot (ArrayList rlist) {
                rlist.add(new SimUnit("Retention"));
        }
}

public class TestLifeSupportSim {
        public static void main(String[] args) {
                ArrayList aList = new ArrayList();
                V2Radiator v2 = new V2Radiator(aList);
                V3Radiator v3 = new V3Radiator(aList);
                for(int z=0; z<20; z++) {
                        RetentionBot ret = new RetentionBot(aList);
                }
        }
}

class SimUnit {
        String botType;
        SimUnit(String type) {
                botType = type;
        }
        int powerUse() {
                if("Retention".equals(botType)) {
                        return 2;
                } else {
                        return 4;
                }
        }
}

// aList에 V2R이 5개, V2R이 5개, V3R이 10개, Retention이 10개 쌓임. 
// (5+5+10)*4 + 10*2 = 120의 에너지를 소모.
// V3Radiator가 V2Radiator를 상속한 것이 문제. 

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: 인스턴스 변수를 쓸 수 없음. 정적 변수만 써야함  
 * 정적 메소드를 선언하는 방법: static
 * static final: 상수. 바꿀수 없다. 대문자로. 메소드를 final로 지정하면 오버라이드 할 수 없다. 클래스를 final로 지정하면 확장할 수 없다. 
 * 널 레퍼런스: 아무것도 가리키지 않는 레퍼런스
 * 오토 박싱: 원시유형을 컬렉션에 집어넣거나, 컬렉션에서 꺼낼 때, 거의 언제나 원시 유형이 들어갈 자리에 그 유형에 해당하는 래퍼 객체를 집어넣거나, 반대로 어떤 래퍼 객체가 들어갈 자리에 원시값을 집어넣을 수 있게하준다.
 * 정적 임포트: 정적 클래스, 정적 변수, enum 값 등을 사용할 때 활용.

*339p Calendar* _구현후 주석달기_

{{{


import java.util.*;

public class CalendarUsage {

        public static void main(String[] args) {

                Calendar c = Calendar.getInstance();
                
                c.set(1994,5,6,23,59); // 년,월,일,시,분 설정
                long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현.
                day1 += 1000 * 60 * 60; // 밀리초단위로 한시간을 나타냅니다.
                c.setTimeInMillis(day1); // 한시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신
                System.out.println("새 시간 " + c.get(c.HOUR_OF_DAY));

                c.add(c.DATE, 35); // 35일 더함
                System.out.println("35일 후 " + c.getTime());

                c.roll(c.DATE, 35); // 35일을 더하고 달은 변경 하지 않음.
                System.out.println("35일을 굴리면 " + c.getTime());

                c.set(c.DATE, 1); // 날짜를 1일로.
                System.out.println("1일로 설정 " + c.getTime());
        }
}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 정적변수는 절차위주의 프로그래밍 썼던 비효율적인 변수 할당 방법이므로 바람직하지 않다
 * 지역 변수: 정적변수는 이미 자바 환경 자체에 녹아들어가 있고 때에 따라서는 정적 변수를 쓰는 것이 편리할 때도 있다.


*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class StaticSuper {

        static {
                System.out.println("super static block");
        }
        
        StaticSuper() { // 생성자 메소드여야 하므로 ()을 써준다.
                System.out.println("super constructor");
        }

}





public class StaticTests extends StaticSuper {

        static int rand; 
        
        static {
                rand = (int) (Math.random() * 6);
                System.out.println("static block " + rand);
        }
        
        StaticTests() {
                System.out.println("constructor");
        }
        
        public static void main(String[] args) {
                System.out.println("in main");
                StaticTests st = new StaticTests();
        }
        
}

/* 출력 결과 :
 super static block
 static block 0
 in main
 super constructor
 constructor */


}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{



public class Try1 {

        public static void main(String[] args) {
                
                public void takeRisk() throws BadException {
                        if (abandonAllHope) {
                                throw new BadException();
                        }
                }
                
                public void crossFingers() {
                        try {
                                anObject.takeRisk(); //예외가 발생 할 수 있는 행동
                        } catch (BadException ex) {  //예외가 발생되면 catch 안에 있는걸 실행
                                System.out.println("Aaargh!");
                                ex.printStackTrance();
                        }
                }
                
        }
}


}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{


import javax.sound.midi.*;

public class MiniMiniMusicApp {

                public static void main(String[] args) {
                        MiniMiniMusicApp mini = new MiniMiniMusicApp(); 
                        mini.play(); //실행
                } 
                
                public void play() {
                        
                        try {
                                Sequencer player = MidiSystem.getSequencer(); //sequencer를 받아서 연다.
                                player.open();
                                
                                Sequence seq = new Sequence(Sequence.PPQ, 4);
                                
                                
                                Track track = seq.createTrack(); // sequencer에 track을 요청.
                                
                                ShortMessage a = new ShortMessage(); 
                                a.setMessage(144, 1, 44, 100);
                                MidiEvent noteOn = new MidiEvent(a, 1);
                                track.add(noteOn);
                                
                                ShortMessage b = new ShortMessage();
                                b.setMessage(128, 1, 44, 100);
                                MidiEvent noteOff = new MidiEvent(b, 16);
                                track.add(noteOff); //track에 MidiEvent를 넣습니다.
                                
                                player.setSequence(seq); // sequencer에 sequence를 보냅니다.
                                
                                player.start(); //sequencer의 start() 메소드 호출.
                        
                        } catch (Exception ex) {
                                ex.printStackTrace();
                        }

                } 
} 

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

import javax.sound.midi.*;

public class MiniMusicCmdLine {

                public static void main(String[] args) {
                        MiniMusicCmdLine mini = new MiniMusicCmdLine(); 
                        if (args.length < 2) {
                                System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
                        } else {
                                int instrument = Integer.parseInt(args[0]); //악기 선택.
                                int note = Integer.parseInt(args[1]); //음높이 선택.
                                mini.play(instrument, note); //실행
                        }
                } 
                
                public void play(int instrument, int note) {
                        
                        try {
                                
                                Sequencer player = MidiSystem.getSequencer(); 
                                player.open();
                                Sequence seq = new Sequence(Sequence.PPQ, 4);
                                Track track = seq.createTrack(); 
                                
                                MidiEvent event = null; //초기화.
                                
                                ShortMessage first = new ShortMessage();
                                first.setMessage(192, 1, instrument, 0);
                                MidiEvent changeInstrument = new MidiEvent(first,1);
                                track.add(changeInstrument); //악기 변경.
                                
                                ShortMessage a = new ShortMessage(); 
                                a.setMessage(144, 1, 44, 100);
                                MidiEvent noteOn = new MidiEvent(a, 1);
                                track.add(noteOn);
                                
                                ShortMessage b = new ShortMessage();
                                b.setMessage(128, 1, 44, 100);
                                MidiEvent noteOff = new MidiEvent(b, 16);
                                track.add(noteOff);
                                player.setSequence(seq); 
                                player.start(); 
                        
                        } catch (Exception ex) {
                                ex.printStackTrace();
                        }

                } 
}

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
import javax.swing.*; //반드시 불러와야 하는 스윙 패키지

public class SimpleGui1 {
	public static void main (String[] args){
		JFrame frame = new JFrame(); //프레임생성
		JButton button = new JButton("click me"); //버튼생성, 버튼 텍스트 : click me
		
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		//창을 닫았을 때 프로그램이 바로 종료 되게 하는 코드
		
		frame.getContentPane().add(button);
		//버튼을 프레임의 내용 틀에 추가
		frame.setSize(300,300);
		//프레임의 크기를 픽셀 단위로 지정
		frame.setVisible(true);
		//화면에 표시되도록 설정
	}
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.event.*; // Actionlistener와 이벤트가 들어있는 패키지를 사용

/* 인터페이스 구현 */
public class SimpleGui1B implements ActionListener {
        JButton button; // 버튼 생성

        public static void main(String []args){
                SimpleGui1B gui=new SimpleGui1B();
                gui.go();

        }

        public void go(){
                JFrame frame= new JFrame();
                button=new JButton("cliick me"); // 버튼 텍스트 : click me

                button.addActionListener(this); // 버튼에 action리스너를 등록.

                frame.getContentPane().add(button);
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(300,300);
                frame.setVisible(true);
        }
/* ActionListener 인터페이스의 actionPerformed()메소드 구현 */
        public void actionPerformed(ActionEvent event){ // 버튼이 클릭됐을 때 실행되는 이벤트
                button.setText("I've been clicked!");
        }
}
}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{
package circle;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener{
	JFrame frame; // 프레임 생성

    public static void main(String [] args){
            SimpleGui3C gui=new SimpleGui3C();
            gui.go();
    }

    public void go() {
            frame=new JFrame();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            JButton button = new JButton("Change colors"); 
            button.addActionListener(this); // 액션 리스너 설정

            MyDrawPanel drawPanel = new MyDrawPanel(); // drawPanel 객체를 생성

            frame.getContentPane().add(BorderLayout.SOUTH,button); // 버튼을 프레임에 추가
            frame.getContentPane().add(BorderLayout.CENTER, drawPanel); // 그림 패널을 프레임에 추가
            frame.setSize(300,300); 
            frame.setVisible(true);
    }
    public void actionPerformed(ActionEvent event){
            frame.repaint(); // 사용자가 버튼을 클릭하면 repaint메소드를 호출합니다. 그러면 그 프레임에 들어있는 모든 위젯의 paintComponent가 호출됩니다.
    }

}
package circle;

import java.awt.*;
import javax.swing.JPanel;

/* 원을 무작위적으로 선택한 색으로 칠하기 위한 코드 */
public class MyDrawPanel extends JPanel{
	 public void paintComponent(Graphics g){
         
		g.fillRect(0, 0, this.getWidth(), this.getHeight()); //배경  : 검은색

         int red = (int)(Math.random()*256); 
         int green = (int)(Math.random()*256);
         int blue = (int)(Math.random()*256);
         
         Color randomColor = new Color(red,green,blue);
         g.setColor(randomColor);
         g.fillOval(70,70,100,100); //왼쪽에서 70픽셀, 위에서 70픽셀 떨어진 곳에 너비와 높이가 각각 100픽셀인 (타)원을 만듦
 }

}

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{
package twobuttons;

import java.awt.*;
import javax.swing.*;

public class TwoButtons {
	 JFrame frame; 
     JLabel label; 

     public static void main(String args[]){
             TwoButtons gui = new TwoButtons();
             gui.go();
     }

     public void go(){
             frame=new JFrame();
             frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);


             JButton labelButton = new JButton ("Change Label");
             labelButton.addActionListener(new LabelListener());
             // 버튼의 리스너 등록 메소드에 this가 아닌 다른 리스너 클래스를 갖고 만든 객체를 전달 합니다.

             JButton colorButton = new JButton ("Change Circle");
             colorButton.addActionListener(new ColorListener());
             // 버튼의 리스너 등록 메소드에 this가 아닌 다른 리스너 클래스를 갖고 만든 객체를 전달 합니다.

             label = new JLabel("I'm a lebel");
             MyDrawPanel drawPanel = new MyDrawPanel();

             // 프레임에서 각 버튼과 판넬의 위치를 설정
             frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
             frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
             frame.getContentPane().add(BorderLayout.EAST, labelButton);
             frame.getContentPane().add(BorderLayout.WEST, label);

             frame.setSize(300,300);
             frame.setVisible(true);
     }

}

class LabelListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        label.setText("Ouch!"); // 내부 클래스에서도 label 변수를 사용할 수 있습니다.
                }
        } // 내부 클래스 끝

class ColorListener implements ActionListener{
                public void actionPerformed(ActionEvent event){
                        frame.repaint(); // 내부 클래스에서 외부 클래스 객체에 대한 레퍼런스 없이 그냥 frame 인스턴스 변수를 사용하면 됩니다.
                }
        } // 내부 클래스 끝

package twobuttons;

import java.awt.*;
import javax.swing.JPanel;

public class MyDrawPanel extends JPanel{
	 public void paintComponent(Graphics g){
         
		g.fillRect(0, 0, this.getWidth(), this.getHeight()); 

         int red = (int)(Math.random()*256); 
         int green = (int)(Math.random()*256);
         int blue = (int)(Math.random()*256);
         
         Color randomColor = new Color(red,green,blue);
         g.setColor(randomColor);
         g.fillOval(70,70,100,100); 
 }

}

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.*;

public class SimpleAnimation{

        int x=70;
        int y=70;
        // 원의 x와 y좌표를 저장하기 위한 인스턴스 변수 두 개를 만듭니다.
        
        public static void main(String args[]){
                SimpleAnimation gui = new SimpleAnimation();
                gui.go();
        }

        public void go(){

                JFrame frame=new JFrame();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);


                MyDrawPanel drawPanel = new MyDrawPanel();
                // 위젯을 만들고, 프레임에 집어 넣습니다.
                frame.getContentPane().add(drawPanel);
                frame.setSize(300,300);
                frame.setVisible(true);

                for(int i=0;i<300;i++){

                // 애니메이션을 수행하는 부분입니다. 300번 반복합니다.
                        x++;
                        y++;
                        //x와 y 좌표를 증가시킵니다.

                        drawPanel.repaint(); // 스스로 다시 칠하도록 패널에게 말합니다.
                        try{
                                Thread.sleep(50); //속도를 약간 줄입니다.
                        }catch(Exception ex){}
                }
        } // go()메소드 끝

        @SuppressWarnings("serial") // 컴파일러에 명령하여 오류를 수정했습니다.
        // 내부클래스입니다.
        class MyDrawPanel extends JPanel{
                public void paintComponent(Graphics g){
                        g.setColor(Color.white);
                        
                        g.fillRect(0,0,this.getWidth(),this.getHeight()); //getWidth(), getHeight()는 JPanel로부터 상속 받은 메소드입니다.

                        g.setColor(Color.green);
                        //지속적으로 갱신되는 외부클래스의 x, y 좌표를 사용합니다.
                        g.fillOval(x, y, 40, 40); 
                }
        } // 내부 클래스 끝
}

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{
package music_video;

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {
	static JFrame f = new JFrame("My First Music Video");
    static MyDrawPanel m1;

    public static void main(String [] args){
            MiniMusicPlayer3 mini = new MiniMusicPlayer3();
            mini.go();
    }

    /* GUI를 세팅 */ 
    public void setUpGui(){
            m1 = new MyDrawPanel();
            f.setContentPane(m1);
            f.setBounds(30, 30, 300, 300);
            f.setVisible(true);
    }

    public void go(){
            setUpGui();

            /* 음악 재생 코드 */
            try{
                    Sequencer sequencer = MidiSystem.getSequencer();
                    sequencer.open();
                    sequencer.addControllerEventListener(m1, new int[] {127}); 
                    Sequence seq = new Sequence(Sequence.PPQ, 4); //sequence생성
                    Track track = seq.createTrack();//track생성

                    int r = 0; 
                    for(int i = 0; i<60 ; i+=4){//음이 올라가는 순서대로 이벤트를 만듭니다.

                            r=(int)((Math.random()*50)+1);
                            track.add(makeEvent(144,1,r,100,i));
                            track.add(makeEvent(176,1,127,0,i)); 
                            track.add(makeEvent(128,1,r,100,i+2));
                    }//144는 NOTE ON이벤트, 128은 NOTE OFF 이벤트, 176은 별도의 EVENT를 지정하기 위한 숫자

                    sequencer.setSequence(seq);
                    sequencer.setTempoInBPM(120);
                    sequencer.start();//시작 
            } catch(Exception ex) {ex.printStackTrace();}
    }

    /* Midi 이벤트 부분 */
    public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
            MidiEvent event = null;
            try{
                    ShortMessage a = new ShortMessage();
                    a. setMessage(comd,chan,one,two);
                    event = new MidiEvent(a, tick);
            }catch(Exception e){}
            return event;

    }


    
}
package music_video;

import java.awt.*;
import javax.sound.midi.*;
import javax.swing.*;

class MyDrawPanel extends JPanel implements ControllerEventListener {
	   boolean msg = false;  
	             
	           public void controlChange(ShortMessage event) {  
	               msg = true;  // 이벤트를 받았으므로 msg를 true로 만들어줌 
	               repaint();  
	           }  
	             
	           public void paintComponent(Graphics2D g) {
  
	               if (msg) {//색 설정이랑 직사각형 설정  
	                   Graphics2D g2 = (Graphics2D) g;  
	                   int r = (int) (Math.random() * 250);  
	                   int gr = (int) (Math.random() * 250);  
	                   int b = (int) (Math.random() * 250);  
	                     
	                   g.setColor(new Color(r,gr,b));  
	                     
	                   int ht = (int) ((Math.random() * 120) + 10);  
	                   int width = (int) ((Math.random() * 120) + 10);  
	                   int x = (int) ((Math.random() * 40) + 10);  
	                   int y = (int) ((Math.random() * 40) + 10);  
	                     
	                   g.fillRect(x, y, ht, width);  
	                   msg = false;  
	               }  
	           }  
	       }  

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {


        JPanel mainPanel;
        ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
        Sequencer sequencer;
        Sequence sequence;
        Track track;
        JFrame theFrame;

       
        String[]instrumentNames = {"Bass Drum","Closed Hi-Hat",
                        "Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap",
                        "High Tom","Hi Bongo","Maracas","Whistle","Low Conga",
                        "Cowbell","Vibraslap","Low-mid Tom","High Agogo",
        "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
        int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
        /* 실제 드럼 '건반'을 나타냅니다.
                       드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 
         35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다. */
        
        public static void main(String [] args){
                new BeatBox().buildGUI();
        }

        public void buildGUI(){
                theFrame = new JFrame("Cyber BeatBox");
                theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                BorderLayout layout = new BorderLayout();
                JPanel background = new JPanel(layout);
                // empty border를 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있습니다.
                
                background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

                checkboxList = new ArrayList<JCheckBox>();
                Box buttonBox = new Box(BoxLayout.Y_AXIS);

                /* 버튼들을 추가하고 actionlistener를 처리 해 줍니다. */
                JButton start = new JButton("Start");
                start.addActionListener(new MyStartListener());
                buttonBox.add(start);

                JButton stop = new JButton("Stop");
                stop.addActionListener (new MyStopListener());
                buttonBox.add(stop);

                JButton upTempo = new JButton("upTempo");
                upTempo.addActionListener(new MyUpTempoListener());
                buttonBox.add(upTempo, "upTempo");

                JButton downTempo = new JButton("Tempo Down");
                downTempo.addActionListener(new MyDownTempoListener());
                buttonBox.add(downTempo, "downTempo");

                /* GUI 설정 코드 */
                Box nameBox = new Box(BoxLayout.Y_AXIS);
                for(int i=0; i<16; i++){
                        nameBox.add(new Label(instrumentNames[i]));
                }

                /* 버튼박스, 이름박스의 위치를 정합니다. */
                background.add(BorderLayout.EAST, buttonBox);
                background.add(BorderLayout.WEST, nameBox);

                theFrame.getContentPane().add(background);

                GridLayout grid = new GridLayout(16,16); //그리드레이아웃을 생성합니다.
                grid.setVgap(1);
                grid.setHgap(2);
                mainPanel = new JPanel(grid);
                background.add(BorderLayout.CENTER,mainPanel);

                for(int i=0;i<256;i++)
                {
                        JCheckBox c = new JCheckBox();
                        c.setSelected(false);
                        checkboxList.add(c);
                        mainPanel.add(c);
                }//체크 상자를 만들고 모든 값을 'false'로 지정하여 체크를 해제 시켜 줍니다.
                 //그다음에 ArrayList와 GUI패널에 추가합니다.

                setUpMidi();

                theFrame.setBounds(50,50,300,300);
                theFrame.pack();
                theFrame.setVisible(true);      

        }// buildGUI 메소드 끝

        /* 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드 */
        public void setUpMidi(){
                try{
                        sequencer= MidiSystem. getSequencer();
                        sequencer.open();
                        sequence = new Sequence(Sequence.PPQ,4);
                        track = sequence.createTrack();
                        sequencer.setTempoInBPM(120);
                }catch(Exception e){e.printStackTrace();}
        }//setUpMidi 메소드 끝

        // 체크상자의 상태를 MIDI이벤트로 바꾼 후 이벤트를 트랙에 추가합니다.
        public void buildTrackAndStart(){
                int [] trackList = null; 
                /* 각 악기의 열여섯 박자에 대한 값을 원소가 16개인 배열에 저장합니다. 
                                               어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를 넣습니다. 
                                               반대로 연주되어야 하지 않는다면 0을 집어넣습니다.*/

                /* 기존 트랙을 제거하고 트랙을 새로 만듭니다.*/
                sequence.deleteTrack(track);
                track = sequence.createTrack();

                
                for(int i = 0; i< 16; i++){//열 16개 모두에 대해 같은 작업을 처리합니다.
                        trackList = new int[16];

                        int key = instruments[i]; // 어떤 악기인지 정하는 번호를 설정합니다.


                        for(int j = 0; j<16 ; j ++) // 이 열에 들어 있는 모든 박자에 대해 같은 작업을 반복합니다.
                        {
                                JCheckBox jc = checkboxList.get(j + (16*i));
                                if(jc.isSelected()){
                                        trackList[j] = key;
                                }else{
                                        trackList[j] = 0;
                                } // 이 박자에 해당하는 체크상자가 선택되었는지 확인.
                                  // 선택되어 있으면 배열의 그 박자를 나타내는 자리에 건반 값을 집어넣습니다.
                                  // 그렇지 않으면 0을 선택합니다.
                        }//안쪽 for문 끝

                        makeTracks(trackList); //16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가합니다.
                        track.add(makeEvent(176,1,127,0,16));
                }// 바깥쪽 for문 끝

                track.add(makeEvent(192,9,1,0,15));
                try{
                        sequencer.setSequence(sequence);
                        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                }catch(Exception e){e.printStackTrace();} //드디어 연주
        } // buildTrackAndStart 메소드 끝

        /* 버튼의 리스너 */
        public class MyStartListener implements ActionListener {
                public void actionPerformed(ActionEvent a){
                        buildTrackAndStart();
                }
        } // 내부 클래스 끝

        public class MyStopListener implements ActionListener{
                public void actionPerformed(ActionEvent a){
                        sequencer.stop();
                }
        }// 내부 클래스 끝

        public class MyUpTempoListener implements ActionListener{
                public void actionPerformed(ActionEvent a){
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor * 1.03));
                }
        }// 내부 클래스 끝
        public class MyDownTempoListener implements ActionListener {
                public void actionPerformed(ActionEvent a){
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor* .97));
                }
        }// 내부 클래스 끝
        /* 리스너 다 만들었다.*/
        
        /* 한 악기의 16박자 전체에 대해 이벤트를 생성. 
        int[]배열에는 악기에 해당하는 건반 번호 또는 0이 들어갑니다.
        0이 들어있다면 그 박자에서는 해당 악기가	연주되지 않아야 합니다.
        0이 아닌 값이 들어있다면 이벤트를 만들어서 트랙에 추가합니다. */
        public void makeTracks(int [] list){
                for(int i=0;i<16;i++){
                        int key = list[i];

                        if(key!=0){

                                // NOTE ON과 NOTE OFF 이벤트를 만들고 트랙에 추가합니다.                
                                track.add(makeEvent(144,9,key,100,i));
                                track.add(makeEvent(128,9,key,100,i+1));
                        }
                }
        }

        public MidiEvent makeEvent(int comd, int chan , int one, int two, int tick){
                MidiEvent event = null;
                try{
                        ShortMessage a = new ShortMessage();
                        a.setMessage(comd,chan,one,two);
                        event = new MidiEvent ( a, tick);

                }catch(Exception e){e.printStackTrace();}
                return event;

        }
}//클래스 끝
}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;

import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class BeatBox {


        JPanel mainPanel;
        ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장합니다.
        Sequencer sequencer;
        Sequence sequence;
        Track track;
        JFrame theFrame;

       
        String[]instrumentNames = {"Bass Drum","Closed Hi-Hat",
                        "Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap",
                        "High Tom","Hi Bongo","Maracas","Whistle","Low Conga",
                        "Cowbell","Vibraslap","Low-mid Tom","High Agogo",
        "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명을 String배열로 저장합니다.
        int []instruments ={35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
        /* 실제 드럼 '건반'을 나타냅니다.
                       드럼채널은 피아노의 각 건반이 서로 다른 드럼을 나타내는 것과 같다고 보면 됩니다. 
         35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식입니다. */
        
        public static void main(String [] args){
                new BeatBox().buildGUI();
        }

        public void buildGUI(){
                theFrame = new JFrame("Cyber BeatBox");
                theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                BorderLayout layout = new BorderLayout();
                JPanel background = new JPanel(layout);
                // empty border를 사용하여 패널 둘레와 구성요소가 들어가는 자리 사이에 빈 공간을 만들 수 있습니다.
                
                background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));

                checkboxList = new ArrayList<JCheckBox>();
                Box buttonBox = new Box(BoxLayout.Y_AXIS);

                /* 버튼들을 추가하고 actionlistener를 처리 해 줍니다. */
                JButton start = new JButton("Start");
                start.addActionListener(new MyStartListener());
                buttonBox.add(start);

                JButton stop = new JButton("Stop");
                stop.addActionListener (new MyStopListener());
                buttonBox.add(stop);

                JButton upTempo = new JButton("upTempo");
                upTempo.addActionListener(new MyUpTempoListener());
                buttonBox.add(upTempo, "upTempo");

                JButton downTempo = new JButton("Tempo Down");
                downTempo.addActionListener(new MyDownTempoListener());
                buttonBox.add(downTempo, "downTempo");
                
                JButton serializeIt = new JButton("serializeIt");
                downTempo.addActionListener(new MySendListener());
                buttonBox.add(serializeIt, "serializeIt");
                //serializeIt 버튼 추가
                
                JButton restore = new JButton("restore");
                downTempo.addActionListener(new MyReadInListener());
                buttonBox.add(restore, "restore");
                //restore 버튼 추가
                
                /* GUI 설정 코드 */
                Box nameBox = new Box(BoxLayout.Y_AXIS);
                for(int i=0; i<16; i++){
                        nameBox.add(new Label(instrumentNames[i]));
                }

                /* 버튼박스, 이름박스의 위치를 정합니다. */
                background.add(BorderLayout.EAST, buttonBox);
                background.add(BorderLayout.WEST, nameBox);

                theFrame.getContentPane().add(background);

                GridLayout grid = new GridLayout(16,16); //그리드레이아웃을 생성합니다.
                grid.setVgap(1);
                grid.setHgap(2);
                mainPanel = new JPanel(grid);
                background.add(BorderLayout.CENTER,mainPanel);

                for(int i=0;i<256;i++)
                {
                        JCheckBox c = new JCheckBox();
                        c.setSelected(false);
                        checkboxList.add(c);
                        mainPanel.add(c);
                }//체크 상자를 만들고 모든 값을 'false'로 지정하여 체크를 해제 시켜 줍니다.
                 //그다음에 ArrayList와 GUI패널에 추가합니다.

                setUpMidi();

                theFrame.setBounds(50,50,300,300);
                theFrame.pack();
                theFrame.setVisible(true);      

        }// buildGUI 메소드 끝

        /* 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드 */
        public void setUpMidi(){
                try{
                        sequencer= MidiSystem. getSequencer();
                        sequencer.open();
                        sequence = new Sequence(Sequence.PPQ,4);
                        track = sequence.createTrack();
                        sequencer.setTempoInBPM(120);
                }catch(Exception e){e.printStackTrace();}
        }//setUpMidi 메소드 끝

        // 체크상자의 상태를 MIDI이벤트로 바꾼 후 이벤트를 트랙에 추가합니다.
        public void buildTrackAndStart(){
                int [] trackList = null; 
                /* 각 악기의 열여섯 박자에 대한 값을 원소가 16개인 배열에 저장합니다. 
                                               어떤 악기가 특정 박자에서 연주되어야하면 그 원소의 값에 건반 번호를 넣습니다. 
                                               반대로 연주되어야 하지 않는다면 0을 집어넣습니다.*/

                /* 기존 트랙을 제거하고 트랙을 새로 만듭니다.*/
                sequence.deleteTrack(track);
                track = sequence.createTrack();

                
                for(int i = 0; i< 16; i++){//열 16개 모두에 대해 같은 작업을 처리합니다.
                        trackList = new int[16];

                        int key = instruments[i]; // 어떤 악기인지 정하는 번호를 설정합니다.


                        for(int j = 0; j<16 ; j ++) // 이 열에 들어 있는 모든 박자에 대해 같은 작업을 반복합니다.
                        {
                                JCheckBox jc = checkboxList.get(j + (16*i));
                                if(jc.isSelected()){
                                        trackList[j] = key;
                                }else{
                                        trackList[j] = 0;
                                } // 이 박자에 해당하는 체크상자가 선택되었는지 확인.
                                  // 선택되어 있으면 배열의 그 박자를 나타내는 자리에 건반 값을 집어넣습니다.
                                  // 그렇지 않으면 0을 선택합니다.
                        }//안쪽 for문 끝

                        makeTracks(trackList); //16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가합니다.
                        track.add(makeEvent1(176,1,127,0,16));
                }// 바깥쪽 for문 끝

                track.add(makeEvent1(192,9,1,0,15));
                try{
                        sequencer.setSequence(sequence);
                        sequencer.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);
                        sequencer.start();
                        sequencer.setTempoInBPM(120);
                }catch(Exception e){e.printStackTrace();} //드디어 연주
        } // buildTrackAndStart 메소드 끝

        /* 버튼의 리스너 */
        public class MyStartListener implements ActionListener {
                public void actionPerformed(ActionEvent a){
                        buildTrackAndStart();
                }
        } // 내부 클래스 끝

        public class MyStopListener implements ActionListener{
                public void actionPerformed(ActionEvent a){
                        sequencer.stop();
                }
        }// 내부 클래스 끝

        public class MyUpTempoListener implements ActionListener{
                public void actionPerformed(ActionEvent a){
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor * 1.03));
                }
        }// 내부 클래스 끝
        public class MyDownTempoListener implements ActionListener {
                public void actionPerformed(ActionEvent a){
                        float tempoFactor = sequencer.getTempoFactor();
                        sequencer.setTempoFactor((float)(tempoFactor* .97));
                }
        }// 내부 클래스 끝
        
        /* 패턴 직렬화 */
        public class MySendListener implements ActionListener{
        	
        	public void actionPerformed(ActionEvent a){//사용자가 버튼을 클릭해서 ActionEvent가 발생된 경ㅇ우에 실행됩ㄴ다.
        		boolean[] checkboxState = new boolean[256];//각 체크상자의 상태를 담아두기 위한 부울 배열을 만듭니다.
        		
        		for (int i = 0 ; i < 256 ; i++){
        			
        			JCheckBox check = (JCheckBox) checkboxList.get(i);
        			//checkboxList를 훑어보면서 각 체크상태의 상태를 확인하고 그 결과를 부울 배열에 추가합니다.
        			if (check.isSelected()){
        				checkboxState[i] =true;
        			}
        		}
        		
        		try{
        			FileOutputStream fileStream = new FileOutputStream(new File("checkbox.ser"));
        			ObjectOutputStream os = new ObjectOutputStream(fileStream);
        			os.writeObject(checkboxState);        			
        		} catch(Exception ex){
        			ex.printStackTrace();
        		}
        	}
        }
        
        
        /* 비트박스 프로그램 패턴 복구입니다. */
        public  class MyReadInListener implements ActionListener {

                public void actionPerformed(ActionEvent a){
                        boolean [] checkboxState = null;
                        try{
                                FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
                                ObjectInputStream is = new ObjectInputStream(fileIn);
                                checkboxState = (boolean [])is.readObject();
                                // 파일에서 객체 하나를 읽은 다음 부울 배열로 다시 캐스트합니다.
                        }catch(Exception ex){ex.printStackTrace();}

                        for(int i = 0; i<256; i++){
                                JCheckBox check = (JCheckBox) checkboxList.get(i);
                                // 실제 JCheckBox 객체로 구성된 ArrayList에 들어있는 각각의 체크상자의 상태를  원래대로 복구합니다.
                                
                                if(checkboxState[i]){
                                        check.setSelected(true);
                                }else{
                                        check.setSelected(false);
                                }
                        }
                        sequencer.stop();
                        buildTrackAndStart();
                        // 현재 연주 중인 것을 멈추고 ArrayList에 들어있는 체크상자의 새로운 상태를 이용하여 시퀀스를 재구성합니다.
                        
                } // 메소드 끝
        } // 내부 클래스 끝

        /* 리스너 다 만들었다.*/
        
        /* 한 악기의 16박자 전체에 대해 이벤트를 생성. 
        int[]배열에는 악기에 해당하는 건반 번호 또는 0이 들어갑니다.
        0이 들어있다면 그 박자에서는 해당 악기가	연주되지 않아야 합니다.
        0이 아닌 값이 들어있다면 이벤트를 만들어서 트랙에 추가합니다. */
        public void makeTracks(int [] list){
                for(int i=0;i<16;i++){
                        int key = list[i];

                        if(key!=0){

                                // NOTE ON과 NOTE OFF 이벤트를 만들고 트랙에 추가합니다.                
                                track.add(makeEvent1(144,9,key,100,i));
                                track.add(makeEvent1(128,9,key,100,i+1));
                        }
                }
        }

        public MidiEvent makeEvent1(int comd, int chan , int one, int two, int tick){
                MidiEvent event = null;
                try{
                        ShortMessage a = new ShortMessage();
                        a.setMessage(comd,chan,one,two);
                        event = new MidiEvent ( a, tick);

                }catch(Exception e){e.printStackTrace();}
                return event;

        }
        

}//클래스 끝
}}}