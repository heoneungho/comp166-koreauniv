#summary 김건희의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{ 


public class BeerSong {
        public static void main (String[] args) {
                int beerNum = 99;
                String word = "bottles"; 

                while (beerNum > 0 ) {

                        if (beerNum ==1) {
                                word = "bottle";
                        }

                        System.out.println(beerNum + " " + word + " of beer on the wall");
                        System.out.println(beerNum + " " + word + " of beer.");
                        System.out.println("Take one down.");
                        System.out.println("Pass it around.");
                        beerNum = beerNum -1;



                        if(beerNum == 0)  {
                                System.out.println("No more bottles of beer on the wall"); 
}
}
}
}


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
        public static void main (String[] args) {

                String [] wordListOne = {"A is a","B is b","C is c","E is e","F is F"};

                String [] wordListTwo = {"G is g","H is h","I is i","J is j","K is K"};

                String [] wordListThree = {"L is l","M is m","N is n","O is o","P is P"," I love English haha..."};

                int oneLength = wordListOne.length;
                int twoLength = wordListTwo.length;
                int threeLength = wordListThree.length;

                int rand1 = (int) (Math.random() * oneLength);
                int rand2 = (int) (Math.random() * twoLength);
                int rand3 = (int) (Math.random() * threeLength);

                String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

                System.out.println("Lets Sing a Happy English Song " + phrase);
        }
}



}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 
-프로그램을 실행한다. 결과를 출력한다.
-원래 들어가야 할 것이 아닌 다른 유형의 값이 들어갈 때는 ClassCast Exception을 발생시킨다.
-보안 관련 작업을 처리한다. 
-바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 그걸 건드리지 않았는지 확인한다.

 * 컴파일러:
-파일을 준다.
-문법이 맞았는지 틀렸는지 본다.
-자바에서 바이트코드 컴파일러를 사용한다. (자바가 순수한 인터프리터 언어라면 실행할 때 가상머신에서 텍스트 편집기로 만든 소스 코드를 해석해야 되고, 자바 프로그램 실행 속도는 무지막지하게 느리게 된다.)
-심각한 위반사항을 막아준다.(변수에 이상한 유형의 데이터를 저장할 수 없다.)
-세미콜론 등을 체크한다.
-비공개 메소드를 호출하려고 한다거나 (보안상의 이유로) 절대 바꿔서는 안 되는 메소드를 변경하려는 것과 같은 접근 위반을 방지한다.
-다른 클래스의 핵심적인 내용에 접근하는 코드와 같이 사람들이 함부로 보면 안 되는 코드를 건드리려는 등의 일을 방지한다.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A. class Exercise1b {
         public static void main(String [] args) {
             int x = 1;
         
             while (x<10) {

                x=x+1;   

                if(x>3)  {
                   System.out.println("big x"); 
                   }
               }
          }
}

B,C. class Exercise1b {           // B. we have to put the "class ~"
       public static void main(String [] args) {  
                          // C. we have to put the "public static ~" 

       int x = 5;
       while (x>1) {
 
       x=x-1;

       if (x<3)  {
         System.out.println("small x");
       }
       }
       }
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것. 객체의 상태(데이터)를 나타내며 그 유형에 속하는 각 객체마다 값이 다르다. 인스턴스(instance)란 객체(object)와 같다.
 * 메소드: 객체에서 자신이 하는 것. 객체에서 할 수 있는 일.
 * 클래스: 객체를 만들기 위한 청사진. 실제로 사용할 객체의 유형을 나타내는 클래스
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel
                  sound
 * 메소드: setChannel()
           setSound()
           


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
	  p1 = new Player();
	  p2 = new Player();
	  p3 = new Player();
	  p4 = new Player();

	  int guessp1 = 0;
	  int guessp2 = 0;
	  int guessp3 = 0;
	  int guessp4 = 0;

	  boolean p1isRight = false;
	  boolean p2isRight = false;
	  boolean p3isRight = false;
	  boolean p4isRight = false;

	  int targetNumber = (int) (Math.random() * 10);
	  System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

	  while(true) {
	   System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

	   p1.guess();
	   p2.guess();
	   p3.guess();
	   p4.guess();

	   guessp1 = p1.number;
	   System.out.println("1번 숫자가 찍은 숫자: " + guessp1);

	   guessp2 = p2.number;
	   System.out.println("2번 숫자가 찍은 숫자: " + guessp2);

	   guessp3 = p3.number;
	   System.out.println("3번 숫자가 찍은 숫자: " + guessp3);

	   guessp4 = p4.number;
	   System.out.println("4번 숫자가 찍은 숫자: " + guessp4);

	   if (guessp1 == targetNumber) {
		p1isRight = true;
	   }

	   if (guessp2 == targetNumber) {
		p2isRight = true;
	   }

	   if (guessp3 == targetNumber) {
		p3isRight = true;
	   }	   
	
	   if (guessp4 == targetNumber) {
		p4isRight = true;
	   }

	   if (p1isRight || p2isRight || p3isRight) {

		System.out.println("맞춘 선수가 있습니다.");
		System.out.println("1번 선수: " + p1isRight);
		System.out.println("2번 선수: " + p2isRight);
		System.out.println("3번 선수: " + p3isRight);
		System.out.println("4번 선수: " + p4isRight);
		System.out.println("게임 끝.");
		break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.

	   } else {
		// 아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
		System.out.println("다시 시도해야 합니다.");
	   } // if/else 부분 끝
	} // 순환문 끝
      } // 메소드 끝
} //클래스 끝

public class Player {
	int number = 0; // 찍은 숫자를 저장할 변수

	public void guess() {
		number = (int) (Math.random() * 10);
		System.out.println("찍은 숫자: " + number);
	}
}


public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}



}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

A.
{{{
public class TapeDeck{
        boolean canRecord = false;
        
        void playTape(){
                System.out.println("tape playing");
        }
        
        void recordTape(){
                System.out.println("tape recording");
        }
}

public class TapeDeckTestDrive {
        public static void main(String[] args) {
                TapeDeck t = new TapeDeck(); 
                
                t.canRecord = true;
                t.playTape();
                
                if (t.canRecord == true){
                        t.recordTape();
                }
        }
}
}}}

B
{{{
public class DVDPlayer {
        boolean canRecord = false;
        
        void recordDVD(){
                System.out.println("DVD recording");
        }
        
        void playDVD(){
                System.out.println("DVD playing");
        } 
}

public class DVDPlayerTestDrive {
        public static void main(String[] args) {
                
                DVDPlayer d = new DVDPlayer();
                d.canRecord = true;
                d.playDVD();
                
                if(d.canRecord == true){
                        d.recordDVD();
                }
        }
}


}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

원시변수-정수, 부울, 부동소수점 수와 같은 기초적인 값(단순한 비트 패턴으로 나타낼수 있는 값)이 들어간다. 원시 변수를 사용할 때는 변수에 어떤 값이 저장된다.
레퍼런스 변수-객체에 대한 레퍼런스가 들어간다. 레퍼런스 변수를 사용할 때는 특정 객체에 접근하는 방법을 나타내는 비트가 변수 값이 된다.
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
	String name;
	public static void main (String[] args) {

	// 이번에는 Dog 배열을 만듭니다.
	Dog[] myDogs = new Dog[4];
	// 그리고 개를 몇 마리 집어넣습니다.
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = new Dog();
	myDogs[3] = new Dog();

	myDogs[0].name = "Fred";
	myDogs[1].name = "Marge";
	myDogs[2].name = "Arin";
	myDogs[3].name = "Haru";

	// 순환문을 써서 배열에 들어있는 모든 개가 짖도록 합니다.
	int x = 0;
	while(x < myDogs.length) {
	  myDogs[x].bark();
	  x = x + 1;
	  }
	}

	public void bark() {
	  System.out.println(name + "이(가) 왈!하고 짖습니다.");
	}
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

A
{{{
class Books {
        String title;
        String author;
}

class BooksTestDrive {
        public static void main(String [] args) {

        Books [] myBooks = new Books[3];

        // Book을 집어 넣어야합니다.
        myBooks[0] = new Books();
        myBooks[1] = new Books();
        myBooks[2] = new Books();

        myBooks[0].title = "The Grapes of Java";
        myBooks[1].title = "The Java Gatsby";
        myBooks[2].title = "The Java Cookbook";
        myBooks[0].author = "bob";
        myBooks[1].author = "sue";
        myBooks[2].author = "ian";

        int x = 0;
        while(x<3) {
                System.out.print(myBooks[x].title);
                System.out.print(" by ");
                System.out.println(myBooks[x].author);
                x=x+1;
                }
        }
}
~                 

}}}

B
{{{
class Hobbits {

        String name;

        public static void main(String [] args) {

                Hobbits [] h = new Hobbits[3];
                int z = 0;

                while (z < 3) { // z=3일 때 while문을 빠져나옵니다.

                h[z] = new Hobbits();
                h[z].name = "bilbo";
                if (z == 1) {
                  h[z].name = "frodo";
                }
                if (z == 2) {
                  h[z].name = "sam";
                }
                System.out.print(h[z].name + " is a ");
                System.out.println("good Hobbit name");

                z = z+1; // while문 끝에서 z의 값이 1씩 증가해야합니다.
                }
        }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥 Bob
 * 문제가 된 부분은 어딘가요?: 밥의 메소드에서 만든 Contact 객체 중에서 마지막 것을 제외한 나머지는 접근할 수가 없다는 문제가 있다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 인스턴스 변수를 부적절한 값으로 설정하지 못하게 한다.
 * 게터와 세터: 게터 - 인스턴스 변수의 값을 알아내기 위한 메소드, 일반적으로 인스턴스 변수의 값을 리턴함
세터 - 인스턴스 변수의 값을 설정하기 위한 메소드, 전달된 값을 확인하고 인스턴스 변수의 값을 설정함
 * 인스턴스 변수 vs 지역 변수: 선언되는 위치 - 인스턴스 변수는 클래스 내에서, 지역 변수는 메소드 내에서
초기화 - 인스턴스 변수는 기본 초기값이 있고(숫자 원시 변수는 0, 부울형은 false, 객체 레퍼런스는 null이라는 기본 초기값이 있다.), 지역 변수는 기본 초기값이 없음
 
*107p Dog* _실행_

{{{
class Dog {
        int size;
        String name;

        void bark() {
                if (size > 60) {
                System.out.println("Woof!Wooof!");
                }else if (size >14 ) {
                System.out.println("Ruff! Ruff!");
                } else {
                System.out.println("Yip! Yip!");
                }
        }
}

class DogTestDrive {

        public static void main (String[] args) {

        Dog one = new Dog();
        one.size = 70;
        Dog two = new Dog();
        two.size = 8;
        Dog three = new Dog();
        three.size = 35;

        one.bark();
        two.bark();
        three.bark();
        }
}


}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

A
{{{
class XCopy {

        public static void main(String [] args) {

        int orig = 42;
        XCopy x = new XCopy();
        int y = x.go(orig);

        System.out.println(orig+" "+y);
        }

        int go(int arg) {

        arg = arg * 2;

        return arg;
        }
}

}}}

B
{{{
class Clock {
        String time;

        void setTime(String t) {
          time = t;
        }

        String getTime() { // return 의 유형은 String 이여야 합니다.
          return time;
        }
}

class ClockTestDrive {
  public static void main(String [] args) {

        Clock c = new Clock();

        c.setTime("1245");
        String tod = c.getTime();
        System.out.println("time: " + tod);

  }
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
최근의 소프트웨어 개발 방법론 분야에 새로 등장한 방법으로, 가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는 점이다. 
XP의 규칙에는 다음이 있다. -조금씩, 자주 발표한다 -사이클을 반복해서 돌리면서 개발한다 -스펙에 없는 것은 절대 집어넣지 않는다 -테스트 코드를 먼저 만든다 -항상 정규 일과 시간에만 작업한다 등이 있다.

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotCom {                //SimpleDotCom 클래스 입니다.

        int[] locationCells;  //셀의 위치를 저장하기 위한 int 배열을 선언합니다.
        int numOfHits = 0;     //맞춘 셀의 개수를 저장하기 위한 int를 선언합니다.

        public void setLocationCells(int[] locs) {
                locationCells = locs;
        }  // int배열(셀 위치 세 개를 나타냄)을 받아들이는 세터 메소드입니다.

        public String checkYourself(String stringGuess) { 
        //사용자가 추측한 위치를 string으로 받아들이고 그 값을 확인하고 결과를 리턴하는 메소드입니다.

                int guess = Integer.parseInt(stringGuess); //사용자가 추측한 위치를 string 매개변수 형태로 받아와 int로 변환합니다.
                
                String result = "miss";
                
                for (int i=0 ; i<locationCells.length; i++) {
                        if(guess == locationCells[i]) {
                                result = "hit";
                                numOfHits++;
                                break;
                        } // 만약 추측한 것이 맞으면 맞춘 갯수를 증가시킵니다.
                }

                if (numOfHits == locationCells.length) {
                        result = "kill";
                } // 만약 맞춘 횟수가 3이면 kill을 결과로 리턴합니다.

                System.out.println(result);
                        return result;
        } 
}                                             //클래스 끝


public class SimpleDotComGame {          //SimpleDotComGame 클래스입니다

public static void main(String[] args) {

        int numOfGuesses  = 0;        // 추측한 횟수를 추적하기 위한 변수
        GameHelper helper = new GameHelper();

        SimpleDotCom theDotCom = new SimpleDotCom();

        int randomNum = (int) (Math.random() * 5);
        int[] locations = {randomNum, randomNum+1, randomNum+2};
                              // 난수를 만들어 셀 위치 배열을 만듭니다.

        theDotCom.setLocationCells(locations);

        boolean isAlive = true;  //게임의 상태를 나타내는 isAlive라는 부울변수를 선언하고 true로 설정합니다.

        while(isAlive == true) {
                String guess = helper.getUserInput("enter a number");
                String result = theDotCom.checkYourself(guess);

                numOfGuesses++;

                if(result.equals("kill")) {
                        isAlive = false;  //순환문이 중단됩니다.
                        System.out.println(numOfGuesses + "guesses");
                } //만약 결과가 kill이면 사용자가 추측한 횟수를 출력합니다.
        }
}
}                                                    // 클래스 끝


import java.io.*;                           //GameHelper 클래스입니다


public class GameHelper {
        public String getUserInput(String prompt) {
                String inputLine = null;
                System.out.print(prompt + " ");
                try {
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));

                inputLine = is.readLine();

                if(inputLine.length() == 0 )  return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                return inputLine;
        }
}                                                     //클래스 끝

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{
{{{

public class FirstSimpleDotCom
{
        int[] locationCells;
        int numOfHits = 0;
        boolean[] hitCells = {false, false, false};//hitCells 배열(DotCom에 새로 추가할 부울 배열 인스턴스 변수)을 선언하고 모두 false로 초기화해줍니다.
        
        public void setLocationCells(int [] locs)
        {
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess)
        {
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ;i < locationCells.length; i++)
                {
                        if(guess == locationCells[i]&& hitCells[i] == false)
                        {
                        //5단원의 기존 조건문에서 추가로 이미 맞춘 셀이 아닌가를 판별합니다.
                                result = "hit";
                                hitCells[i] = true; //hitCells를 true로 설정해줍니다
                                numOfHits++;
                                break;
                        }
                }

        
        if(numOfHits == locationCells.length)
        {
                result = "kill";
        }
        System.out.println(result);
        return result;

        }
}
//사용자가 맞출 때마다 두번째 배열('hitCells' 배열)의 상태를 바꿔야 합니다. 그 리고 그 전에 'hitCells' 배열을 확인하여 이미 맞춘 적이 있는지 확인해야 합니다. 이 때문에 작업이 복잡해집니다.

public class SimpleDotComGame {          //SimpleDotComGame 클래스입니다(5단원의 코드와 동일합니다.)

public static void main(String[] args) {

        int numOfGuesses  = 0;        // 추측한 횟수를 추적하기 위한 변수
        GameHelper helper = new GameHelper();

        SimpleDotCom theDotCom = new SimpleDotCom();

        int randomNum = (int) (Math.random() * 5);
        int[] locations = {randomNum, randomNum+1, randomNum+2};
                              // 난수를 만들어 셀 위치 배열을 만듭니다.

        theDotCom.setLocationCells(locations);

        boolean isAlive = true;  //게임의 상태를 나타내는 isAlive라는 부울변수를 선언하고 true로 설정합니다.

        while(isAlive == true) {
                String guess = helper.getUserInput("enter a number");
                String result = theDotCom.checkYourself(guess);

                numOfGuesses++;

                if(result.equals("kill")) {
                        isAlive = false;  //순환문이 중단됩니다.
                        System.out.println(numOfGuesses + "guesses");
                } //만약 결과가 kill이면 사용자가 추측한 횟수를 출력합니다.
        }
}
}                                                    // 클래스 끝


import java.io.*;                           //GameHelper 클래스입니다


public class GameHelper {
        public String getUserInput(String prompt) {
                String inputLine = null;
                System.out.print(prompt + " ");
                try {
                        BufferedReader is = new BufferedReader(
                        new InputStreamReader(System.in));

                inputLine = is.readLine();

                if(inputLine.length() == 0 )  return null;
                } catch (IOException e) {
                        System.out.println("IOException: "+ e);
                }
                return inputLine;
        }
}                                                     //클래스 끝


}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상속을 이용하여 설계할 때는 공통적인 코드를 어떤 클래스에 넣은 다음, 다른 더 구체적인 클래스에 공통적인(더 추상적인)클래스가 상위클래스라는 것을 알려주면 된다. 한 클래스가 다른 클래스를 상속하는 것을 하위클래스가 상위클래스로부터 상속받는다고 말한다.
하위클래스가 상위클래스의 멤버(인스턴스 변수와 메소드)를 물려받는다는 것을 의미한다.

 * 다형성: 일련의 클래스에 대한 상위클래스를 만들면 그 상위클래스 형식이 들어갈 수 있는 모든 자리에 해당 상위클래와 임의 하위클래스에 속하는 객체를 마음대로 사용할 수 있다. 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다. 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 한다.
 * 오버로딩: 메소드 오버로딩은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것이다. 이를 활용하면 호출하는 쪽의 편의를 위해 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100% 추상클래스이다. 자바 키워드이다. 자바의 인터페이스는 죽음의 다이아몬드(줄여서 DDD) 때문에 생기는 부작용없이 다중 상속의 다형적인 장점을 대부분 누릴 수 있게 해 줌으로써 다중 상속 문제를 해결해준다.
 
 * 다형성: '여러 형태'를 의미한다. 상위클래스 유형을 메소드의 인자나 리턴 유형 또는 배열 유형으로 쓸 수 있게 만드는 능력이 필요하다. 그래야만 새로운 유형을 처리하기 위한 새로운 메소드를 추가하거나 기존의 메소드를 고칠 필요 없이 프로그램에 새로운 하위클래스 유형을 추가할 수 있다.

 * 추상 클래스: 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스를 의미한다.

 * 추상 메소드: 반드시 오버라이드해야하는 메소드를 의미한다. 추상 메소드를 만드는 이유는 실제 메소드 코드를 전혀 집어넣지는 않았더라도 일련의 하위클래스를 위한 규약(protocol)의 일부를 정의하기 위한 것이다.

 * 다중 상속: 상위클래스를 두 개 사용하는 접근법이다. 자바에서는 다중 상속을 쓸 수 없다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 모든 객체가 사는 곳으로, 인스턴스 변수는 객체 안에 들어있다.

 * 스택에서의 변수: 메소드 호출과 지역 변수가 사는 곳으로, 지역 변수는 스택 변수라고도 부른다.

 * 생성자: Constructor. 객체를 생성할 때 실행되는 코드가 들어있다. 모든 클래스에 생성자가 들어있다. 직접 만들지 않아도 컴파일러에서 자동으로 생성자를 만들어준다. 객체의 상태를 초기화하는 작업은 대부분 생성자에서 처리한다.

 * 널 레퍼런스: 객체 레퍼런스 제거 방법. 레퍼런스를 null로 설정하는 것은 리모컨의 기능을 해제하는 것과 같다. 즉 리모컨은 있는데 그 리모컨으로 조종할 TV가 없는 셈이다. 널 레퍼런스에는 '널'을 나타내는 비트들이 들어있다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객체가 살아있는 동안 살 수 있음.마지막 레퍼런스가 사라지면 그 객체는 가비지 컬렉션 대상이 된다.

 * 지역 변수: 그 변수를 선언한 메소드 안에서만 살 수 있음. 삶(life)-지역 변수는 스택 프레임이 스택에 들어있는 한 계속 살아있다. 영역(scope)-지역 변수의 영역은 그 변수를 선언한 메소드 내로 제한됩니다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}