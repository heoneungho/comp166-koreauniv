#summary 2012190727 한혜원 자바자바자바
<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong{           //class 선언
      public static void main(String[] args)  {           //main함수 선언
           int beerNum = 99;           beerNum이라는 정수형변수 선언 후 99값 저장
           String word = "bottles";        //복수형

           while (beerNum > 0) {           //while 순환문 시작

                 if (beerNum == 1) {
                       word = "bottle";             //단수형(한 병인 경우)
                }

               System.out.println(beerNum + " " + word + " of beer on the wall");
               System.out.println(beerNum + " " + word + " of beer.");
               System.out.println("Take one down.");
               System.out.println("Pass it around.");
               beerNum = beerNum - 1;

               if (beerNum > 0 ) {
                     System.out.println(beerNum + " " + word + " of beer on the wall");
               } else {
                    System.out.println("No more bottles of beer on the wall");
               } // else 문 끝
          } // while 순환문 끝
     } // main 클래스 끝
} // 클래스 끝


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic{
     public static void main (String[] args) {

     // 세 종류의 단어목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다. 
          String[] wordListOne = {"24/7", "multi-
Tier", "30,000 foot", "B-to-B", "win-win", "front-
end", "web-based", "pervasive", "smart"", "six-
sigma", "critical-path", "dynamic"};

     String[] wordListTwo = { "empowered", "stricky",
"valued-added", "oriented", "centric", "distributed", 
"clustered", "branded", "outside-the-box", "positioned",
"networked", "focused", "leveraged", "aligned",
"targeted", "shared", "cooperative", "accelerated"};

     String[] wordListThree = {"process", "tipping-
point", "solution", "architecture", "core competency",
"strategy", "mindshare", "portal", "space", "vision", 
"paradigm", "mission"};

     //각 목록에 단어가 몇 개씩 들어있는지 확인합니다.
     int oneLength = wordListOne.length;
     int twoLength = wordListTwo.length;
     int threeLength = wordListThree.length;

     //난수 세 개를 발생시킵니다.
     int rand1 = (int) (Math.random() * oneLength);
     int rand2 = (int) (Math.random() * twoLength);
     int rand3 = (int) (Math.random() * threeLength);

     //이제 구문을 만듭니다.
     String phase = wordListOne[rand1] + " " +
wordListTwo[rand2] + " " + wordLIstThree[rand3];

     System.out.println("What we need is a " + phase);
     }
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램실행, 보안, 동적 바인딩 지원, 바이트 코드가 만들어진 후 바이트 코드가 실행되기 전까지 다른 누군가가 건드리지 않았는지 확인하는 작업 수행
 * 컴파일러: 파일전송, 문법확인, 바이트코드작성, 데이터유형위반사항검사, 접근위반 방지

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b {
     public static void main(String [] args) {
          int x = 1;
          while ( x < 10 ) {
               x = x + 1;
               if ( x > 3 ) {
                    System.out.println("big x");
               }
          }
     }
}

class Foo{
     public static void main(String [] args) {
          int x = 5;
          while ( x > 1 ) {
               x = x - 1;
               if ( x < 3) {
                    System.out.println("small x");
               }
          }
     }
}

class Exercise1b {
     public static void main(String [] args) {
          int x = 5;
          while ( x > 1) {
               x = x - 1;
               if ( x < 3 ) {
                    System.out.println("small x");
               }
          }
     }
}


}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것. 객체의 상태(데이터). 객체를 부르는 다른 이름
 * 메소드: 객체에서 할 수 있는 일
 * 클래스: 객체를 만들기 위한 청사진
 * 테스트용 클래스:
 

*68p Television* _채워넣기_

 * 인스턴스 변수:
 * 메소드:TurnOn(), TurnOff(), VolumeUp(), VolumeDown(), 


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame






}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class TapeDeck{
     boolean canRecord = false;
     void playTape() {
          System.out.println("tape playing");
     }
     void recordTape() {
          System.out.println("tape recording");
     }
}

class TapeDeckTestDrive{
     public static void main(String [] args) {
          TapeDeck += new TapeDeck();
          t.canRecord = true;
          t.playTape();

          if (t.canRecord == true) {
               t.recordTape();
          }
     }
} 

class DVDPlayer{
     boolean canRecord = false;
     void recordDVD() {
          System.out.println("DVD recordings");
     }
     void playDVD() {
          System.out.println("DVD recording");
     }
}

class DVDPlayerTestDrive {
     public static void main(String [] args) {
          DVDPlayer d = new DVDPlayer();
          d.canRecord = true;
          d.playDVD();
          if (d.canRecord == true) {
               d.recordDVD();
          }
     }
}



}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog {
     String name;
     public static void main (String[] args) {
          // Dog 객체를 만들고 접근합니다.
          Dog dog 1 = new Dog();
          dog1.bark();
          dog1.name = "Bart";

          // 이번에는 Dog 배열을 만듭니다.
          Dog[] myDogs = new Dog[3];
          // 그리고 개를 몇 마리 집어넣습니다.
          myDogs[0] = new Dog();
          myDogs[1] = new Dog();
          myDogs[2] = dog1;

          // 배열 레퍼런스를 써서 Dog 객체에 접근합니다.
          myDogs[0].name = "Fred";
          myDogs[1].name = "Marge";

          // myDogs[2]의 이름이 뭐였지?
          System.out.print("마지막 개의 이름: ");
          System.out.println(myDogs[2].name);

          //이제 순환문을 사용하여 배열에 속해있는 모든 개가 짖도록 합시다.
          int x = 0;
          while(x < myDogs.length) {
               myDogs[x].bark();
               x = x + 1;
          }
     }

     public void bark() {
          System.out.println(name + "이(가) 왈! 하고 짖습니다.");
     }
     public void eat() {  }
     public void chaseCat() {  }
}



}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class Books {
     String title;
     String author;
}

class BooksTestDrive {
     public static void main(String [] args) {
          Books [] myBooks = new Books[3];
          int x = 0;
          myBooks[0] = new Books();
          myBooks[1] = new Books();
          myBooks[2] = new Books();
          myBooks[0].title = "The Grapes of Java";
          myBooks[1].title = "The Java Gatsby";
          myBooks[2].title = "The Java Cookbook";
          myBooks[0].author = "bob";
          myBooks[1].author = "sue";
          myBooks[2].author = "ian";
          while ( x < 3) {
               System.out.print(myBooks[x].title);
               System.out.print(" by ");
               System.out.println(myBooks[x].author);
               x = x + 1;
          }
     }
}

class Habbits{
     String name;
     public static void main (String [] args) {
           Hobbits [] h = new Hobbits[3];
               int z = -1;
               while( z < 2) {
               z = z + 1;
               h[z] = new Hobbits();
               h[z].name = "bilbo";
               if ( z == 1) {
                    h[z].name = "frodo";
               }
               if ( z == 2) {
                    h[z].name = "sam";
               }
               System.out.print(h[z].name + " is a ");
               System.out.println("good Hobbit name");
          }
     }
} 


}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:
 * 문제가 된 부분은 어딘가요?:

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
 * 게터와 세터:
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_

{{{

class Dog {
     int size;
     String name;
 
     void bark() {
          if (size > 60) {
               System.out.println("Wooof!  Wooof!");
          } else if (size > 14) {
                 System.out.println("Ruff!  Ruff!");
          }  else {
                 System.out.println("Yip!  Yip!");
          }
     }
}

class DogTestDrive{

     public static void main (String[] args) {
          Dog one = new Dog();
          one.size = 70;
          Dog two = new Dog();
          two.size = 8;
          Dog three = new Dog();
          three.size = 35;

          one.bark();
          two.bark();
          three.bark();
     }
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class XCopy {
     public static void main(String [] args) {
          int orig = 42;
          XCopy x = new XCopy();
          int y = x.go(orig);
          System.out.println(orig + " " + y);
     }

     int go(int arg) {
          arg = arg * 2;
          return arg;
     }
} 

class Clock{
     String time;
     void setTime(String t) {
          time = t;
     }
     String getTime() {
          return time;
     }
}

class ClockTestDrive{
     public static void main(String [] args) {
          Clock c = new Clock();
          c.setTime("1245");
          String tod = c.getTime();
          System.out.println("time: " + tod);
     }
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_ 익스트림 프로그래밍(XP, eXtreme Programming)이라는 방법은 

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotComTestDrive {
     public static void main (String [] args) {
          SimpleDotCom dot = new SimpleDotCom();
          // SimpleDotCom클래스의 인스턴스를 만든다.

          int[] locations = {2, 3, 4};
          dot.setLocationCells(locations);
    
          String userGuess = "2";
          String result = dot.checkYourself(userGuess);
          String testResult = "failed";
          if (result.equals("hits")) {
               testResult = "passed";
          }
          System.out.println(testresult);
     }
} 


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{




}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 
 * 오버로딩: 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것. 오버로드된 메소드는 다형성과는 전혀 관계가 없다. 

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class MonsterTestDrive {
     public static void main ( String [] args) {
          Monster [] ma = new Monster[3];
          ma[0] = new Vampire();
          ma[1] = new Dragon();
          ma[2] = new Monster();
          for ( int x = 0; x < 3 ; x ++) {
               ma[x].frighten(x);
          }
     }
}

class Monster{
     boolean frighten ( int d) {
          System.out.println("arrrgh");
          return true;
     }
}

class Vampire extends Monster {
     boolean frighten(int x) {
          System.out.println("a bite?");
          return false;
     }
}

class Dragon extends Monster {
     boolean frighten ( int degree) {
          System.out.println("breath fire");
          return true;
     }
}


}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 100% 추상 클래스
 * 다형성: 여러 형태
 * 추상 클래스: 인스턴스를 만스들 수 없는 클래스
 * 추상 메소드: 반드시 오버라이드 해야하는 메소드. 추상 메소드를 만들 때는 클래스도 반드시 추상 클래스로 만들어야 한다. 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없다. 추상 메소드를 만드는 이유는 실제 메소드 코드를 잔혀 집어넣지 않았더라도 일련의 하위클래스를 위한 규약의 일부를 정의하기 위함. 
 * 다중 상속: multiple inheritance, 상위클래스를 두 개 사용하는 접근법에 발생하는 한 가지 문제점. 자바에서는 다중 상속 사용 불가. '죽음의 다이아몬드'라고 알려진 문제가 있기 때문.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{



}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

import javax.sound.midi.*;

public class MiniMusicCmdLine {

     public static void main(String[] args) {
          MiniMusicCmdLine mini = new MiniMusicCmdLine();
          if (args.length < 2) {
               System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
          } else {
               int instrument = Integer.parseInt (args[0]);
               int note = Integer.parseInt(args[1]);
               mini.play(instrument, note);
          }
     }

     public void play(int instrument, int note) {
     
     try {

          Sequencer player = MidiSystem.getSequencer ();
          player.open();
          Sequence seq = new Sequence(Sequence.PPQ, 4);
          Track track = seq.createTrack();

          MidiEvent event = null;

          Short Message first = new ShortMessage();
          first.setMessage(192, 1, instument, 0);
          MidiEvent changeInstrument = new MidiEvent(first, 1);
          track.add(changeInstrument);

          ShortMessage a = new ShortMessage();
          a.setMessage(144, 1, note, 100);
          MidiEvent noteOn = new MideEvent (a, 1);
          track.add(noteOn);

          ShortMessage b = new ShortMessage();
          b.setMessage(128, 1, note, 100);
          MidiEvent noteOff = new MidiEvent(b, 16);
          track.add(noteOff);
          player.setSequence(seq);
          player.start();

          } catch (Exception ex) { ex.printStackTrace();}
     }
}

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

import javax.swing.*;

public class SimpleGuil {
     public static void main (String[] args) {

          JFrame frame = new JFrame();
          JButton button = new JButton("click me");

          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

          frame.getContentPane().add(button);

          frame.setSize(300,300);

          frame.setVisible(true);
     }
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

import javax.swing.*;
import.java.awt.event.*;

public class SimpleGui1B implements ActionListener {
     JButton button;

     public static void main (String[] args) {
          SimpleGui1B gui = new SimpleGui1B();
          gui.go();
     }

public void go() {
     JFrame frame = new JFrame();
     button = new JButton("click me");

     button.addActionListener(this);

     frame.getContentPane().add(button);
     frame.setDeFaultCloseOperation(JFrame.EXIT_ON_CLOSE);
     frame.setSize(300,300);
     frame.setVisible(true);
}

public void actionPerformed(ActionEvent event) {
     button.setText("I've been clicked!");
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{



}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}