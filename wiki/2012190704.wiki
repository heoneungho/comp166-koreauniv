#summary 수업중 실습하는 내용을 올리게 되는 실습페이지입니다. 페이지의 내용은 각 학생에 의해서 관리됩니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong {       //클래스 선언
        public static void main (String[] args) {      //main 메소드 선언
                int beerNum=99;       //병의 수를 나타내는 변수 선언
                String word="bottles";  //복수형

                while (beerNum > 0) {

                        if (beerNum == 1) {
                                word = "bottle";        //단수형
                        }

                        System.out.println(beerNum + " "+ word + " of beer on the wall");
                        System.out.println(beerNum + " "+ word + " of beer.");
                        System.out.println("Take one down.");
                        System.out.println("Pass it around.");
                        beerNum = beerNum - 1;

                        if (beerNum > 0) {
                                System.out.println(beerNum + " " + word + " of beer on the wall");
                        } else {
                                System.out.println("No more bottles of beer on the wall");
                        }     //else문 끝
                }     //while순환문 끝
        }     //main클래스 끝
}     //클래스 끝 
}}}
*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_
{{{
public class PhraseOMatic {
     public static void main (String[] args) {

          String[] wordListOne = {"Korea", "university", "computer", "education"};
          String[] wordListTwo = {"likes", "wants", "does", "works"};
          String[] wordListThree = {"pizza", "math", "actor", "music"};

          int oneLength = wordListOne.length;
          int twoLength = wordListTwo.length;
          int threeLength = wordListThree.length;

          int rand1 = (int) (Math.random() * oneLength);
          int rand2 = (int) (Math.random() * twoLength);
          int rand3 = (int) (Math.random() * threeLength);

          String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

          System.out.println("What we need is a " + phrase);
          }
}

}}}
*52p 집중토론* _요약_

 * 자바 가상 머신: (Java Virtual Machine)바이트코드로 컴파일된 코드를 실행시켜 주는 프로그램.
 * 컴파일러: 자바언어로 작성된 프로그램을 바이트코드로 변환시키는 것.

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class Exercise1b {
     public static void main(String [] args) {
          int x = 1;
          while (x < 10) {
               x = x + 1;     //while문의 무한 반복을 막기 위해 x를 1씩 증가시킴.
               if (x > 3) {
                    System.out.println("big x");
               }
          }
     }
}

class Exercise1b {     //class를 정의해야 함.
     public static void main(String [] args) {
          int x = 5;
          while (x > 1) {
               x = x - 1;
               if (x < 3) {
                    System.out.println("small x");
               }
          }
     }
}

class Exercise1b {
     public static void main(String [] args) {     //메소드를 정의해야 함.
          int x = 5;
          while (x > 1) {
               x = x - 1;
               if (x < 3) {
                    System.out.println("small x");
          }
     }
}
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 자신에 대해 아는 것. 객체의 상태(데이터)를 나타냄.
 * 메소드: 객체에서 자신이 하는 것(할 수 있는 일).
 * 클래스: 객체를 만들기 위한 청사진.
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스.
 

*68p Television* _채워넣기_

 * 인스턴스 변수: channel, volume
 * 메소드: setChannel(), setVolume()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_
{{{
public class GuessGame {
        Player p1;
        Player p2;
        Player p3;
        Player p4;

        public void startGame() {
                p1 = new Player();
                p2 = new Player();
                p3 = new Player();
                p4 = new Player();

                int guessp1 = 0;
                int guessp2 = 0;
                int guessp3 = 0;
                int guessp4 = 0;

                boolean p1isRight = false;
                boolean p2isRight = false;
                boolean p3isRight = false;
                boolean p4isRight = false;

                int targetNumber = (int) (Math.random() * 10);
                System.out.println("0 이상9 이하의 숫자를 맞춰보세요.");

                while(true) {
                        System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

                        p1.guess();
                        p2.guess();
                        p3.guess();
                        p4.guess();

                        guessp1 = p1.number;
                        System.out.println("1번 선수가 찍은 숫자: " + guessp1);

			guessp2 = p2.number;
                        System.out.println("2번 선수가 찍은 숫자: " + guessp2);

			guessp3 = p3.number;
                        System.out.println("3번 선수가 찍은 숫자: " + guessp3);

			guessp4 = p4.number;
                        System.out.println("4번 선수가 찍은 숫자: " + guessp4);

		        if (guessp1 == targetNumber) {
				p1isRight = true;
			}

			if (guessp2 == targetNumber) {
				p2isRight = true;
			}

			if (guessp3 == targetNumber) {
				p3isRight = true;
			}

			if (guessp4 == targetNumber) {
				p4isRight = true;
			}

			if (p1isRight || p2isRight || p3isRight || p4isRight)	{

				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수:  " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p2isRight);
				System.out.println("게임 끝.");
				break;	//게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.

			}	else {
				// 아무도 못 맞췄기 때문에 계속 해야 합니다 .
				System.out.println("다시 시도해야 합니다.");
			}	// if/else 부분 끝
		}	// 순환문 끝
	}	//메소드 끝
}	// 클래스 끝
}}}
{{{
public class Player {
     int number = 0;     //찍은 숫자를 저장할 변수

     public void guess() {
          number = (int) (Math.random() * 10);
          System.out.println("찍은 숫자: " + number);
     }
}
}}}
{{{
public class GameLauncher {
     public static void main (String[] args) {
          GuessGame game = new GuessGame();
     }
}
}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
                A
class TapeDeck {

     boolean canRecord = false;

     void playTape() {
          System.out.println("tape playing");
     }

     void recordTape() {
          System.out.println("tape recording");
     }
}

class TapeDeckTestDrive {
     public static void main(String [] args) {
    
          TapeDeck t = new TapeDeck();     //TapeDeck 객체 생성과 t라는 레퍼런스변수 선언

          t.canRecord = true;
          t.playTape();

          if (t.canRecord == true) {
               t.recordTape();
          }
     }
}


                B
class DVDPlayer {

	boolean canRecord = false;

	void recordDVD() {
		System.out.println("DVD recording");
	}

	void playDVD() {     //DVD재생하는 메소드 생성
		System.out.println("DVD playing");
	}
}

class DVDPlayerTestDrive {
	public static void main(String[] args) {

		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();

		if (d.canRecord == true) {
			d.recordDVD();
		}
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
-'원시변수'에는 정수, 부울, 부동소수점 수와 같은 기초적인 값이 들어감.
-'레퍼런스변수'에는 객체에 대한 레퍼런스가 들어감.

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{
class Dog {
     String name;
     public static void main (String[] args) {
          //Dog객체를 만들고 접근합니다.
          Dog dog1 = new Dog();
          Dog dog2 = new Dog();
          dog1.bark();
          dog1.name = "Bart";
          dog2.name = "Song";

          //이번에는 Dog 배열을 만듭니다.
          Dog[] myDogs = new Dog[5];
          //그리고 개를 몇마리 집어넣습니다.
          myDogs[0] = new Dog();
          myDogs[1] = new Dog();
          myDogs[2] = dog1;
          myDogs[3] = new Dog();
          myDogs[4] = dog2;

          //배열 레퍼런스를 써서 Dog객체에 접근합니다.
          myDogs[0].name = "Fred";
          myDogs[1].name = "Marge";

          //myDogs[4]의 이름 출력.
          System.out.print("마지막 개의 이름: ");
          System.out.println(myDogs[4].name);

          //순환문을 써서 배열에 들어있는 모든개가 짖도록 함.
          int x = 0;
          while(x < myDogs.length) {
               myDogs[x].bark();
               x = x + 1;
          }
     }

     public void bark() {
          System.out.println(name + "이(가) 왈!하고 짖습니다.");
     }
     public void eat() { }
     public void chaseCat() { }
}

     
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
         A

class Books {
     String title;
     String author;
}

class BooksTestDrive {
     public static void main(String [] args) {

          Books [] myBooks = new Books[3];     //Books 배열 생성.
          int x = 0;
          //Books 객체 생성.
          myBooks[0] = new Books();
          myBooks[1] = new Books();
          myBooks[2] = new Books();
          //배열 레퍼런스를 써서 Books 객체에 접근.
          myBooks[0].title = "The Grapes of Java";
          myBooks[1].title = "The Java Gatsby";
          myBooks[2].title = "The Java Cookbook";
          myBooks[0].title = "bob";
          myBooks[1].title = "sue";
          myBooks[2].title = "ian";

          //배열에 있는 모든 책의 제목과 저자 출력.
          while (x < 3) {
               System.out.print(myBook[x].title);
               System.out.print(" by ");
               System.out.println(myBooks[x].author);
               x = x + 1;
           }
     }
}

         B

class Hobbits {

     String name;

     public static void main(String [] args) {

          Hobbits [] h = new Hobbits[3];
          int z = 0;

          while (z < 3) {     //배열은 0부터 시작하므로 (z < 4)를 (z < 3)으로 수정.
               h[z] = new Hobbits();
               h[z].name = "bilbo";
               if (z == 1) {
                    h[z].name = "frodo";
               }
               if (z == 2) {
                    h[z].name = "sam";
               }
               System.out.print(h[z].name + " is a ");
               System.out.println("good Hobbit name");
               z = z + 1;     //z의 초기값이 0이므로 z의 값을 순환문을 한번 돈 후 증가 시켜야 함.
          }
     }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 하나를 제외한 나머지 Contact객체에 접근할 수 없다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 인스턴스 변수의 노출을 막기 위해 데니터를 숨기는 것. 인스턴스 변수를 private으로 지정하고, public으로 지정된 케터와 세터를 만들면 됨.
 * 게터와 세터: 각각 어떤 것(보통 인스턴스 변수의 값)을 가져오고(get) 설정하는(set) 역할.
 * 인스턴스 변수 vs 지역 변수: 
인스턴스 변수는 클래스 내에서 선언.
지역변수는 메소드 내에서 선언. 사용하기 전 반드시 초기화.
 
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;

	void bark() {
		if (size > 60) {
			System.out.println("Woof! Woof!");
		}
		else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		}
		else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {

	public static void main (String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;

		one.bark();
		two.bark();
		three.bark();
	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

          A

class XCopy {

	public static void main(String [] args) {
		
		int orig = 42;

		XCopy x = new XCopy();

		int y = x.go(orig);     //orig값의 두배를 y에 대입.

		System.out.println(orig + " " + y);
	}

        //숫자의 크기를 2배로 증가시키는 메소드.
	int go(int arg) {
		
		arg = arg * 2;

		return arg;
	}
}
//컴파일 됨. 출력 결과 : 42 84


          B

class Clock {
	String time;

	void setTime (String t) {
		time = t;
	}

	String getTime() {     // time을 반환해야 하므로 return type이 void가 아니라 String이여야 함.
		return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {

		Clock c = new Clock();

		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time: " + tod);
	}
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

90년대 말에 등장한 소프트웨어 개발 방법론 중 하나.
'조금씩, 하지만 자주 발표', '사이클을 반복해서 돌리면서 개발', '테스트 코드를 먼저 만듦', '기회가 생기는 족족 언제 어디서든 코드를 개선함' 등의 일련의 규칙이 있다.

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotComTestDrive {

	public static void main (String[] args) {
		SimpleDotCom dot = new SimpleDotCom();
		int[] locations = {2,3,4};
		dot.setLocationCells(locations);
		String userGuess = "2";
		String result = dot.checkYourself(userGuess);
	} //메소드 끝
} //클래스 끝

public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0;

	public void setLocationCelss(int[] locs) {
		locationCells = locs;
	}

	public String checkYourself(String stringGuess) {	//사용자가 추측한 위치를 받아옵니다.
		int guess = Integer.parseInt(stringGuess);	//사용자가 추측한 위치를 int로 변환.
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i]) {
				result = "hit";	//맞춘 횟수가 3미만일 경우 "hit"을 결과로 리턴.
				numOfHits++;
				break;
			}
		} //순환문 끝

		if (numOfHits == locationCells.length) {	//마지막 셀인지 확인.
			result = "kill";	//맞춘 횟수가 3이면 "kill"을 결과로 리턴.
		}
		System.out.println(result);
			return result;
	} //메소드 끝
} //클래스 끝

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

<수정한 SimpleDotCom.java>
{{{
public class SimpleDotCom {

	int[] locationCells;
	boolean[] hitCells;	/*이미 맞춘 문제인지 확인하기 위해 추가한 배열.*/
	int numOfHits = 0;

	public void setLocationCelss(int[] locs) {
		locationCells = locs;
	}

	public String checkYourself(String stringGuess) {	//사용자가 추측한 위치를 받아옵니다.
		int guess = Integer.parseInt(stringGuess);	//사용자가 추측한 위치를 int로 변환.
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i] && hitCells[i] != true) {	/*hitCells배열을 통해 이미 맞춘 문제가 아닐 때만 실행.*/
				result = "hit";	//맞춘 횟수가 3미만일 경우 "hit"을 결과로 리턴.
				hitCells[i] = true;	/*맞춘 문제임을 저장.*/
				numOfHits++;
				break;
			}
		} //순환문 끝

		if (numOfHits == locationCells.length) {	//마지막 셀인지 확인.
			result = "kill";	//맞춘 횟수가 3이면 "kill"을 결과로 리턴.
		}
		System.out.println(result);
			return result;
	} //메소드 끝
} //클래스 끝

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

<수정한 SimpleDotCom.java>
{{{
public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0;

	public void setLocationCelss(int[] locs) {
		locationCells = locs;
	}

	public String checkYourself(String stringGuess) {	//사용자가 추측한 위치를 받아옵니다.
		int guess = Integer.parseInt(stringGuess);	//사용자가 추측한 위치를 int로 변환.
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if (guess == locationCells[i] && locationCells[i] != -1) {	/*locationCells의 값이 -1이면 이미 맞춘 위치이므로 넘어감.*/
				result = "hit";	//맞춘 횟수가 3미만일 경우 "hit"을 결과로 리턴.
				locationCells[i] = -1;	/*맞춘 것을 나타내기 위해 locationCells의 값을  -1로 변경.*/
				numOfHits++;
				break;
			}
		} //순환문 끝

		if (numOfHits == locationCells.length) {	//마지막 셀인지 확인.
			result = "kill";	//맞춘 횟수가 3이면 "kill"을 결과로 리턴.
		}
		System.out.println(result);
			return result;
	} //메소드 끝
} //클래스 끝
}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList;
//ArrayList 채용

public class DotCom {

	private ArrayList<String> locationCells;     //배열대신 String이 들어가는 ArrayList사용.
	//private int numOfHits;
	//(없어도 됩니다 )

	public void setLocationCells (ArrayList<String> loc) {
		locationCells = loc;
	}

	public String checkYourself (String userInput) {
		
		String result = "miss";

			int index = locationCells.indexOf(userInput);
                        //사용자가 추측한 위치가 ArrayList에 들어있는지 확인.
                        //들어있으면 인덱스번호가, 그렇지 않으면 -1이 리턴됨.

			if (index >= 0) {

				locationCells.remove(index);
                                //인덱스가 0이상이면 사용자가 추측한 위치가 목록에 들어있는 것이므로 제거.   

				if (locationCells.isEmpty()) {
					result = "kill";
				} else {
					result = "hit";
				}	//if문 끝

			}	//바깥쪽 if문 끝

		return result;
	}	//메소드 끝
}	//클래스 끝

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{
}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 상위(부모)클래스에서 하위(자식)클래스로 인스턴스변수와 메소드를 넘겨주는 것.
 * 다형성: 다형성을 활용하면 레퍼런스와 객체가 다른 유형이어도 됨. 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있음. 새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없음.

*208p 클래스 계층 구조* _클래스로 구현_

{{{
public class Animal{
 char picture;
 int food
 int boudaries;
 int location;
 boolean hunger;
 void sound(){ }
 void eat(){ }
 void sleep(){ }
 void roam(){ }
}
class Feline extends Animal{
 void roam(){ }
 void sleep(){ }
}
class Hippo extends Animal{
 void sound(){ }
 void eat(){ }
}
class Lion extends Feline{
 void sound(){ }
 void eat(){ }
}
class Tiger extends Feline{
 void sound(){ }
 void eat(){ }
}
class Cat extends Feline{
 void sound(){ }
 void eat(){ }
}
class Canine extends Animal{
 void roam(){ }
}
class Wolf extends Canine{
 void sound(){ }
 void eat(){ }
}
class Dog extends Canine{
 void sound(){ }
 void eat(){ }
}

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야 함. 접근 단계는 그대로 유지하거나 완화시켜야 함.
 * 오버로딩: 메소드 오버로딩은 이름이 같고 인자 목록이 다른 메소드 두 개를 만드는 것. 인자 목록만 다르면 리턴 유형이 달라도 됨. 더 제한이 심한 메소드를 만들 수 있음. 

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive{
	public static void main(String [] args){
		Monster [] ma = new Monster[3]; // ma 배열을 생성합니다.
		ma[0] = new Vampire();
		ma[1] = new Monster();
		ma[2] = new Monster();
		for(int x = 0; x < 3; x++){ // 메소드를 생성합니다.
			ma[x].frighten(x);
		}
	}
}

class Monster{ // 놀랐을 때 하는 행동
	boolean frighten(int d){
		System.out.println("arrrgh");
		return true;
	}
}

class Vampire extends Monster{ // 뱀파이어가 몬스터를 확장한다.
	boolean frighten(int x){
		System.out.println("a bite?");
		return false;
	}
}

class Dragon extends Monster{ // 드래곤이 몬스터를 확장한다.
	boolean frighten(int degree){
		System.out.println("breath fire");
		return true;
	}
}


}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스: 다중 상속의 문제를 해결.
 * 추상 클래스: 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스.
 * 추상 메소드: 반드시 오버라이드해야하는 메소드.
 * 다중 상속: 상위클래스를 두 개 이상 사용하는 것.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 레퍼런스가 지역변수든 인스턴스변수든 상관없이 모든 객체는 힙에 저장.
 * 스택에서의 변수: 객체 레퍼런스 변수도 원시 변수와 마찬가지로 지역변수로 선언했으면 스택에 저장.
 * 생성자: 생성자에는 객체를 생성할 때 실행되는 코드가 들어있음. 즉, 어떤 클래스 유형에 대해 new키워드를 사용했을 때 실행되는 코드가 들어있음. 모든 클래스에는 생성자가 있음.
 * 널 레퍼런스: 레퍼런스 변수에 null을 대입하여 아무것도 가리키지 않는 레퍼런스.
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{
import java.util.*;
class V2Radiator{ // 클래스 선언
	V2Radiator(ArrayList list){
		for(int x=0; x<5; x++){ // 심플유닛 생성
			list.add(new SimUnit("V2Radiator"));
		}
	}
}

class V3Radiator extends V2Radiator{ // 클래스 선언
	V3Radiator(ArrayList lglist){
		super(lglist); // 상위클래스에서 가져옴
		for(int g=0; g<10; g++){ // 심플유닛 생성
			lglist.add(new SimUnit("V3Radiator"));
		}
	}
}

class RetentionBot{ // 클래스 선언
	RetentionBot(ArrayList rlist){ 
		rlist.add(new SimUnit("Retention"));//심플유닛 생성
	}
}

public class TestLifeSupportSim{
	public static void main(String [] args){
		ArrayList aList = new ArrayList(); // 배열을 생성
		V2Radiator v2 = new V2Radiator(aList);
		V3Radiator v3 = new V3Radiator(aList);
		for(int z=0; z<20; z++){ // 실행될때마다 메세지를 출력
			RetentionBot ret = new RetentionBot(aList);
			System.out.println(z+1 + "unit");
		}
	}
}

class SimUnit{
	String botType;
	SimUnit(String type){
		botType = type;
	}
	int powerUse(){
		if("Retention".equals(botType)){
			return 2;
		}else{
			return 4;
		}
	}
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드: "인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가 필요하지 않습니다. 클래스만 있어도 됩니다."를 의미.
 * 정적 메소드를 선언하는 방법: static 키워드 사용.
 * static final: static final로 선언된 변수는 상수. 클래스가 로딩되어있는 동안 계속 똑같은 값을 유지시킴.
 * 오토 박싱: 원시값과 래퍼 객체 사이의 변환을 자동으로 처리해주는 기능.
 * 정적 임포트: 기본 개념은 정적 클래스, 정적 변수, enum 값 등을 사용할 때 타이핑을 적게 하게 함. 정적 임포트 기능을 잘못 사용하면 코드의 가독성이 떨어짐. 정적 임포트를 선언할 때 와일드카드(.*)를 쓸 수도 있음.

*339p Calendar* _구현후 주석달기_

{{{
import java.util.*;
public class Calender{
        public static void main(String[] args){
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40); // 시각을 2004년 1월 7일 15:40으로 설정
                   long day1 = c.getTimeInMillis(); // 1970년 1월 1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴
                   day1 += 1000*60*60;
                c.setTimeInMillis(day1); // 한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시간을 갱신.
                System.out.println("new hour " + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35); // 35일을 더합니다.
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35); // 35일 뒤로 넘깁니다.
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1); // 날짜를 1로 설정
                   System.out.println("set to 1 " + c.getTime());
}
}

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수: 객체지향적.
 * 정적 변수: Color클래스에 표준적인 색을 상수로 지정해놓음. System.out의 out은 System클래스의 정적 변수. 클래스마다 하나씩. 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
class StaticSuper{

  static{
    System.out.println("super static block");
  }

  StaticSuper{
    System.out.println(
      "super constructor");
  }
}

public class StaticTests extends StaticSuper{ // 클래스 확장
  static int rand;

  static{
    rand = (int) (Math.random() * 6);
    System.out.println("static block " + rand);
  }

  staticTests(){
    System.out.println("constructor");
  }

  public static void main(String [] args){ // 메인메소드
    System.out.println("in main");
    StaticTests st = new StaticTests();
  }
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{
public void takeRisk() throws BadException{ // 예외를 선언하는 과정
  if(abandonAllHope){
    throw new BadException(); // 새로운 Exception 객체를 만들고 던짐.
  }
}

public void crossFingers(){
  try{
    anObject.takeRisk();
  }
  catch(BadException ex){
    System.out.println("Aaargh!");
    ex.printStackTrace(); 
  }
}

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{
import javax.sound.midi.*; // 미디패키지를 반드시 불러와야 합니다.

public class MiniMiniMusicApp{
	
		public static void main(String[] args){
			MiniMiniMusicApp mini = new MiniMiniMusicApp();
			mini.play();
		}
		
		public void play(){
			try{
				Sequencer player = MidiSystem.getSequencer(); // Sequencer을 받아서 엽니다.
				player.open();
				
				Sequence seq = new Sequence(Sequence.PPQ,4);
				
				Track track = seq.createTrack(); // Sequence에 Track을 요청.
				
				ShortMessage a = new ShortMessage(); // Track에 MidiEvent를 집어넣습니다.
				a.setMessage(144,1,44,100);
				MidiEvent noteOn = new MidiEvent(a, 1);
				track.add(noteOn);
				
				ShortMessage b = new ShortMessage();
				b.setMessage(128, 1, 44, 100);
				MidiEvent noteOff = new MidiEvent(b, 16);
				track.add(noteOff);
				
				player.setSequence(seq); // Sequencer에 Sequence를 보냅니다.
				
				player.start(); // Sequencer의 start()메소드를 호출합니다.
			}catch(Exception ex){
				ex.printStackTrace();
			}
		}
}

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{
import javax.sound.midi.*;

public class MiniMusicCmdLine { // 첫번째
	
	public static void main(String[] args){
		MiniMusicCmdLine mini = new MiniMusicCmdLine();
		if (args.length < 2){
			System.out.println("악기와 음 높이를 지정하는 인자를 입력하세요.");
		} else{
			int instrument = Integer.parseInt(args[0]);
			int note = Integer.parseInt(args[1]);
			mini.play(instrument, note);
		}
	} // main 끝
	
	public void play(int instrument, int note) {
		
		try{
			
			Sequencer player = MidiSystem.getSequencer(); // Sequencer을 받아서 연다.
			player.open();
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack(); // Sequence에 Track을 요청
			
			MidiEvent event = null;
			
			ShortMessage first = new ShortMessage(); // Track에 MidiEvent를 집어넣는다.
			first.setMessage(192, 1, instrument, 0);
			MidiEvent changeInstrument = new MidiEvent(first,1);
			track.add(changeInstrument);

			ShortMessage a = new ShortMessage();
			a.setMessage(144,1,note,100);
			MidiEvent noteOn = new MidiEvent(a,1);
			track.add(noteOn);
			
			ShortMessage b = new ShortMessage();
			b.setMessage(128,1,note,100);
			MidiEvent noteOff = new MidiEvent(b, 16);
			track.add(noteOff);
			player.setSequence(seq); // Sequencer에 Sequence를 보낸다.
			player.start(); // Sequencer의 Start()메소드를 호출.
			
		}catch(Exception ex){ ex.printStackTrace();}
	} // play메소드 끝
} // class 끝

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{
import javax.swing.*;	

public class SimpleGui1 {
	public static void main(String[] args) {
		
		JFrame frame = new JFrame();     //프레임 생성
		JButton button = new JButton("click me");     'click me'라고 표시된 버튼 생성

		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);     //창을 닫으면 프로그램이 바로 종료

	
		frame.getContentPane().add(button);     //버튼을 프레임의 내용 틀(content pane)에 추가

		frame.setSize(300,300);     //프레임의 크기를 픽셀단위로 지정

		frame.setVisible(true);     //화면에 표시되도록 설정
	}
}

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{
import javax.swing.*;
import java.awt.event.*;     //ActionListener와 ActionEvent가 들어있는 패키지를 사용하기 위한 import선언

public class SimpleGui1B implements ActionListener {     //인터페이스 구현
	JButton button;

	public static void main (String[] args) {
		SimpleGui1B gui = new SimpleGui1B();
		gui.go();
	}

	public void go() {
		JFrame frame = new JFrame();
		button = new JButton("Click me");

		button.addActionListener(this);     //버튼에 등록 

		frame.getContentPane().add(button);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(300,300);
		frame.setVisible(true);
	}

	public void actionPerformed(ActionEvent event) {     //ActionListener인터페이스의 actionPerformed()메소드를 구현
		button.setText("I've been clicked!");     //이벤트가 일어났다는 것을 알려줌.
	}
}

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {

	JFrame frame;

	public static void main (String[] args) {
		SimpleGui3C gui = new SimpleGui3C();
		gui.go();
	}

	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		JButton button = new JButton("Change colors");
		button.addActionListener(this);	//Listener(this)를 버튼에 추가

		MyDrawPanel drawPanel = new MyDrawPanel();

		frame.getContentPane().add(BorderLayout.SOUTH, button);	//위젯(버튼)을 프레임에 추가
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);	//위젯(그림 패널)을 중앙 지역에 추가 
		frame.setSize(300,300);
		frame.setVisible(true);
	}

	public void actionPerformed(ActionEvent event) {
		frame.repaint();	//사용자가 버튼을 클릭하면 프레임의 repaint()메소드를 호출
	}
}

class MyDrawPanel extends JPanel {

	public void paintComponent(Graphics g) {
		//타원을 무작위적으롤 선택한 색으로 칠하기 위한 코드
		g.fillRect(0,0,this.getWidth(), this.getHeight());	//패널 전체를 검은색(기본색)으로 칠함.

		int red = (int) (Math.random() * 255);
		int green = (int) (Math.random() * 255);
		int blue = (int) (Math.random() * 255);

		Color randomColor = new Color(red, green, blue);	//각각 빨간색, 녹색, 파란색 성분(RGB)을 나타내는 정수 세 개를 전달하여 색을 만듦.
		g.setColor(randomColor);
		g.fillOval(70,70,100,100);	//왼쪽에서 70픽셀, 위에서 70픽셀 떨어진 위치에 너비가 100픽셀, 높이가 100픽셀인 원을 그림.
	}
}

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TwoButtons {

	JFrame frame;
	JLabel label;

	public static void main(String[] args) {
		TwoButtons gui = new TwoButtons ();
		gui.go();
	}

	public void go() {
		frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		JButton labelButton = new JButton("Change Label");
		labelButton.addActionListener(new LabelListener());     //버튼의 리스너 등록메소드에 다른 리스너 클래스(내부 클래스)를 가지고 만든 객체를 전달.

		JButton colorButton = new JButton("Change Circle");
		colorButton.addActionListener(new ColorListener());

		label = new JLabel("I'm a label");
		MyDrawPanel drawPanel = new MyDrawPanel();

		frame.getContentPane().add(BorderLayout.SOUTH, colorButton);
		frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
		frame.getContentPane().add(BorderLayout.EAST, labelButton);
		frame.getContentPane().add(BorderLayout.WEST, label);

		frame.setSize(300,300);
		frame.setVisible(true);

	}

	class LabelListener implements ActionListener {     
		public void actionPerformed(ActionEvent event) {
			label.setText("Ouch!");     //내부 클래스에서도 'label'변수 사용 가능능
		}
	}	//내부 클래스 끝

	class ColorListener implements ActionListener {
		public void actionPerformed(ActionEvent event) {
			frame.repaint();     //내부 클래스에서는 외부 클래스 객체에 대한 레퍼런스 없이 그냥 'frame' 인스턴스 변수 사용
		}
	}	//내부 클래스 끝
}

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {

	int x = 70;
	int y = 70;
	//메인 GUI클래스에 원의 x와 y좌표를 저장하기 위한 인스턴스 변수 두 개 만듦.

	public static void main (String[] args) {
		SimpleAnimation gui = new SimpleAnimation();
		gui.go();
	}

	public void go() {
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		MyDrawPanel drawPanel = new MyDrawPanel();	

		frame.getContentPane().add(drawPanel);
		frame.setSize(300,300);
		frame.setVisible(true);

		for (int i = 0; i < 130; i++) {	//130번  반복 
			
			x++;
			y++;

			drawPanel.repaint();	//스스로 다시 칠하게 함. 

			try {
				Thread.sleep(50);	//보이도록 속도 늦춤.
			}catch(Exception ex) {}
		}	//애니메이션을 수행하는 부분 
	}	//go() 메소드 끝

	class MyDrawPanel extends JPanel {

		public void paintComponent(Graphics g) {
			g.setColor(Color.green);
			g.fillOval(x, y, 40, 40);	//지속적으로 갱신되는 외부 클래스의 x와 y좌표 사용 
		}
	}	//내부 클래스 끝
}	//외부 클래스 끝

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {

	static JFrame f = new JFrame("My First Music Video");
	static MyDrawPanel ml;

	public static void main(String[] args) {
		MiniMusicPlayer3 mini = new MiniMusicPlayer3();
		mini.go();
	}	//메소드 끝

	public void setUpGui() {
		ml = new MyDrawPanel();
		f.setContentPane(ml);
		f.setBounds(30,30,300,300);
		f.setVisible(true);
	}	//메소드 끝

	public void go() {
		setUpGui();

		try {
			
			Sequencer sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequencer.addControllerEventListener(ml,new int[] {127});
			Sequence seq = new Sequence(Sequence.PPQ, 4);
			Track track = seq.createTrack();

			int r = 0;
			for (int i = 0; i < 60; i += 4) {
			
				r = (int) ((Math.random() * 50) + 1);
				track.add(makeEvent(144,1,r,100,i));
				track.add(makeEvent(176,1,127,0,i));
				track.add(makeEvent(128,1,r,100,i+2));
			}	//순환문 끝

			sequencer.setSequence(seq);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		}catch (Exception ex) {ex.printStackTrace();}
	}	//메소드 끝

	public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd, chan, one, two);
			event = new MidiEvent(a, tick);

		}catch (Exception e) {}
		return event;
	}	//메소드 끝

	class MyDrawPanel extends JPanel implements ControllerEventListener {
		boolean msg = false;

		public void controlChange(ShortMessage event) {
			msg = true;
			repaint();
		}
	
		public void paintComponent(Graphics g) {
			if (msg) {
	
				Graphics2D g2 = (Graphics2D) g;
	
				int r = (int) (Math.random() * 250);
				int gr = (int) (Math.random() * 250);
				int b = (int) (Math.random() * 250);
	
				g.setColor(new Color(r, gr, b));
	
				int ht = (int) ((Math.random() * 120) + 10);
				int width = (int) ((Math.random() * 120) + 10);
	
				int x = (int) ((Math.random() * 40) + 10);
				int y = (int) ((Math.random() * 40) + 10);
	
				g.fillRect(x, y, ht, width);
				msg = false;
	
			}	// if문 끝
		}	//메소드 끝
	}	//내부 클래스 끝

}	//클래스 끝 

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;

public class BeatBox {

	JPanel mainPanel;
	ArrayList<JCheckBox> checkboxList;     //체크상자를 ArrayList에 저장.
	Sequencer sequencer;
	Sequencer sequence;
	Track track;
	JFrame theFrame;
	
	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat",
			"Open Hi-Hat","Acoustic Snare","Crash Cymbal","Hand Clap",
			"Cowbell","Vibraslap","Low-mid Tom","High Agogo",
			"Open Hi Conga"};
	int[] instruments = {35,45,46,38,49,39,50,60,70,72,64,56,58,47,67,63};
	
	public static void main (String[] args) {
		new BeatBox().buildGUI();
	}
	
	public void buildGUI() {
		theFrame = new JFrame("Cyber BeatBox");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		BorderLayout layout = new BorderLayout();
		JPanel background = new JPanel(layout);
		background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
		
		checkboxList = new ArrayList<JCheckBox>();
		Box buttonBox = new Box(BoxLayout.Y_AXIS);
		
		JButton start = new JButton("Start");
		start.addActionListener(new MyStartListener());
		buttonBox.add(start);
		
		JButton start = new JButton("Stop");
		stop.addActionListener(new MyStopListener());
		buttonBox.add(stop);
		
		JButton upTempo = new JButton("Tempo Up");
		upTempo.addActionListener(new MyUpTempoListener());
		buttonBox.add(upTempo);
		
		JButton downTempo = new JButton("Tempo Down");
		downTempo.addActionListener(new MyDownTempoListener());
		buttonBox.add(downTempo);
		
		Box nameBox = new Box(BoxLayout.Y_AXIS);
		for(int i = 0; i< 16; i++) {
			nameBox.add(new Label(instrumentNames[i]));
		}
		
		background.add(BorderLayout.EAST,buttonBox);
		background.add(BorderLayout.WEST,nameBox);
		
		theFrame.getContentPane().add(background);
		
		GridLayout grid = new GridLayout(16,16);
		grid.setVgap(1);
		grid.setHgap(2);
		mainPanel = new JPanel(grid);
		background.add(BorderLayout.CENTER,mainPanel);
		
		for(int i = 0; i < 256; i++) {
			JCheckBox c = new JCheckBox();
			c.setSelected(false);
			checkboxList.add(c);
			mainPanel.add(c);
		}
		
		setUpMidi();
		
		theFrame.setBounds(50,50,300,300);
		theFrame.pack();
		theFrame.setVisible(true);
	}
	
	public void setUpMidi() {
		try {
			sequencer = MidiSystem.getSequencer();
			sequencer.open();
			sequence = new Sequence(Sequence.PPQ,4);
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);
			
		} catch(Exception e) {e.printStackTrace();}
	}
	
	public void buildTrackAndStart() {
		int[] trackList = null;
		
		sequence.deleteTrack(track);
		track = sequence.createTrack();
		
		for(int i = 0; i< 16; i++) {
			trackList = new int[16];
			
			int key = instruments[i];
			
			for(int j=0; j<16; j++) {
				JCheckBox jc = checkboxList.get(j+(16*i));
				if(jc.isSelected()) {
					trackList[j] = key;
				} else {
					trackList[j] = 0;
				}
			}
			
			makeTracks(trackList);
			track.add(makeEvent(176,1,127,0,16));
		}
		
		track.add(makeEvent(192,9,1,0,15));
		try {
			sequencer.setSequence(sequence);
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);
			sequencer.start();
			sequencer.setTempoInBPM(120);
		} catch(Exception e) {e.printStackTrace();}
	}
	
	public class MyStartListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			buildTrackAndStart();
		}
	}
	
	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			sequencer.stop();
		}
	}
	
	public class MyUpTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((factor)(tempoFactor * 1.03));
		}
	}
	
	public class MyDownTempoListener implements ActionListener {
		public void actionPerformed(ActionEvent a) {
			float tempoFactor = sequencer.getTempoFactor();
			sequencer.setTempoFactor((float)(tempoFactor*.97));
		}
	}
	
	public void makeTracks(int[] list) {
		for(int i=0; i<16; i++) {
			int key = list[i];
			
			if(key !=0) {
				track.add(makeEvent(144,9,key,100,i));
				track.add(makeEvent(128,9,key,100,i+1));
			}
		}
	}
	
	public MidiEvent makeEvent(int comd,int chan,int one,int two, int tick) {
		MidiEvent event = null;
		try {
			ShortMessage a = new ShortMessage();
			a.setMessage(comd,chan,one,two);
			event = new MidiEvent(a,tick);
			
		} catch(Exception e) {e.printStackTrace();}
		return event;
	}
}

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{
import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Beatbox2{
	
	JPanel mainPanel;  
	ArrayList<JCheckBox> checkboxList; // 체크상자를 ArrayList에 저장. 
	Sequencer sequencer;  
	Sequence sequence;  
	Track track;  
	JFrame theFrame;
	String[] instrumentNames = {"Bass Drum", "Closed Hi-Hat", "Open Hi-Hat","Acoustic Snare", "Crash Cymbal", "Hand Clap", "High Tom", "Hi Bongo", "Maracas", "Whistle", "Low Conga", "Cowbell", "Vibraslap", "Low-mid Tom", "High Agogo",  "Open Hi Conga"}; // GUI 레이블을 만들 때 사용할 악기명 String 배열로 저장합니다. 
	int[] instruments = {35,42,46,38,49,39,50,60,70,72,64,56,58,47,67,63}; // 실제 드럼 '건반'을 나타냄.   
	// 35번 건반은 베이스 드럼을, 42번 건반은 하이햇을 나타내는 식.  
	
	public static void main (String[] args) {  
		new Beatbox2().buildGUI();  
		}    
	
	public void buildGUI() {   
		theFrame = new JFrame("Cyber BeatBox");   
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    
		BorderLayout layout = new BorderLayout();     
		JPanel background = new JPanel(layout);   
		background.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));     
		
		checkboxList = new ArrayList<JCheckBox>();  
		Box buttonBox = new Box(BoxLayout.Y_AXIS);    
		
		JButton start = new JButton("Start");    
		start.addActionListener(new MyStartListener());  
		buttonBox.add(start);    
		
		JButton stop = new JButton("Stop");  
		stop.addActionListener(new MyStopListener());    
		buttonBox.add(stop);    
		
		JButton upTempo = new JButton("Tempo Up");    
		upTempo.addActionListener(new MyUpTempoListener());   
		buttonBox.add(upTempo);    
		
		JButton downTempo = new JButton("Tempo Down");  
		downTempo.addActionListener(new MyDownTempoListener()); 
		buttonBox.add(downTempo);   
		
		Box nameBox = new Box(BoxLayout.Y_AXIS);           
		for (int i = 0; i < 16; i++) {     
			nameBox.add(new Label(instrumentNames[i]));  
			}               
		
		background.add(BorderLayout.EAST, buttonBox); 
		background.add(BorderLayout.WEST, nameBox);     
		
		theFrame.getContentPane().add(background);               
		GridLayout grid = new GridLayout(16,16);             
		grid.setVgap(1);      
		grid.setHgap(2);    
		mainPanel = new JPanel(grid);   
		background.add(BorderLayout.CENTER, mainPanel);   
		
		for (int i = 0; i < 256; i++) { // 체크상자를 만들고 모든 값을 'false'로 설정한 다음 arraylist와 gui패널에 추가.
			JCheckBox c = new JCheckBox();    
			c.setSelected(false);    
			checkboxList.add(c);         
			mainPanel.add(c);    
			}//순환문 끝
		
		setUpMidi();       
		
		theFrame.setBounds(50,50,300,300);   
		theFrame.pack();     
		theFrame.setVisible(true);     
		}//buidGUI 메소드 끝  
	
	public void setUpMidi() { // 시퀀서, 시퀀스, 트랙을 만들기 위한 일반적인 미디 관련 코드
		try {     
			sequencer = MidiSystem.getSequencer();  
			sequencer.open();     
			sequence = new Sequence(Sequence.PPQ,4);  
			track = sequence.createTrack();
			sequencer.setTempoInBPM(120);       
			
		} catch(Exception e) {e.printStackTrace();}  
		}     
	
	public void buildTrackAndStart() {   
		int[] trackList = null; // 각 악기의 열여섯 박자에 대한 값을 원소가 16개인 배열에 저장.     
		
		sequence.deleteTrack(track); // 기존 트랙을 제거하고 트랙을 새로 만듭니다. 
		track = sequence.createTrack(); 
		
		for (int i = 0; i < 16; i++) { // 열 16개에 대해 모두 같은 작업.    
			trackList = new int[16];       
			
			int key = instruments[i]; // 어떤 악기인지를 나타내는 건반 번호를 설정.        
			
			for (int j = 0; j < 16; j++ ) { // 이 열에 들어있는 모든 박자에 대해 같은 작업을 반복.
				
				JCheckBox jc = (JCheckBox) checkboxList.get(j + (16*i));      
				if ( jc.isSelected()){ // 이 박자에 해당하는 체크상자가 선택되었는지 확인. 그렇다면 배열에 건반을 집어넣고 아니면 0으로 설정. 
					trackList[j] = key;    
					} else {    
						trackList[j] = 0;    
						}                         
				} // 안쪽 for문 끝   
			
			makeTracks(trackList); // 이 악기의 16개의 모든 박자에 대해 이벤트를 만들고 트랙에 추가.    
			track.add(makeEvent(176,1,127,0,16)); 
			
		} // 바깥쪽 for문 끝         
		
		track.add(makeEvent(192,9,1,0,15)); // 16번째 박자에는 반드시 이벤트가 있어야 합니다. 이렇게 하지 않으면 다시 시작하기 전에 16박자가 모두 끝나지 않을 수도 있습니다. 
		try {
			sequencer.setSequence(sequence);  
			sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY); //루프 반복 횟수를 지정하기 위한 메소드.  
			sequencer.start(); // 연주합니다.     
			sequencer.setTempoInBPM(120);        
			} catch(Exception e) {e.printStackTrace();}                  
		} // buildTrackAndStart 메소드 끝                
	
public class MySendListener implements ActionListener{
	
	public void actionPerformed(ActionEvent a){
		boolean[] checkboxState = new boolean[256]; // 각 체크상자의 상태를 담아두기 위한 부울 배열.
		
		for(int i=0;i<256;i++){
			JCheckBox check = (JCheckBox) checkboxList.get(i); // 각 체크상자의 상태를 확인하고 그 결과를 부울배열에 추가
			if(check.isSelected()){
				checkboxState[i] = true;
			}
		}
		
		try{
			FileOutputStream fileStream = new FileOutputStream(new File("Checkbox.ser"));
			ObjectOutputStream os = new ObjectOutputStream(fileStream);
			os.writeObject(checkboxState);
		}catch(Exception ex){
			ex.printStackTrace();
		}
	}
}

public class MyReadInListener implements ActionListener{
	public void actionPerformed(ActionEvent a){
		boolean[] checkboxState = null;
		try{
			FileInputStream fileIn = new FileInputStream(new File("Checkbox.ser"));
			ObjectInputStream is = new ObjectInputStream(fileIn);
			checkboxState = (boolean[]) is.readObject(); // 파일에서 객체하나를 읽은 다음 부울배열로 다시 캐스트
		}catch(Exception ex) {ex.printStackTrace();}
		
		for(int i = 0; i < 256; i++){  // 각각의 체크상자의 상태를 원래대로 복구
			JCheckBox check = (JCheckBox) checkboxList.get(i);
		if(checkboxState[i]){
				check.setSelected(true);
			}else{
				check.setSelected(false);
			}
			sequencer.stop(); // 현재 연주중인것을 멈추고 시퀀스를 재구성
			buildTrackAndStart();
		}
	}
}
		

	
	
	
	
	public class MyStartListener implements ActionListener { // 첫번째 내부클래스
		public void actionPerformed(ActionEvent a) {  
			buildTrackAndStart();   
			}   
		} // 내부 클래스 끝
	
	public class MyStopListener implements ActionListener {
		public void actionPerformed(ActionEvent a)  {   
			sequencer.stop();  
			}  
		} // 내부 클래스 끝  
	
	public class MyUpTempoListener implements ActionListener { 
		public void actionPerformed(ActionEvent a) {      
			float tempoFactor = sequencer.getTempoFactor();       
			sequencer.setTempoFactor((float)(tempoFactor * 1.03)); // 속도를 빠르게증가시킵니다.  
			}  
		} // 내부 클래스 끝   
	
	public class MyDownTempoListener implements ActionListener{     
		public void actionPerformed(ActionEvent a) {   
			float tempoFactor = sequencer.getTempoFactor(); 
			sequencer.setTempoFactor((float)(tempoFactor * .97)); // 속도를 느리게감소시킵니다.      
			}    
		} // 내부 클래스 끝   
	
	public void makeTracks(int[] list) { //한 악기의 16박자 전체에 대해 이벤트를 만듭니다.0 또는 해당 악기의 건반 번호가 들어갑니다. 
                     for (int i = 0; i < 16; i++) {  
                    	 int key = list[i];       
                    	 
                    	 if (key != 0) {        
                    		 track.add(makeEvent(144,9,key, 100, i)); //NOTE ON과 NOTE OFF 이벤트를 만들고 트랙에 추가합니다.  
                    		 track.add(makeEvent(128,9,key, 100, i+1));             
                    		 }     
                    	 }  
	}
	

	
	public  MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {  
		MidiEvent event = null;           
		try  {   
			ShortMessage a = new ShortMessage();     
			a.setMessage(comd, chan, one, two);         
			event = new MidiEvent(a, tick);     
			
		}catch(Exception e){e.printStackTrace();}  
		return event;   
	}
}


}}}