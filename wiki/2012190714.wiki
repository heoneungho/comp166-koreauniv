#summary 김성미

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

/* 컴파일 시 마지막에 
1 bottles of beer on the wall
1 bottle of beer on the wall
1 bottle of beer.
Take one down.
Pass it around.
no more bottles of beer on the wall
이렇게 단, 복수 오류가 뜬다. 책의 코딩을 아래와 같이 고치면 */

public class Beersong {
	public static void main(String[] args) {
		
                int beerNum = 99;
		String word = "bottles"; //복수형
		
		while (beerNum>0){
			System.out.println(beerNum + " " + word + " of beer on the wall");
			System.out.println(beerNum + " " + word + " of beer.");
			System.out.println("Take one down.");
			System.out.println("Pass it around.");
			beerNum = beerNum-1;
			
			if (beerNum ==1){
				word = "bottle"; //단수형
			} //위의 네 줄과 순서를 바꾼 상태
			
			if (beerNum > 0){
				System.out.println(beerNum + " " + word + " of beer on the wall");
			}else{
				System.out.println("no more bottles of beer on the wall");
			} //else문 끝
		} //while문 끝

	} //main클래스 끝

} //클래스 끝

/* 고치면 
1 bottle of beer on the wall
1 bottle of beer on the wall
1 bottle of beer.
Take one down.
Pass it around.
no more bottles of beer on the wall
위와 같이 된다.*/
}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

//자동구문 생성기 - 내가 사는 곳

public class PhraseOMatic {
	public static void main(String[] args) {
		
                //세 종류의 단어 목록 
		String[] wordListOne = {"small","big","famous","beautiful"};
		String[] wordListTwo = {"town","city","countryside"};
		String[] wordListThree = {"Korea","Japan","China","Thailand","Singapore"};
		
		//각 단어 목록에 들어간 단어 개수
		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;
		
		//난수 세 개 발생
		int rand1 = (int)(Math.random()*oneLength);
		int rand2 = (int)(Math.random()*twoLength);
		int rand3 = (int)(Math.random()*threeLength);
		
		//구문 만들기
		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " in " + wordListThree[rand3];
		
		//구문 출력
		System.out.println("I live in a " + phrase + ".");
	}

}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 프로그램을 실행, 바이트코드가 만들어진 다음 바이트코드가 실행되기 전까지 외부의 접근을 확인하는 작업 수행.
 
 * 컴파일러: 자바 언어를 해석, 동적 바인딩 지원, 실행 시 오류 막아줌, 클래스 및 메소드의 보안 담당. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

//A.
public class Exercise1b {
	public static void main(String[] args) {
		
                int x = 1;
		while(x<10){ 
			x = x+1; //출력값이 나오도록 조건을 추가
			if(x>3){
				System.out.println("big x");
			}
		}
	}

}

//B.
public class Exercise1b { //클래스가 없으므로 추가
	public static void main(String[] args) {
		
                int x = 5;
		while(x>1){ 
			x = x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}

}

//C.
public class Exercise1b { 
	public static void main(String[] args) { //메인 메소드가 없으므로 추가
		
                int x = 5;
		while(x>1){ 
			x = x-1;
			if(x<3){
				System.out.println("small x");
			}
		}
	}

}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체에서 대해 아는 것(객체의 데이터 혹은 상태)
 
 * 메소드: 객체에서 할 수 있는 일

 * 클래스: 가상머신에 그 유형의 객체를 만드는 방법을 알려주는 역할

 * 테스트용 클래스: 새로운 클래스 유형의 객체에 들어이쓴 메소드와 변수를 테스트하는 역할, main() 메소드를 포함하며 그 main() 메소드에서 테스트할 클래스 유형의 객체를 만들어서 접근
 

*68p Television* _채워넣기_

 * 인스턴스 변수: volume, channel

 * 메소드: volumeUp(), volumeDown(), channelUp(), channerDown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

package GuessGame;

public class GuessGame {
	
        Player p1;
	Player p2;
	Player p3;
	Player p4;
	
	public void startGame(){
		p1 = new Player();
		p2 = new Player();
		p3 = new Player();
		p4 = new Player();
		
		int guessp1 = 0;
		int guessp2 = 0;
		int guessp3 = 0;
		int guessp4 = 0;
		
		boolean p1isRight = false;
		boolean p2isRight = false;
		boolean p3isRight = false;
		boolean p4isRight = false;
		
		int targetNumber = (int) (Math.random()*10);
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");
		
		while(true){
			System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");
			
			p1.guess();
			p2.guess();
			p3.guess();
			p4.guess();
			
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: " + guessp1);
			
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: " + guessp2);
			
			guessp1 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: " + guessp3);
			
			guessp1 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: " + guessp4);
			
			if(guessp1 == targetNumber){
				p1isRight = true;
			}
			
			if(guessp2 == targetNumber){
				p2isRight = true;
			}
			
			if(guessp3 == targetNumber){
				p3isRight = true;
			}
			
			if(guessp4 == targetNumber){
				p4isRight = true;
			}
			
			if(p1isRight || p2isRight || p3isRight || p4isRight){
				
				System.out.println("맞춘 선수가 있습니다.");
				System.out.println("1번 선수: " + p1isRight);
				System.out.println("2번 선수: " + p2isRight);
				System.out.println("3번 선수: " + p3isRight);
				System.out.println("4번 선수: " + p4isRight);
				System.out.println("게임 끝.");
				break;
			
			}else{
				System.out.println("다시 시도해야 합니다.");
			}
			
		}
		
	}
}

public class Player {
	
        int number = 0;
	
	public void guess(){
		number = (int) (Math.random()*10);
		System.out.println("찍은 숫자: " + number);
	}

}

public class GameLauncher {
	public static void main(String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}

}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

//A.
public class TapeDeck{
	
        boolean canRecord = false;
	
	void playTape(){
		System.out.println("tape playing");
	}
	
	void recordTape(){
		System.out.println("tape recording");
	}
}

public class TapeDeckTestDrive {
	public static void main(String[] args) {
		TapeDeck t = new TapeDeck(); // 새로운 객체를 지정해줘야 함
		
		t.canRecord = true;
		t.playTape();
		
		if (t.canRecord == true){
			t.recordTape();
		}
	}

}


//B.
public class DVDPlayer {
	
	boolean canRecord = false;
	
	void recordDVD(){
		System.out.println("DVD recording");
	}
	
	void playDVD(){
		System.out.println("DVD playing");
	} // playDVD에 대한 메소드 삽입

}

public class DVDPlayerTestDrive {
        public static void main(String[] args) {
		
		DVDPlayer d = new DVDPlayer();
		d.canRecord = true;
		d.playDVD();
		
		if(d.canRecord == true){
			d.recordDVD();
		}
	}

}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:

원시변수: 정수, 부울. 부동소수점 수와 같은 기초적인 값이 들어감

레퍼런스변수: 객체에 대한 레퍼런스, 특정 객체에 접근하는 방법을 나타내는 비트가 변수 값

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

public class Dog {
	String name;
	public static void main(String[] args) { 
		
                // Dog 객체를 만들고 접근
		Dog dog1 = new Dog();
		dog1.bark();
		dog1.name = "Bart";
		
		// Dog 배열 만들기
		Dog[] myDogs = new Dog[5];
		
		// 개 5마리 집어넣기
		myDogs[0] = new Dog();
		myDogs[1] = new Dog();
		myDogs[2] = new Dog();
		myDogs[3] = dog1;
		myDogs[4] = new Dog();

		// 배열 레퍼런스를 써서 Dog객체에 접근
		myDogs[0].name = "Fred";
		myDogs[1].name = "Merge";
		myDogs[2].name = "Burkey";
		myDogs[4].name = "Poli";
		
		// 네번째 개 이름?
		System.out.print("네 번째 개의 이름: ");
		System.out.println(myDogs[3].name);
		
		// 순환문을 써서 배열에 들어있는 모든 개가 짖도록
		int x = 0;
		while(x < myDogs.length){
			myDogs[x].bark();
			x = x+1;
		}
	}
	
	public void bark(){
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	
	public void eat(){
	}
	
	public void chaseCat(){
	}

}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

//A.

package Books;

public class Books {
	String title;
	String author;
}

public class BooksTestDrive {
	public static void main(String[] args) {
		
		Books[] myBooks = new Books[3];
		
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); // 새로운 세 개의 객체 만들어야 함
		
		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
		
		while(x<3){
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x+1;
		}

	}

}


//B.
public class Hobbits {
	
        String name;
	public static void main(String[] args) {
		
		Hobbits[] h = new Hobbits[3];
		int z = -1; // 배열은 0부터 시작하므로
		
		while(z<2){
			z = z+1; // z값 0으로 설정
		
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			
			if(z==1){
				h[z].name = "frodo";
			}
			
			if(z==2){
				h[z].name = "sam";
			}
				
			System.out.print(h[z].name + " is a ");
			System.out.println("good Hobbit name");
		}

	}

}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 방식으로 메소드를 만들면 10개의 객체가 아닌 마지막으로 만든 객체 하나만 사용 가능

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 인스턴스 변수를 부적절한 값으로 설정하지 못하게 막기 위해 인스턴스 변수를 private로 지정하고 접근 제어를 위해 게터와 세터를 public으로 지정
 
 * 게터와 세터: 인스턴스 변수의 값에 대해 가져오기로 되어있는 값을 리턴값 형태로 받아오는 것을 게터, 설정한 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도로 쓰이는 것이 세터라 함

 * 인스턴스 변수 vs 지역 변수: 인스턴스 변수는 클래스 내에서 선언되고, 지역 변수는 메소드 내에서 선언됨(지역 변수는 항상 초기화 필요)
 
*107p Dog* _실행_

{{{

package Dog;

public class Dog {
	
	int size;
	String name;
	
	void bark(){
		if(size>60){
			System.out.println("Wooof! Wooof");
		}else if(size>14){
			System.out.println("Ruff! Ruff!");
		}else{
			System.out.println("Yip! Yip!");
		}
	}

}

public class DogTestDrive {
	
	public static void main(String[] args) {
		
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
		
		one.bark();
		two.bark();
		three.bark();

	}

}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

//A.
public class XCopy {

	public static void main(String[] args) {
		
		int orig = 42;
		XCopy x = new XCopy();
		int y = x.go(orig);
		System.out.println(orig + " " + y); // orig 값은  변하지 않고 y는 인자값의 두배로 리턴됨
		
	}

	int go(int arg){
		
		arg = arg*2;
		return arg;
		
	}
}
// 결과 : 42 84


//B.
package Clock;

public class Clock {
	
	String time;
	
	void setTime(String t){
		time = t;
	}
	
	String getTime(){ // 게터는 반드시 리턴 유형이 있어야 함
		return time;
	}

}

public class ClockTestDrive {

	public static void main(String[] args) {
		
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time: " + tod);
		
	}

}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}