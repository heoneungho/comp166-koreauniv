#summary 이지현의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public class BeerSong {

     public static void main (String[] args) {
          int beerNum = 99;
          String word = "bottles";

     while (beerNum > 0) {

     if (beerNum == 1) {
          word = "bottle";
     }

     System.out.println(beerNum + " " + word + " of beer on the wall");
     System.out.println(beerNum + " " + word + " of beer.");
     System.out.println("Pass it around");
     beerNum = beerNum -1;

     if (beerNum > 0) {
          if(beerNum ==1) {
               word = "bottle";//this is edited part.
          }
          System.out.println(beerNum + " " + word + " of beer on the wall");
          }else {
          System.out.println("No more bottles of beer on the wall");
               }
          }
     }
}



}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
	public static void main (String[] args) {

	String[] Animalword = {"Dog", "Cat", "Tiger", "Monkey", "Lion", "Shark", "Whale", "Bird"};

	String[] Stationeryword = {"Pencil", "Pen", "Eraser", "Pencilcase", "Notebook", "Highlightpen", "book"};

	String[] Feelingword = {"Happy", "Sad", "Angry", "Interesting", "jealous", "impressed", "Nice", "Tired", "zealous", "excited", "Bad"};

	int AnimalLength = Animalword.length;
	int StationeryLength = Stationeryword.length;
	int FeelingLength = Feelingword.length;

	int rand1 = (int) (Math.random() * AnimalLength);
	int rand2 = (int) (Math.random() * StationeryLength);
	int rand3 = (int) (Math.random() * FeelingLength);

	String phrase = Animalword[rand1] + " " + Stationeryword[rand2] + " " + Feelingword[rand3];

	System.out.println("What we need is a " + phrase);
	}
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 1. 프로그램을 실행하게 한다. 2. 바이트 코드가 만들어진 다음 바이트코드가 실행되기 전까지 다른 누군가가 그걸 건드리지 않았는지 확인하는 작업을 한다.

 * 컴파일러: 1. 자바 언어를 해석한다. 2. 동적 바인딩을 지원한다. 3. 실행 시 오류를 막아준다. 4. 클래스 및 메소드의 보안을 담당한다. 

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

<A>

class Exercise1b {
     public static void main (String [] args) {
     
     int x = 1;

     while (x < 10) {
          if (x > 3) {
               System.out.println("big x");
               }
          }
     }
}

<B>

class Exercise1b {
public static void main(String [] args) {

	int x = 5;

	while (x > 1) {
		x = x - 1;
	if (x <3) {
		System.out.println("small x");
		}
	}
}
}

<C>

class Exercise1b {
	public static void main(String [] args) {
	
	int x = 5;

	while (x > 1) {
	
	x = x -1;

	if (x <3) {
		System.out.println("small x");
		}
	}
}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수: 객체의 상태(데이터)를 나타내며 그 유형에 속하는 각 객체마다 값이 다름
 * 메소드: 객체에서 할 수 있는 일
 * 클래스: 객체를 만들기 위한 청사진(blueprint)
 * 테스트용 클래스: 새로운 클래스를 테스트하기 위한 클래스
 

*68p Television* _채워넣기_

 * 인스턴스 변수: title, cast
 * 메소드: setTitle(), setCast(); TurnOn(), TurnOff() 

*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{

public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
	  p1 = new Player();
	  p2 = new Player();
	  p3 = new Player();
	  p4 = new Player();

	  int guessp1 = 0;
	  int guessp2 = 0;
	  int guessp3 = 0;
	  int guessp4 = 0;

	  boolean p1isRight = false;
	  boolean p2isRight = false;
	  boolean p3isRight = false;
	  boolean p4isRight = false;

	  int targetNumber = (int) (Math.random()*10);
	  System.out.println("Guess the number from 0 to 9");

	while(true) {
	  System.out.println("The number you should guess is" + targetNumber);

	  p1.guess();
	  p2.guess();
	  p3.guess();
	  p4.guess();

	  guessp1 = p1.number;
	  System.out.println("Player 1 pick the number:" + guessp1);

	  guessp2 = p2.number;
	  System.out.println("Player 2 pick the number:" + guessp2);

	  guessp3 = p3.number;
	  System.out.println("Player 3 pick the number:" + guessp3);

	  guessp4 = p4.number;
	  System.out.println("Player 4 pick the number:" + guessp4);

	if (guessp1 == targetNumber) {
	  p1isRight = true;
	}

	if (guessp2 == targetNumber) {
	  p2isRight = true;
	}

	if (guessp3 == targetNumber) {
	  p3isRight = true;
	}

	if (guessp4 == targetNumber) {
	  p4isRight = true;
	}

	if (p1isRight || p2isRight || p3isRight ||p4isRight) {

		System.out.println("There are some players who pick the right number.");
		System.out.println("Player1 :" + p1isRight);
		System.out.println("Player2 :" + p2isRight);
		System.out.println("Player3 :" + p3isRight);
		System.out.println("Player4 :" + p4isRight);
		System.out.println("Game over.");
		break;
	} else {
		System.out.println("Try again");
	}
	}
	}
}

public class Player {
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random()*10);
		System.out.println("The number you pick up" +number);
		}
	}

public class GameLauncher {
	public static void main (String[] args) {
		GuessGame game = new GuessGame();
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

<A>

class TapeDeck {

	boolean canRecord = false;
	
	void playTape() {
	  System.out.println("tape playing");
	}

	void recordTape() {
	  System.out.println("tape recording");
	}
  }

class TapeDeckTestDrive {
	public static void main(String [] args) {

	TapeDeck t = new TapeDeck();
	t.canRecord = true;
	t.playTape();

	if (t.canRecord == true) {
	  t.recordTape();
	  }
	}
}

}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 원시변수에는 넝수, 부울, 부동소수점 수와 같은 기초적인 값(단순한 비트값으로 나타낼 수 있는 값)이 들어감. 객체 레퍼런스에는 객체에 대한 레퍼런스가 들어감. 
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog {
	String name;
	public static void main (String[] args) {

	Dog dog1 = new Dog();
	dog1.bark();
	dog1.name = "Bart";

	Dog[] myDogs = new Dog[3];
	
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;

	
}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
< A >

class Books {
	String title;
	String author;
	}

class BooksTestDrive {
		public static void main(String [] args) {

		Books [] myBooks = new Books[3];
		int x = 0;
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books();
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";

		while (x < 3) {
		
		System.out.print(myBooks[x].title);
		System.out.print("by");
		System.out.println(myBooks[x].author);
		x = x + 1;
		}
	}
}

< B >

class Hobbits {

	String name;

	public static void main(String [] args) {

	  Hobbits [] h = new Hobbits[3];
	  int z = -1;

	  while (z < 2) {
		z = z + 1;
		h[z] = new Hobbits();
		h[z].name = "bilbo";
		if (z==1) {
		  h[z].name = "frodo";
		}
		if (z==2) {
		  h[z].name = "sam";
		}
		System.out.print(h[z].name + " is a ");
		System.out.println("good Hobbit name");
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?: 밥
 * 문제가 된 부분은 어딘가요?: 켄트의 메소드는 contact 객체 중 마지막 객체에만 접근 가능하여 아무 쓸모가 없다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화: 클래스의 인스턴트 변수와 메소드에 제한을 걸어 외부에서 직접 인스턴트 변수와 메소드에 접근할 수 없게 함.
 * 게터와 세터: 게터-인스턴트 변수의 값을 알아내기 위한 메소드, 세터-인스턴트 변수의 값을 설정하기 위한 메소드
 * 인스턴스 변수 vs 지역 변수: 인스턴트 변수-클래스 안, 메소드 밖에서 설정한 변수. 지역 변수-메소드 안에서 설정한 변수 
 
*107p Dog* _실행_

{{{
class Dog {
	int size;
	String name;

	void bark() {
	  if (size > 60) {
		System.out.println("Wooof! Wooof!");
	  } else if (size >14) {
		System.out.println("Ruff! Ruff!");
	  } else {
		System.out.println("Yip! Yip!");
	  }
	}
}

------------------------------------------------------

class DogTestDrive {

	public static void main (String[] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;

		one.bark();
		two.bark();
		three.bark();
	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
< A >
class XCopy {

	public static void main(String [] args) {
		
		int orig = 42;
		XCopy x = new XCopy();
		int y = x.go(orig);
		System.out.println(orig + " " + y);
	}

		int go(int arg) {

			arg = arg*2;
			return arg;
		}
}

< B >

class Clock {

	String time;

	void setTime(String t) {
	  time = t;
	}

	String getTime() {
	  return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {

	Clock c = new Clock();

	c.setTime("1245");
	String tod = c.getTime();
	System.out.println("time: " + tod);
	}
}

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란? 최근의 소프트웨어 개발 방법론 분야에 새로 등장하였다. 
XP의 가장 큰 장점은 막판에 스펙이 변경되는 일이 있어도 고객이 원하는 것을 고객이 원하는 기한에 맞춰서 제공할 수 있다는 점이다. XP는 서로 조화롭게 쓸 수 있도록 계획된 일련의 규칙이 있다. 
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{
public class SimpleDotCom {

	int[] locationCells;
	int numOfHits = 0;
	
	public void setLocationCells(int[] locs) {
			locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i = 0; i < locationCells.length; i++) {
			if(guess == locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}//순환문 끝
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
	}//메소드 끝
}// 클래스 끝

public class SimpleDotComGame {
	public static void main(String[] args) {

		int numOfGuesses = 0;
		GameHelper helper = new GameHelper();
		
		SimpleDotCom theDotCom = new SimpleDotCom();
		int randomNum = (int) (Math.random()*5);
		
		int[] locations = {randomNum, randomNum+1, randomNum+2};
		theDotCom.setLocationCells(locations);
		boolean isAlive = true;
		
		while(isAlive == true) {
			
			String guess = helper.getUserInput("enter a number");
			String result = theDotCom.checkYourself(guess);
			numOfGuesses++;
			
			if(result.equals("kill")) {
				isAlive = false;
				
				System.out.println(numOfGuesses + "guesses");
				
			}//if문 끝
		}//while문 끝
	}
}//main문 끝

import java.io.*;
public class GameHelper {
	public String getUserInput(String prompt) {
		String InputLine = null;
		System.out.print(prompt + " ");
		try {
			BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
			InputLine = is.readLine();
			if (InputLine.length() == 0) return null;
		} catch(IOException e) {
			System.out.println("IOException: "+ e);
		}
		return InputLine;
	}

}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{
import java.util.ArrayList;

public class DotCom {
     
     private ArrayList<String> locationCells;

     public void setLocationCells(ArrayList<String> loc) {
          locationCells = loc;
     }//배열 대신 string이 들어가는 ArrayList를 사용

     public String checkYourself(String userInput) {

          String result = "miss";
          
               int index = locationCells.indexOf(userInput);

               if (index >= 0 ) {

                    locationCells.remove(index);

                    if (locationCells.isEmpty()) {
                         result = "kill";
                    } else {
                          result = "hit";
                    }//if 문 끝
               }//바깥쪽 if문 끝
                    return result;
          }//메소드 끝
}//클래스 끝


            

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속: 
 * 다형성:

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
public class MonsterTestDrive {
	public static void main(String [] args) {
	  Monster [] ma = new Monster[3];
	  ma[0] = new Vampire();
	  ma[1] = new Dragon();
	  ma[2] = new Monster();
	  for(int x = 0; x <3; x++) {
		ma[x].frighten(x);
	  }
	}
}

class Monster {
	boolean frighten(int d) {
	  System.out.println("arrrgh");
	  return true;
	}
}

class Vampire extends Monster {
	boolean frighten(int x) {
	  System.out.println("a bite?");
	  return false;
	}
}

class Dragon extends Monster {
	boolean frighten(int degree) {
	  System.out.println("breath fire");
	  return true;
	}
}


}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속:

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}