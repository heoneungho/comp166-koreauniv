#summary 신아영의 실습 페이지입니다.

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{

public class beer {
        public static void main (String[] args) {
                int beerNum=99;
                String word="bottles"; //복수형

        while (beerNum>0) {

        if(beerNum==1) {
                word="bottle"; //단수형(한 병인 경우)
                        

        System.out.println(beerNum + " " + word + " of beer on the wall");
        System.out.println(beerNum + " " + word + " of beer.");
        System.out.println("Take one down.");
        System.out.println("Pass it around.");
        beerNum = beerNum - 1;

        if (beerNum<=0) {
                System.out.println("No more bottles of beer on the wall");
        } //else문 끝
        } //while순환문 끝
} //main클래스 끝
} //클래스 끝


}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{

public class PhraseOMatic {
	public static void main (String[] args) {

		String[] wordListOne = {"nice", "awesome", "good", "cool", "gorgeous"};

		String[] wordListTwo = {"Korean", "American", "Chinese", "Spanish", "Japanese", "Taiwan"};
		String[] wordListThree = {"food", "clothes", "culture", "drink"};

		int oneLength = wordListOne.length;
		int twoLength = wordListTwo.length;
		int threeLength = wordListThree.length;

		int rand1 = (int) (Math.random() * oneLength);
		int rand2 = (int) (Math.random() * twoLength);
		int rand3 = (int) (Math.random() * threeLength);

		String phrase = wordListOne[rand1] + " " + wordListTwo[rand2] + " " + wordListThree[rand3];

		System.out.println("I like " + phrase);
	}
}

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신:
 * 컴파일러:

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A
class Exercise1b {
	public static void main(String [] args) {
		int x = 1;
		while(x < 10) {
			if(x > 3){
				System.out.println("big x");
			}
		x = x+1; 
		}
	}
}

B
class Exercise1b {
	public static void main(String [] args) {
		int x = 5;
		while(x > 1) {
			x = x-1;
			if(x < 3) {
				System.out.println("small x");
			}
		}
	}
}

C
class Exercise1b {
	public static void main(String [] args) {
		int x = 5;
		while(x > 1) {
			x = x-1;
			if(x < 3) {
				System.out.println("small x");
			}
		}
	}
}

}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수:
 * 메소드:
 * 클래스:
 * 테스트용 클래스:
 

*68p Television* _채워넣기_

 * 인스턴스 변수:
 * 메소드:


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
1. GuessGame.java
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4;

	public void startGame() {
	p1 = new Player();
	p2 = new Player();
	p3 = new Player();
	p4 = new Player();

	int guessp1 = 0;
	int guessp2 = 0;
	int guessp3 = 0;
	int guessp4 = 0;

	boolean p1isRight = false;
	boolean p2isRight = false;
	boolean p3isRight = false;
	boolean p4isRight = false;

	int targetNumber = (int) (Math.random() * 10);
	System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

	while(true) {
	System.out.println("맞춰야 할 숫자는 " + targetNumber + "입니다.");

	p1.guess();
	p2.guess();
	p3.guess();
	p4.guess();

	guessp1 = p1.number;
	System.out.println("1번 선수가 찍은 숫자: " + guessp1);

	guessp2 = p2.number;
	System.out.println("2번 선수가 찍은 숫자: " + guessp1);

	guessp1 = p3.number;
	System.out.println("3번 선수가 찍은 숫자: " + guessp1);

	guessp1 = p4.number;
	System.out.println("4번 선수가 찍은 숫자: " + guessp1);

	if (guessp1 == targetNumber) {
	p1isRight = true;
	}

	if (guessp2 == targetNumber) {
	p2isRight = true;
	}

	if (guessp3 == targetNumber) {
	p3isRight = true;
	}

	if (guessp4 == targetNumber) {
	p4isRight = true;
	}

	if (p1isRight || p2isRight || p3isRight || p4isRight) {

	System.out.println("맞춘 선수가 있습니다.");
	System.out.println("1번 선수: " +p1isRight);
	System.out.println("2번 선수: " +p2isRight);
	System.out.println("3번 선수: " +p3isRight);
	System.out.println("4번 선수: " +p4isRight);
	System.out.println("게임 끝.");
	break; // 게임이 끝났으므로 break문으로 순환문을 빠져나갑니다.

	} else {
	//아직 아무도 못 맞췄기 때문에 계속 해야 합니다.
	System.out.println("다시 시도해야 합니다.");
	} // if/else 부분 끝
	}//순환문 끝
	}//메소드 끝
}//클래스 끝





2. Player.java
public class Player {
	int number = 0; //찍은 숫자를 저장할 변수

public void guess() {
	number = (int) (Math.random() * 10);
	System.out.println("찍은 숫자: " + number);
	}
}





3. GameLauncher.java
public class GameLauncher {
	public static void main (String[] args) {
	GuessGame game = new GuessGame();
	game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A-1 TapeDeck
class TapeDeck {
	boolean canRecord = false;

	void playTape() {
	System.out.println("tape playing");
	}

	void recordTape() {
	System.out.println("tape recording");
	}
}


A-2 TapeDeckTestDrive
class TapeDeckTestDrive {
	public static void main(String [] args) {

	t.canRecord = true;
	t.playTape();

	if(t.canRecord== true) {
	t.recordTape();
	}
	}
}


B-1 DVDPlayer
class DVDPlayer {

	boolean canRecord = false;

	void recordDVD() {
	System.out.println("DVD recording");
	}
}


B-2 DVDPlayerTestDrive
class DVDPlayerTestDrive {
	public static void main(String [] args) {

	DVDPlayer d = new DVDPlayer();
	d.canRecord = true;
	d.playDVD();

	if (d.canRecord == true) {
	d.recordDVD();
	}
	}
}


}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수:
 
*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog {
	String name;
	public static void main (String[] args) {
	Dog dog1 = new Dog();
	dog1.bark;
	dog1.name = "Bart";

	Dog[] myDogs = new Dog[3];
	myDogs[0] = new Dog();
	myDogs[1] = new Dog();
	myDogs[2] = dog1;

	myDogs[0].name = "Fred";
	myDogs[1].name = "Marge";

	System.out.print("Last dog' name: ");
	System.out.println(myDogs[2].name);

	int x = 0;
	while(x < myDogs.length) {
	myDogs[x].bark();
	x = x + 1;
	}
}

	public void bark() {
	System.out.println(name + "barks Wal!");
	}
	public void eat() { }
	public void chaseCat() { }
}


}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A
class Books {
        String title;
        String author;
}

class BooksTestDrive {
        public static void main(String [] args) {

        Books [] myBooks = new Books[3];

        // Book을 집어 넣어야합니다.
        myBooks[0] = new Books();
        myBooks[1] = new Books();
        myBooks[2] = new Books();

        myBooks[0].title = "The Grapes of Java";
        myBooks[1].title = "The Java Gatsby";
        myBooks[2].title = "The Java Cookbook";
        myBooks[0].author = "bob";
        myBooks[1].author = "sue";
        myBooks[2].author = "ian";

        int x = 0;
        while(x<3) {
                System.out.print(myBooks[x].title);
                System.out.print(" by ");
                System.out.println(myBooks[x].author);
                x=x+1;
                }
        }
}


                 
B
class Hobbits {

        String name;

        public static void main(String [] args) {

                Hobbits [] h = new Hobbits[3];
                int z = 0;

                while (z < 3) { // z=3일 때 while문을 빠져나옵니다.

                h[z] = new Hobbits();
                h[z].name = "bilbo";
                if (z == 1) {
                  h[z].name = "frodo";
                }
                if (z == 2) {
                  h[z].name = "sam";
                }
                System.out.print(h[z].name + " is a ");
                System.out.println("good Hobbit name");

                z = z+1; // while문 끝에서 z의 값이 1씩 증가해야합니다.
                }
        }
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:
 * 문제가 된 부분은 어딘가요?:

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:
 * 게터와 세터:
 * 인스턴스 변수 vs 지역 변수:
 
*107p Dog* _실행_

{{{

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?
Before starting method code, make assistance code to test method. Making a test code is one of a ground rule as making the code easier. The pros of this XP is that you can easily change the spec if the client wants to change the code. 
 
*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

public class SimpleDotCom {

        int[] locationCells;
        int numOfHits = 0 ;
        
        public void setLocationCells (int[] locs){
                locationCells = locs;
        }
        
        public String checkYourself(String stringGuess){
                int guess = Integer.parseInt(stringGuess);
                String result = "miss";
                for(int i = 0 ; i < locationCells.length; i++){
                        if (guess == locationCells[i]) {
                                result = "hit";
                                numOfHits++;
                                break;
                        }
                }
                
                if (numOfHits == locationCells.length){
                        result = "kill";
                }
                System.out.println(result) ;
                        return result ;
        }
}


public class SimpleDotComGame {

        public static void main(String[] args) {
                int numOfGuesses = 0 ; //
                GameHelper helper = new GameHelper(); 
                
                SimpleDotCom theDotCom = new SimpleDotCom(); 
                
                int randomNum = (int)(Math.random()*5);
                
                int[] locations = {randomNum, randomNum+1, randomNum+2};

                theDotCom.setLocationCells(locations);//using array
                boolean isAlive = true ;
                
                while (isAlive == true){//if it is live, start repetition
                        String guess = helper.getUserInput("enter a number");
                        
                        String result = theDotCom.checkYourself(guess);
                        
                        numOfGuesses++;
                        //guess number increase
                        if (result.equals("kill")){
                                isAlive = false ;
                                
                                System.out.println(numOfGuesses + "guesses");
                        }
                }
        }/
}



import java.io.*;
public class GameHelper {
        public String getUserInput(String prompt){
                String inputLine = null ;
                System.out.print(prompt + " ") ;
                try {
                        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
                        inputLine = is.readLine();
                        if (inputLine.length()== 0) return null;
                } catch(IOException e){
                        System.out.println("IOException: " + e);
                }
                return inputLine;
        }
}


}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{



}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:부모 클래스가 자식 클래스에게 멤버필드와 메소드를 물려줌
 * 미다형성:하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것 즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것을 의미

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:부모 클래스와 자식 클래스가 상속관계에 있을 경우 부모로부터 물려받은 메소드를 자식 클래스에 맞게 재정의하여 사용하는 것
 * 오버로딩:하나의 클래스 안에서 식별자가 같은 메소드를 만들 수 있는 규칙

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

public class MonsterTestDrive {
        public static void main(String [] args) {
                Monster [] ma = new Monster[3];
                ma[0]= new Vampire();
                ma[1]= new Dragon();
                ma[2]= new Monster();
                
                for(int x=0; x<3; x++) {
                        ma[x].frighten(x);
                }
        }
}

class Monster {
        boolean frighten(int d) {
                System.out.println("arrrgh");
                return true;
        }
}

class Vampire extends Monster {
        boolean frighten(int x) {
                System.out.println("a bite?");
                return false;
        }
}

class Dragon extends Monster {
        boolean frighten(int degree) {
                System.out.println("breath fire");
                return true;
        }
}

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:상속 관계에 있는 클래스 중에서 상위 클래스에서는 특별한 구현 없이 사용하고자 하는 메소드만 기술하고 구체적인 구현은 하위 클래스에서 하도록 할 수 있습니다.
 * 추상 메소드:부모클래스에서 메소드명 앞에 abstract(추상)이라고 붙이기만 하고 실제로 메소드 내의 선언문(statement)내용이 없는 것을 추상메소드라고 합니다. 부모클래스(parentclass)를 상속 받은 자식클래스(subclass)에서는 반드시 이 추상메소드에 대해서 메소드를 정의해야 합니다.
 * 다중 상속:두개 이상의 부모클래스에서 상속 받는 것
= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:힙은 모든 객체가 사는 곳으로, 인스턴스 변수는 객체 안에 들어있습니다.
 * 스택에서의 변수:객체 레퍼런스 변수도 지역 변수라면 스택에 저장됩니다. 모든 지역 변수는 스택에 들어있으며 그 변수를 선언한 메소드에 해당하는 프레임 안에 들어있습니다. 
 * 생성자:객체 지향 프로그래밍(OOP:objective-oriented programming)에서 쓰이는 객체 초기화 함수. 객체의 생성 시에만 호출되어 메모리 생성과 동시에 객체의 데이터를 초기화하는 역할을 한다. 
 * 널 레퍼런스:'아무것도 가리키지 않는다 - 주소값이 없다'는 뜻입니다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수:객체 지향 프로그래밍(OOP)에서, 어떤 등급의 하나의 인스턴스인 객체에 관련(결합)된 변수. 등급이 어느 변수를 정의하면 그 등급에 속하는 각 인스턴스는 그 변수 자신의 카피를 갖는 것이 된다.
 * 지역 변수: 프로그램 언어에 있어서 변수가 어떤 블록(block) 내에서만 선언되지 않을 때에는 다른 블록에 그것을 사용하는 것은 불가능하며, 프로그램 내 전체에 걸쳐 사용할 수 없다. 이것은 그 변수가 지역적인 것이며, 프로그램 전체에 대하여 정의되어 있지 않기 때문이다. 이러한 변수를 지역 변수라 한다.

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:정적 메소드는 클래스 종속적인 메소드를 말합니다. 클래스에 선언되어 있지만 인스턴스를 만들때 포함되지 않습니다. 또한 메모리에 로드되는 시점도 비정적 메소드와 달리 프로그램이 실행되어 시작되기 바로전에 모두 메모리에 로드됩니다. 어떤 메소드가 실행이 되려면 메모리에 우선 로드되어야 하는데 위에서 설명한 차이로 인해 정적메소드는 인스턴스 생성을 하지 않고도 클래스명을 사용하여 바로 실행이 가능합니다.
 * 정적 메소드를 선언하는 방법:
 * static final:static-객체 생성을 안하고 사용 가능하다./final-오버라이딩이 되지 않으므로 내용을 바꾸지 못하도록 하는 기능이 있다.
 * 널 레퍼런스:'아무것도 가리키지 않는다-주소값이 없다'는 뜻입니다.
 * 오토 박싱:'기본자료형 -> 래퍼클래스' or '래퍼클래스 -> 기본자료형'
 * 정적 임포트:static import를 사용하면 다른 클래스의 static멤버를 클래스 이름없이 사용할 수 있다.

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}