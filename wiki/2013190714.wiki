#summary 김명준의 실습 페이지입니다.짱짱

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong { //public의 BeerSong이라는 class선언
	public static void main (String[] args) { //main함수를 선언
		int beerNum = 99; //int형 beerNum을 선언하고 값을 99로 초기화
		String word = "bottles"; //String의 word를 선언하고 bottles로 초기화
		while(beerNum>0) { //beerNum이 0보다 클때동안
			if(beerNum==1) { //beernum이 1일때
			word = "bottle"; //word를 bottle로 초기화
				       }
		System.out.println(beerNum + " " + word + " of beer on the wall");//beerNum의값 word의 값 of beer on the wall을 출력하고 newline
		System.out.println(beerNum + " " + word + " of beer.");//beerNum의값 word의 값 of beer 출력하고 newline
		System.out.println("Take one down.");//Take one down을 출력하고 newline
		System.out.println("Pass it around.");//Pass it around를 출력하고 newline
		beerNum = beerNum - 1; //beerNum의 값을 -1
		if(beerNum>0) {
			//System.out.println(beerNum + " " +word + " of beer on the wall");
//while문에 있는 출력문과 같은내용이 중복된다.중복된 내용이 출력되므로 주석처리
			      } else {
			System.out.println("No more bottles of beer on the wall");//0보다 크지 않을경우 다음문장을 출력하고 newline
			      }//else문 끝
  			}//while 순환문 끝
 		}//main 클래스 끝
	}//클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String [] args) {
	//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
	String [] wordListOne = {"김명준은","임태완은","김석환은","박선우은","이영기는","이미현은","임태휘는","손낙원은","곽도윤은"};
	
	String [] wordListTwo = {"수업끝나고","오늘새벽에","곧","한시간후에"};
	
	String [] wordListThree = {"롤을합니다","공부를합니다","잠을잡니다","수업을듣습니다"};
	
	int oneLength = wordListOne.length;
	int twoLength = wordListTwo.length;
	int threeLength = wordListThree.length;
	
	int rand1 = (int) (Math.random() * oneLength);
	int rand2 = (int) (Math.random() * twoLength);
	int rand3 = (int) (Math.random() * threeLength);
	
	String phrase = wordListOne[rand1] + " " +
	wordListTwo[rand2] + " " + wordListThree[rand3];
	
        //구문을 출력합니다.
	System.out.println("지금 408에 있는" +phrase);
	}
} 
	

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 컴파일러가 잡아내지 못해 다른유형의 데이터가 들어갈때 오류를 잡아냄,자바를 구동시킴,보안을 담당
 * 컴파일러:자바를 구동시킬때 있어서는 안될 데이터 유형 위반등의 오류를 막아줌,접근해서는 안되는 메소드의 보안을 담당

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Exercise1b {
	public static void main(String[] args) {
		int x = 1;
			while(x<10) {
				if(x>3){
					System.out.println("big x");
				}
				x = x + 1;//x의 증가가 없으면 무한루프가 됨
			}
		}
	}
B
class exercise2b {// class 선언이 없어서 추가
	public static void main(String [] args) {
		int x = 5;
		while ( x > 1 ) {
		x=x-1;
		if ( x < 3 ) {
			System.out.println("small x");
			}
		}
	}
}// }를 하나 추가
C
class Exercise3b {
	public static void main(String [] args) {//main 메소드 추가
		int x = 5;
		while ( x > 1) {
			x=x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}//}하나 추가
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수:객체에서 자신에 대하여 아는것,객체의 상태(테이터)를 나타낸다.
 * 메소드:객체에서 할 수 있는 일
 * 클래스:객체를 만들기 위한 용도,청사진이다.
 * 테스트용 클래스:새로운 클래스를 테스트하기 위한 클래스,main메소드가 들어가며 테스트할 클래스 유형의 객체를 만들어 메소드와 변수를 테스트한다.<클래스명>TestDrive같은 이름이 붙는다
 

*68p Television* _채워넣기_

 * 인스턴스 변수:channel,volume,power
 * 메소드:poweron(),poweroff(),volumeup(),volumedown(),recording(),channelup(),channeldown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4; //플레이어4를 위한 인스턴스 변수 추가
	
	public void startGame () {
		p1 = new Player () ;
		p2 = new Player () ;
		p3 = new Player () ; 
		p4 = new Player () ; //플레이어 객체를 인스턴스 변수에 대입
	
		int guessp1 = 0 ;
		int guessp2 = 0 ;
		int guessp3 = 0 ; 
		int guessp4 = 0 ; //플레이어 4가 찍을 숫자를 저장
	
		boolean p1isRight = false ;
		boolean p2isRight = false ; 
		boolean p3isRight = false ;
		boolean p4isRight = false ; //각각 플레이어의 기본값을 실패로 선언
	
		int targetNumber = (int) (Math.random() * 10) ;
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

		while(true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + " 입니다.");
		
			p1.guess () ;
			p2.guess () ;
			p3.guess () ;
			p4.guess () ; //각각 선수별로 guess메소드 호출
	
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: "+ guessp1);
	
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: "+ guessp2);
	
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: "+ guessp3);

			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: "+ guessp4); //각각 객체의 인스턴스 변수를 접근하여 찍은 숫자를 알아냄
	
			if ( guessp1 == targetNumber ) {
				p1isRight = true ;
			}
		
			if ( guessp2 == targetNumber ) {
				p2isRight = true ;
			}
			
			if ( guessp3 == targetNumber ) {
				p3isRight = true ;
			}
			
			if ( guessp4 == targetNumber ) {
				p4isRight = true ;
			} //맞을경우 결과값을 참으로 변경
			
			if ( p1isRight || p2isRight || p3isRight || p4isRight) {
	
			System.out.println("맞춘 선수가 있습니다.") ;
			System.out.println("1번 선수: " + p1isRight) ;
			System.out.println("2번 선수: " + p2isRight) ;
			System.out.println("3번 선수: " + p3isRight) ;
			System.out.println("4번 선수: " + p4isRight) ;
			System.out.println("게임 끝.");
			break;//게임이 끝나서 반복문을 나감
			}//못맞췄기 때문에 다시 실행하라함	else {
			System.out.println("다시 시도해야 합니다.");//조건문 끝
			}// 순환문 끝
		}//메소드 끝
	}// 클래스 끝
}
public class Player { //플레이어 부분은 바뀔게 없음
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random() * 10 ) ;
		System.out.println("찍은 숫자: " + number) ;
	}
}
public class GameLauncher { //게임 런처 부분은 바뀔게 없음
	public static void main (String[] args) {
		GuessGame game = new GuessGame() ;
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A
class TapeDeck {
	
	boolean canRecord = false;
	
	void playTape() {//테이프플레이메소드
		System.out.println("tape playing");
	}
	
	void recordTape() {//리코드테이프메소드
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive {
	public static void main(String [] args) {
	
		TapeDeck t = new TapeDeck(); //t라는 TapeDeck 객체 선언

		t.canRecord = true;
		t.playTape();//플레이테이프메소트호출
		
		if(t.canRecord == true ) {
			t.recordTape();//리코드테이프메소드호출
			}
		}
	}

B
class DVDPlayer {
	
	boolean canRecord = false ;
	
	void recordDVD() {//리코드디브이디메소드
		System.out.println("DVD recording");
	}
	void playDVD() {
		System.out.println("DVD playing");//플레이디브이디 메소드를 추가

	}
}
class DVDPlayerTestDrive {
	public static void main(String [] args) {
	
	DVDPlayer d = new DVDPlayer ();//d라는 디브이디플레이어 객체 생성
	d.canRecord = true;
	d.playDVD ();//플레이디브이디 메소드 호출
	
	if(d.canRecord == true) {
		d.recordDVD();//리코드디브이디 메소드 호출
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 변수는 원시변수와 레퍼런스 변수로 나눌수 있다.
원시 변수에는 정수,부울,부동소수전 수와 같이 비트 패턴으로 나타낼 수 있는 기초적인 값이 들어간다.
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.
 

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog {
	String name;
	public static void main (String[] args) {
		//Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark() ;
		dog1.name = "나서스" ;
		
		//이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[8];
		//그리고 개 8 마리를 집어넣습니다.
		myDogs[0] = new Dog() ;
		myDogs[1] = new Dog() ;
		myDogs[2] = new Dog() ;
		myDogs[3] = new Dog() ;
		myDogs[4] = new Dog() ;
		myDogs[5] = new Dog() ;
		myDogs[6] = new Dog() ;
		myDogs[7] = dog1;
	

		//배열 레퍼런스를 써서 Dog 객체에
		//접근합니다.
		myDogs[0].name = "똥개";
		myDogs[1].name = "개석환";
		myDogs[2].name = "개태완";
		myDogs[3].name = "개선우";
		myDogs[4].name = "복날이";
		myDogs[5].name = "개새x" ;
		myDogs[6].name = "개노답";
		//마지막 개의 이름이 뭐였지?
		System.out.print("마지막 개의 이름: ");
		System.out.println(myDogs[7].name);
		
	
		//이제 순환문을 써서 배열에 들어있는
		//모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length) {
			myDogs[x].bark();
			x = x + 1;
		}
	}
	public void bark() {
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Books {
	String title ;
	String author ;
}

class BooksTestDrive {
	public static void main(String [] args) {
	
		Books [] myBooks = new Books[3] ;
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); //Books라는 객체를 생성
		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
	
		while(x<3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}

B
class Hobbits {
	
	String name ;
	
	public static void main(String [] args) {
	
		Hobbits [] h = new Hobbits[3];
		int z = 0 ;

		while(z<3) {//이름의 갯수는 3개이므로 3으로 조절
	
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if(z==1) {
				h[z].name = "frodo";
			}
			if(z==2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + " is a " );
			System.out.println("good Hobbit name");
			z=z+1;//맨앞에 있으면 0번째가 의미가 없으므로 맨 밑으로 내림
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 약간 절약할수는 있다. 하지만 켄트의 코드는 매번 순환문을 돌때마다 새로운 값으로 초기화 시키기 때문에 결국 밥의 코드보다 효용성이 없는 코드가 된다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:외부에 노출되어있는 변수를 보호하기 위하여 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다.
 * 게터와 세터: 어떤것을 가져오고 설정하는 역할
게터는 게터가 가져오기로 되어있는값을 리턴값 형태로 받아오기 위한 용도

세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도
 * 인스턴스 변수 vs 지역 변수:
인스턴스변수는 클래스 내에서 선언

지역변수는 메소드 내에서 선언, 사용전에 초기화를 해야됨

 
*107p Dog* _실행_

{{{
class Dog {
	int size ;
	String name;

	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {
	
	public static void main(String [] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
	
		one.bark();
		two.bark();
		three.bark();
	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class XCopy {
	
	public static void main(String []args) {
	
		int orig = 42;
	
		XCopy x = new XCopy(); // XCopy유형의 객체 x선언

		int y = x.go(orig);//객체x에서 go를 호출 이때 orig값을 보낸후 메소드를 실행해 y에 그값을 리턴
	
		System.out.println(orig + " " + y );
	}
	
	int go(int arg) { //함수를 int값으로 리턴을 받게됨
	
		arg=arg*2;
		
		return arg;//arg를 리턴
	}
} //결과는 42 84

B

class Clock {
	String time;
	
	void setTime(String t) {//String의 t를받아 이를 time으로 보내주는 세터
		time = t;
	}
	
	String getTime() { //time을 리턴받는 게터이고 받을 time은 String이므로 String으로 선언
		return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {
	
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time :  "  + tod);
	}
} // 출력값은 time : 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

90년대 말에 등장학 프로그래머들이 정말 원하는 방법으로 여러가지 규칙이 있다.

-테스트 코드를 먼저만든다.

-야근을 하지 않고 기회가 생기는 족족 코드를 개선

-테스트를 통과한 후에 발표를 한다

-스펙에 필요한 기능만 집어넣고 단순하게 처리한다

-두명씩 팀을 편성하고 코드를 모두 알 수 있도록 돌아가면서 진행
 

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

import java.io.*;
//뭔지는 모르겟지만 뭔가를 가져오는듯
public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}
//내용은 모르겟지만 책에서는 나중에 배우니 일단 쓰라고함

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0 ;
//초기 히트수를 0으로 초기화
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";//맞춤
		}
		System.out.println(result);
		return result;
	}
}

public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {//맞추면
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

import java.io.*;

public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}



public class SimpleDotCom {
	
	int[] locationCells;
	boolean[] hitCells = new boolean[3];//hitCells이라는 boolean형 배열을 생성
	int numOfHits = 0 ;

	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public void sethitCells(boolean[] hit) {//위의 setLocationCells처럼 sethitCells메소드를 추가
		hitCells = hit;
	}
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]&&hitCells[i]==false) {//이미 맞췃는지에대한 확인추가
				result = "hit";
				numOfHits++;
				hitCells[i]=true;//맞췃다는 표시를함
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
	}
}


public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
	
		boolean[] hitCells = new boolean[3];//첫번째 옵션에 필요한 boolean배열을 생성
	 	theDotCom.sethitCells(hitCells);//boolean배열을 닷컴클래스로 보내줌
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

import java.io.*;

public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0 ;

	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]&&locationCells[i]!=-1) {//-1이면 맞춘자리 이므로 이에대한 확인
				result = "hit";
				numOfHits++;
				locationCells[i]=-1;//맞췃다는 표시로 -1을 넣어줌
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
	}
}

public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

import java.util.ArrayList;

public class DotCom {

  private ArrayList<String> locationCells;
  //private int numOfHits;
  //(없어도 됩니다.)

  public void setLocationCells(ArrayList<String> loc) {
    locationCells = loc;
  }

  public String checkYourself(String userInput) {

    String result = "miss";

      int index = locationCells.indexOf(userInput);

       if(index>=0) {

          locationCells.remove(index);

          if(locationCells.isEmpty()){
            result = "kill";
          } else {
            result = "hit";
          }//if문 끝

         }//바깥쪽if문 끝

      return result;

   }//메소드 끝
 }//클래스끝


}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:공통적인 코드를 어떤 클래스에 넣은 다음,다른 더 구체적인 클래스에 공통적인(더 추상적인) 클래스가 상위클래스라는 것을 알려주면 됩니다. 한 클래스가 다른 클래스를 상속하는 것을 하위클래스가 상위클래스로부터 상속받는다고 말합니다.
 * 다형성: 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있습니다. 다형성은 하나의 변수와 메소드가 다양한 의미로 사용 가능하다는 것이고 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있습니다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드:
 * 오버로딩:

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:
 * 다형성:
 * 추상 클래스:
 * 추상 메소드:
 * 다중 상속: 여러 부모 객체에게 상속을 받는것 자바는 지원하지 않는다. 따라서 이를 하기 위해서는 인터페이스를 사용해야한다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수:
 * 스택에서의 변수:
 * 생성자:
 * 널 레퍼런스:
 
*298p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*302p 5분 미스터리* _구현후 주석달기_

{{{

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:
 * 정적 메소드를 선언하는 방법:
 * static final:
 * 널 레퍼런스:
 * 오토 박싱:
 * 정적 임포트:

*339p Calendar* _구현후 주석달기_

{{{

}}}

*342p 집중토론* _요약_

 * 인스턴스 변수:
 * 지역 변수: 

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{

}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}