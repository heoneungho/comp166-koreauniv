#summary 김명준의 실습 페이지입니다.짱짱

<wiki:toc max_depth="1" />

= 01. 껍질을 깨고:간단한 소개 =

*48p BeerSong* _문제해결하기, 주석달기_

{{{
public class BeerSong { //public의 BeerSong이라는 class선언
	public static void main (String[] args) { //main함수를 선언
		int beerNum = 99; //int형 beerNum을 선언하고 값을 99로 초기화
		String word = "bottles"; //String의 word를 선언하고 bottles로 초기화
		while(beerNum>0) { //beerNum이 0보다 클때동안
			if(beerNum==1) { //beernum이 1일때
			word = "bottle"; //word를 bottle로 초기화
				       }
		System.out.println(beerNum + " " + word + " of beer on the wall");//beerNum의값 word의 값 of beer on the wall을 출력하고 newline
		System.out.println(beerNum + " " + word + " of beer.");//beerNum의값 word의 값 of beer 출력하고 newline
		System.out.println("Take one down.");//Take one down을 출력하고 newline
		System.out.println("Pass it around.");//Pass it around를 출력하고 newline
		beerNum = beerNum - 1; //beerNum의 값을 -1
		if(beerNum>0) {
			//System.out.println(beerNum + " " +word + " of beer on the wall");
//while문에 있는 출력문과 같은내용이 중복된다.중복된 내용이 출력되므로 주석처리
			      } else {
			System.out.println("No more bottles of beer on the wall");//0보다 크지 않을경우 다음문장을 출력하고 newline
			      }//else문 끝
  			}//while 순환문 끝
 		}//main 클래스 끝
	}//클래스 끝

}}}

*50p PhraseOMatic* _wordListOne, wordListTwo, wordListThree를 변경_

{{{
public class PhraseOMatic {
	public static void main (String [] args) {
	//세 종류의 단어 목록을 만듭니다. 적당히 필요한 단어를 추가해도 됩니다.
	String [] wordListOne = {"김명준은","임태완은","김석환은","박선우은","이영기는","이미현은","임태휘는","손낙원은","곽도윤은"};
	
	String [] wordListTwo = {"수업끝나고","오늘새벽에","곧","한시간후에"};
	
	String [] wordListThree = {"롤을합니다","공부를합니다","잠을잡니다","수업을듣습니다"};
	
	int oneLength = wordListOne.length;
	int twoLength = wordListTwo.length;
	int threeLength = wordListThree.length;
	
	int rand1 = (int) (Math.random() * oneLength);
	int rand2 = (int) (Math.random() * twoLength);
	int rand3 = (int) (Math.random() * threeLength);
	
	String phrase = wordListOne[rand1] + " " +
	wordListTwo[rand2] + " " + wordListThree[rand3];
	
        //구문을 출력합니다.
	System.out.println("지금 408에 있는" +phrase);
	}
} 
	

}}}

*52p 집중토론* _요약_

 * 자바 가상 머신: 컴파일러가 잡아내지 못해 다른유형의 데이터가 들어갈때 오류를 잡아냄,자바를 구동시킴,보안을 담당
 * 컴파일러:자바를 구동시킬때 있어서는 안될 데이터 유형 위반등의 오류를 막아줌,접근해서는 안되는 메소드의 보안을 담당

*55p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Exercise1b {
	public static void main(String[] args) {
		int x = 1;
			while(x<10) {
				if(x>3){
					System.out.println("big x");
				}
				x = x + 1;//x의 증가가 없으면 무한루프가 됨
			}
		}
	}
B
class exercise2b {// class 선언이 없어서 추가
	public static void main(String [] args) {
		int x = 5;
		while ( x > 1 ) {
		x=x-1;
		if ( x < 3 ) {
			System.out.println("small x");
			}
		}
	}
}// }를 하나 추가
C
class Exercise3b {
	public static void main(String [] args) {//main 메소드 추가
		int x = 5;
		while ( x > 1) {
			x=x-1;
			if(x<3) {
				System.out.println("small x");
			}
		}
	}
}//}하나 추가
}}}


= 02. 객체마을로의 여행:객체에 대해 알아봅시다  =

*68p~ 클래스* _요약_

 * 인스턴스 변수:객체에서 자신에 대하여 아는것,객체의 상태(테이터)를 나타낸다.
 * 메소드:객체에서 할 수 있는 일
 * 클래스:객체를 만들기 위한 용도,청사진이다.
 * 테스트용 클래스:새로운 클래스를 테스트하기 위한 클래스,main메소드가 들어가며 테스트할 클래스 유형의 객체를 만들어 메소드와 변수를 테스트한다.<클래스명>TestDrive같은 이름이 붙는다
 

*68p Television* _채워넣기_

 * 인스턴스 변수:channel,volume,power
 * 메소드:poweron(),poweroff(),volumeup(),volumedown(),recording(),channelup(),channeldown()


*72p GuessGame* _게임에 참여하는 사람 수를 4명으로 변경_

{{{
public class GuessGame {
	Player p1;
	Player p2;
	Player p3;
	Player p4; //플레이어4를 위한 인스턴스 변수 추가
	
	public void startGame () {
		p1 = new Player () ;
		p2 = new Player () ;
		p3 = new Player () ; 
		p4 = new Player () ; //플레이어 객체를 인스턴스 변수에 대입
	
		int guessp1 = 0 ;
		int guessp2 = 0 ;
		int guessp3 = 0 ; 
		int guessp4 = 0 ; //플레이어 4가 찍을 숫자를 저장
	
		boolean p1isRight = false ;
		boolean p2isRight = false ; 
		boolean p3isRight = false ;
		boolean p4isRight = false ; //각각 플레이어의 기본값을 실패로 선언
	
		int targetNumber = (int) (Math.random() * 10) ;
		System.out.println("0 이상 9 이하의 숫자를 맞춰보세요.");

		while(true) {
			System.out.println("맞춰야 할 숫자는 " + targetNumber + " 입니다.");
		
			p1.guess () ;
			p2.guess () ;
			p3.guess () ;
			p4.guess () ; //각각 선수별로 guess메소드 호출
	
			guessp1 = p1.number;
			System.out.println("1번 선수가 찍은 숫자: "+ guessp1);
	
			guessp2 = p2.number;
			System.out.println("2번 선수가 찍은 숫자: "+ guessp2);
	
			guessp3 = p3.number;
			System.out.println("3번 선수가 찍은 숫자: "+ guessp3);

			guessp4 = p4.number;
			System.out.println("4번 선수가 찍은 숫자: "+ guessp4); //각각 객체의 인스턴스 변수를 접근하여 찍은 숫자를 알아냄
	
			if ( guessp1 == targetNumber ) {
				p1isRight = true ;
			}
		
			if ( guessp2 == targetNumber ) {
				p2isRight = true ;
			}
			
			if ( guessp3 == targetNumber ) {
				p3isRight = true ;
			}
			
			if ( guessp4 == targetNumber ) {
				p4isRight = true ;
			} //맞을경우 결과값을 참으로 변경
			
			if ( p1isRight || p2isRight || p3isRight || p4isRight) {
	
			System.out.println("맞춘 선수가 있습니다.") ;
			System.out.println("1번 선수: " + p1isRight) ;
			System.out.println("2번 선수: " + p2isRight) ;
			System.out.println("3번 선수: " + p3isRight) ;
			System.out.println("4번 선수: " + p4isRight) ;
			System.out.println("게임 끝.");
			break;//게임이 끝나서 반복문을 나감
			}//못맞췄기 때문에 다시 실행하라함	else {
			System.out.println("다시 시도해야 합니다.");//조건문 끝
			}// 순환문 끝
		}//메소드 끝
	}// 클래스 끝
}
public class Player { //플레이어 부분은 바뀔게 없음
	int number = 0;
	
	public void guess() {
		number = (int) (Math.random() * 10 ) ;
		System.out.println("찍은 숫자: " + number) ;
	}
}
public class GameLauncher { //게임 런처 부분은 바뀔게 없음
	public static void main (String[] args) {
		GuessGame game = new GuessGame() ;
		game.startGame();
	}
}

}}}

*76p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A
class TapeDeck {
	
	boolean canRecord = false;
	
	void playTape() {//테이프플레이메소드
		System.out.println("tape playing");
	}
	
	void recordTape() {//리코드테이프메소드
		System.out.println("tape recording");
	}
}

class TapeDeckTestDrive {
	public static void main(String [] args) {
	
		TapeDeck t = new TapeDeck(); //t라는 TapeDeck 객체 선언

		t.canRecord = true;
		t.playTape();//플레이테이프메소트호출
		
		if(t.canRecord == true ) {
			t.recordTape();//리코드테이프메소드호출
			}
		}
	}

B
class DVDPlayer {
	
	boolean canRecord = false ;
	
	void recordDVD() {//리코드디브이디메소드
		System.out.println("DVD recording");
	}
	void playDVD() {
		System.out.println("DVD playing");//플레이디브이디 메소드를 추가

	}
}
class DVDPlayerTestDrive {
	public static void main(String [] args) {
	
	DVDPlayer d = new DVDPlayer ();//d라는 디브이디플레이어 객체 생성
	d.canRecord = true;
	d.playDVD ();//플레이디브이디 메소드 호출
	
	if(d.canRecord == true) {
		d.recordDVD();//리코드디브이디 메소드 호출
		}
	}
}
}}}

= 03. 네 변수를알라:원시 변수와 레퍼런스  =

*83p~ 변수* _요약_

 * 원시변수 vs 레퍼런스변수: 변수는 원시변수와 레퍼런스 변수로 나눌수 있다.
원시 변수에는 정수,부울,부동소수전 수와 같이 비트 패턴으로 나타낼 수 있는 기초적인 값이 들어간다.
객체 레퍼런스에는 객체에 대한 레퍼런스가 들어간다.
 

*96p Dog* _수많은 개를 만들어 난장판 만들기_

{{{

class Dog {
	String name;
	public static void main (String[] args) {
		//Dog 객체를 만들고 접근합니다.
		Dog dog1 = new Dog();
		dog1.bark() ;
		dog1.name = "나서스" ;
		
		//이번에는 Dog 배열을 만듭니다.
		Dog[] myDogs = new Dog[8];
		//그리고 개 8 마리를 집어넣습니다.
		myDogs[0] = new Dog() ;
		myDogs[1] = new Dog() ;
		myDogs[2] = new Dog() ;
		myDogs[3] = new Dog() ;
		myDogs[4] = new Dog() ;
		myDogs[5] = new Dog() ;
		myDogs[6] = new Dog() ;
		myDogs[7] = dog1;
	

		//배열 레퍼런스를 써서 Dog 객체에
		//접근합니다.
		myDogs[0].name = "똥개";
		myDogs[1].name = "개석환";
		myDogs[2].name = "개태완";
		myDogs[3].name = "개선우";
		myDogs[4].name = "복날이";
		myDogs[5].name = "개새x" ;
		myDogs[6].name = "개노답";
		//마지막 개의 이름이 뭐였지?
		System.out.print("마지막 개의 이름: ");
		System.out.println(myDogs[7].name);
		
	
		//이제 순환문을 써서 배열에 들어있는
		//모든 개가 짖도록 합시다.
		int x = 0;
		while(x < myDogs.length) {
			myDogs[x].bark();
			x = x + 1;
		}
	}
	public void bark() {
		System.out.println(name + "이(가) 왈! 하고 짖습니다.");
	}
	public void eat() { }
	public void chaseCat() { }
}

}}}

*97p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{
A
class Books {
	String title ;
	String author ;
}

class BooksTestDrive {
	public static void main(String [] args) {
	
		Books [] myBooks = new Books[3] ;
		myBooks[0] = new Books();
		myBooks[1] = new Books();
		myBooks[2] = new Books(); //Books라는 객체를 생성
		int x = 0;
		myBooks[0].title = "The Grapes of Java";
		myBooks[1].title = "The Java Gatsby";
		myBooks[2].title = "The Java Cookbook";
		myBooks[0].author = "bob";
		myBooks[1].author = "sue";
		myBooks[2].author = "ian";
	
		while(x<3) {
			System.out.print(myBooks[x].title);
			System.out.print(" by ");
			System.out.println(myBooks[x].author);
			x = x + 1;
		}
	}
}

B
class Hobbits {
	
	String name ;
	
	public static void main(String [] args) {
	
		Hobbits [] h = new Hobbits[3];
		int z = 0 ;

		while(z<3) {//이름의 갯수는 3개이므로 3으로 조절
	
			h[z] = new Hobbits();
			h[z].name = "bilbo";
			if(z==1) {
				h[z].name = "frodo";
			}
			if(z==2) {
				h[z].name = "sam";
			}
			System.out.print(h[z].name + " is a " );
			System.out.println("good Hobbit name");
			z=z+1;//맨앞에 있으면 0번째가 의미가 없으므로 맨 밑으로 내림
		}
	}
}

}}}

*101p 레퍼런스 도용사건* _요약_

 * 누가 이겼나요?:밥
 * 문제가 된 부분은 어딘가요?: 켄트의 코드는 메모리를 약간 절약할수는 있다. 하지만 켄트의 코드는 매번 순환문을 돌때마다 새로운 값으로 초기화 시키기 때문에 결국 밥의 코드보다 효용성이 없는 코드가 된다.

= 04. 객체의 행동:객체의 상태가 메소드의 속성에 미치는 영향  =

*105p~ 객체* _요약_

 * 캡슐화:외부에 노출되어있는 변수를 보호하기 위하여 인스턴스 변수를 private로 지정하고 접근 제어를 위해 public으로 지정된 게터와 세터를 만든다.
 * 게터와 세터: 어떤것을 가져오고 설정하는 역할
게터는 게터가 가져오기로 되어있는값을 리턴값 형태로 받아오기 위한 용도

세터는 세터가 설정할 값을 인자로 받아서 인스턴스 변수를 그 값으로 설정하기 위한 용도
 * 인스턴스 변수 vs 지역 변수:
인스턴스변수는 클래스 내에서 선언

지역변수는 메소드 내에서 선언, 사용전에 초기화를 해야됨

 
*107p Dog* _실행_

{{{
class Dog {
	int size ;
	String name;

	void bark() {
		if(size > 60) {
			System.out.println("Wooof! Wooof!");
		} else if (size > 14) {
			System.out.println("Ruff! Ruff!");
		} else {
			System.out.println("Yip! Yip!");
		}
	}
}

class DogTestDrive {
	
	public static void main(String [] args) {
		Dog one = new Dog();
		one.size = 70;
		Dog two = new Dog();
		two.size = 8;
		Dog three = new Dog();
		three.size = 35;
	
		one.bark();
		two.bark();
		three.bark();
	}
}

}}}

*122p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

A

class XCopy {
	
	public static void main(String []args) {
	
		int orig = 42;
	
		XCopy x = new XCopy(); // XCopy유형의 객체 x선언

		int y = x.go(orig);//객체x에서 go를 호출 이때 orig값을 보낸후 메소드를 실행해 y에 그값을 리턴
	
		System.out.println(orig + " " + y );
	}
	
	int go(int arg) { //함수를 int값으로 리턴을 받게됨
	
		arg=arg*2;
		
		return arg;//arg를 리턴
	}
} //결과는 42 84

B

class Clock {
	String time;
	
	void setTime(String t) {//String의 t를받아 이를 time으로 보내주는 세터
		time = t;
	}
	
	String getTime() { //time을 리턴받는 게터이고 받을 time은 String이므로 String으로 선언
		return time;
	}
}

class ClockTestDrive {
	public static void main(String [] args) {
	
		Clock c = new Clock();
		
		c.setTime("1245");
		String tod = c.getTime();
		System.out.println("time :  "  + tod);
	}
} // 출력값은 time : 1245

}}}


= 05. 메소드를 더 강력하게:흐름 제어, 연산 등  =

*135p XP* _요약_

 * 익스트림 프로그래밍이란?

90년대 말에 등장학 프로그래머들이 정말 원하는 방법으로 여러가지 규칙이 있다.

-테스트 코드를 먼저만든다.

-야근을 하지 않고 기회가 생기는 족족 코드를 개선

-테스트를 통과한 후에 발표를 한다

-스펙에 필요한 기능만 집어넣고 단순하게 처리한다

-두명씩 팀을 편성하고 코드를 모두 알 수 있도록 돌아가면서 진행
 

*137p~ 간단한 닷컴 게임* _구현후 주석달기_

{{{

import java.io.*;
//뭔지는 모르겟지만 뭔가를 가져오는듯
public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}
//내용은 모르겟지만 책에서는 나중에 배우니 일단 쓰라고함

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0 ;
//초기 히트수를 0으로 초기화
	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]) {
				result = "hit";
				numOfHits++;
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";//맞춤
		}
		System.out.println(result);
		return result;
	}
}

public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {//맞추면
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

= 06. 자바 라이브러리:전부 다 직접 만들어서 쓸 필요는 없습니다  =

*162p 닷컴 게임:첫번째 옵션* _구현후 주석달기_

{{{

import java.io.*;

public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}



public class SimpleDotCom {
	
	int[] locationCells;
	boolean[] hitCells = new boolean[3];//hitCells이라는 boolean형 배열을 생성
	int numOfHits = 0 ;

	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public void sethitCells(boolean[] hit) {//위의 setLocationCells처럼 sethitCells메소드를 추가
		hitCells = hit;
	}
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]&&hitCells[i]==false) {//이미 맞췃는지에대한 확인추가
				result = "hit";
				numOfHits++;
				hitCells[i]=true;//맞췃다는 표시를함
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
	}
}


public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
	
		boolean[] hitCells = new boolean[3];//첫번째 옵션에 필요한 boolean배열을 생성
	 	theDotCom.sethitCells(hitCells);//boolean배열을 닷컴클래스로 보내줌
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

*163p 닷컴 게임:두번째 옵션* _구현후 주석달기_

{{{

import java.io.*;

public class GameHelper {
	
	public String getUserInput(String prompt) {
		
		String inputLine = null;
		
		System.out.print(prompt + " " );
		
		try{
		
			BufferedReader is = new BufferedReader (
			
			new InputStreamReader(System.in));
			
		inputLine = is.readLine();
	
		if(inputLine.length()==0) return null;
			
		} catch (IOException e) {
			
			System.out.println("IOExceoption:  " + e);
		}
		
		return inputLine;
	}
}

public class SimpleDotCom {
	
	int[] locationCells;
	int numOfHits = 0 ;

	public void setLocationCells(int[] locs) {
		locationCells = locs;
	}
	
	public String checkYourself(String stringGuess) {
		int guess = Integer.parseInt(stringGuess);
		String result = "miss";
		for(int i=0;i<locationCells.length;i++) {
			if(guess==locationCells[i]&&locationCells[i]!=-1) {//-1이면 맞춘자리 이므로 이에대한 확인
				result = "hit";
				numOfHits++;
				locationCells[i]=-1;//맞췃다는 표시로 -1을 넣어줌
				break;
			}
		}
		
		if(numOfHits == locationCells.length) {
			result = "kill";
		}
		System.out.println(result);
		return result;
	}
}

public class SimpleDotComTestDrive { 

        public static void main(String[] args) {

                int numOfGuesses = 0;
                GameHelper helper = new GameHelper();

                SimpleDotCom theDotCom = new SimpleDotCom();

                int randomNum = (int) (Math.random() * 5); // 난수를 발생합니다.

                int[] locations = { randomNum, randomNum + 1, randomNum + 2 };
                theDotCom.setLocationCells(locations);
                boolean isAlive = true;

                while (isAlive == true) {
                        String guess = helper.getUserInput("enter a number");
                        String result = theDotCom.checkYourself(guess);
                        numOfGuesses++;

                        if (result.equals("kill")) {
                                isAlive = false;
                                System.out.println(numOfGuesses + " guesses");
                        }

                } 

        } 
}

}}}

*173p 닷컴 게임:세번째 옵션* _구현후 주석달기_

{{{

import java.util.ArrayList;

public class DotCom {

  private ArrayList<String> locationCells;
  //private int numOfHits;
  //(없어도 됩니다.)

  public void setLocationCells(ArrayList<String> loc) {
    locationCells = loc;
  }

  public String checkYourself(String userInput) {

    String result = "miss";

      int index = locationCells.indexOf(userInput);

       if(index>=0) {

          locationCells.remove(index);

          if(locationCells.isEmpty()){
            result = "kill";
          } else {
            result = "hit";
          }//if문 끝

         }//바깥쪽if문 끝

      return result;

   }//메소드 끝
 }//클래스끝


}}}

*174p 진짜 닷컴 게임* _구현후 주석달기_

{{{

}}}

= 07. 객체마을에서의 더 나은 삶:미래를 준비합시다  =

*199p~ 상속과 다형성* _요약_

 * 상속:공통적인 코드를 어떤 클래스에 넣은 다음,다른 더 구체적인 클래스에 공통적인(더 추상적인) 클래스가 상위클래스라는 것을 알려주면 됩니다. 한 클래스가 다른 클래스를 상속하는 것을 하위클래스가 상위클래스로부터 상속받는다고 말합니다.
 * 다형성: 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있습니다. 다형성은 하나의 변수와 메소드가 다양한 의미로 사용 가능하다는 것이고 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있습니다.

*208p 클래스 계층 구조* _클래스로 구현_

{{{

class Animal
{
        String picture; //그 동물의 모습을 보여주는 JPEG파일명
        Boolean food;//그 동물이 먹는 음식의 형식,초식과 육식
        int hunger;//동물이 배고픈 정도
        float boundaries;//동물이 돌아다니는 공간
        float location;//동물의 위치를 나타내는 좌표

        void makeNoise()
        {
//동물이 소리를 낼 떄의 행동
        }

        void eat()
        {
//동물이 음식을 접했을 때의 행동
        }

        void sleep()
        {
//동물이 잠들어 있을 때의 행동
        }

        void roam()
        {
//동물이 배회할때의 행동
        }

}
//Animal을 상속받습니다.
class Feline extends Animal
{
        void roam()
        {
            // roam를 오버라이드합니다.
        }
}
//Animal을 상속받습니다.
class Canine extends Animal
{
        void roam()
        {
             // roam을 오버라이드합니다.
        }
}
//Feline을 상속받습니다.
class Lion extends Feline
{
        void makeNoise()
        {
              // makeNoise를 오버라이드합니다.
        }

        void eat()
        {
              //eat를 오버라이드합니다.
        }
}
//Feline을 상속받습니다.
class Tiger extends Feline
{
        void makeNoise()
        {
           // makeNoise를 오버라이드합니다.
        }

        void eat()
        {
           // eat를 오버라이드합니다.
        }
}


//Feline을 상속받습니다.
class Cat extends Feline
{
        void makeNoise()
        {
              
        }

        void eat()
        {
             //eat를 오버라이드합니다.
        }
}
//Animal을 상속받습니다.
class Hiippo extends Animal
{
        void makeNoise()
        {
             // makeNoise를 오버라이드합니다.
        }

        void eat()
        {
              //eat를 오버라이드합니다.
        }
}
//Canine을 상속받습니다.
class Wolf extends Canine
{
        void makeNoise()
        {
           // makeNoise를 오버라이드합니다.
        }

        void eat()
        {
           //eat를 오버라이드합니다.
        }
}
//Canine을 상속받습니다.
class Dog extends Canine
{
        void makeNoise()
        {
           // makeNoise를 오버라이드합니다.
        }

        void eat()
        {
            //eat를 오버라이드합니다.
        }
}
}}}
 
*224p 오버라이드와 오버로딩* _요약_

 * 오버라이드: 오버라이드를 사용하여 상위클래스의 메소드를 하위클래스에서 재 정의하여 사용할수 있습니다.

오버라이드를 사용하기 위해서는

1. 인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 합니다.

2.메소드를 더 접근하기 어렵게 만들면 안 됩니다.
상위클래스에서 public으로 선언하던것을 private로 선언하여 더 접근하게 어렵게 하면 안됩니다.

 * 오버로딩: 메소드 오버로딩은 이름이 같고 인자 목록이 다른 메소드 두개를 만드는 것입니다. 오버로드된 메소드는 다형성과 전혀 관계가 없습니다. 오버로딩을 활용하여 같은 메소드를 서로 다른 인자 목록을 가진 여러 버전으로 만들 수 있습니다. 
오버로딩의 경우는 리턴 유형이 달라도 되지만 리턴 유형만 달라서는 안됩니다. 또한 접근 단계를 마음대로 바꿀 수 있습니다.

*227p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

1.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return true;
}
}

class Vampire extends Monster {

boolean frighten(int x){
	System.out.println("a bite?");
	return false;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

제대로 작동합니다.

결과값 : 
a bite?
breath fire
arrrgh
}}}

{{{

2.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return true;
}
}

class Vampire extends Monster {

int frighten(int x){
	System.out.println("a bite?");
	return 1;//return 유형이 int인데 상위클래스는 boolean이기 때문에 오버로딩 불가
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

}}}

{{{

3.

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return false;
}
}

class Vampire extends Monster {

boolean scare(int x){//메소드가 frighten이 아닌 scare입니다. 따라서 본 클래스에서 
상위클래스의 메소드를 사용하게 됩니다.
	System.out.println("a bite?");
	return true;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

결과값 : 

arrrgh
breath fire
arrrgh

}}}

{{{

public class MonsterTestDrive {
	public static void main(String [] args) {
		Monster [] ma = new Monster[3];
		ma[0] = new Vampire();
		ma[1] = new Dragon();
		ma[2] = new Monster();
		for(int x = 0 ;x<3;x++) {
			ma[x].frighten(x);
		}
	}
}

class Monster {

boolean frighten(int d) {
	System.out.println("arrrgh");
	return false;
}
}

class Vampire extends Monster {

boolean frighten(byte b){//상위클래스의 메소드와 매개변수가 다릅니다. 따라서 오버
로드 하지 않습니다.
	System.out.println("a bite?");
	return true;
}
}

class Dragon extends Monster {
	boolean fighten (int degree ) {
		System.out.println("breath fire");
		return true;
	}
}

결과값 : 
arrrgh
breath fire
arrrgh
}}}

= 08. 심각한 다형성:추상 클래스와 인터페이스  =

*231p~ 심각한 다형성* _요약_

 * 인터페이스:100% 추상클래스 이다. 인터페이스를 사용하면 다중 상속으로 인한 죽음의 다이아몬드라는 부작용을 없애 다중 상속의 효과를 누릴 수 있습니다. 모든 메소드를 추상 메소드로 정의하여 자식 클래스에서는 무조건 오버라이드 해야합니다.
 * 다형성:: 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있습니다. 다형성은 하나의 변수와 메소드가 다양한 의미로 사용 가능하다는 것이고 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있습니다.
 * 추상 클래스: 추상 클래스를 지정하면 인스턴스를 만들수가 없다. 추상 메소드를 만들기 위해서는 클래스 또한 추상 클래스이어야 한다.추상 클래스는 확장하지 않으면 쓸모가 없습니다.
 * 추상 메소드: 추상 클래스처럼 메소드도 추상 메소드로 지정할수 있다. 이러한 추상 메소드는 반드시 오버라이드 해야한다는 특징이 있다. 추상 메소드를 사용하는 이유는 반드시 오버라이드 해야한다는 특징으로 하위클래스에서 필요한 메소드를 강제로 지정함으로 인하여 놓치지 않고 지정할수 있다는 장점이 있다.
 * 다중 상속: 여러 부모 객체에게 상속을 받는것 자바는 지원하지 않는다. 따라서 이를 하기 위해서는 인터페이스를 사용해야한다. 다중 상속을 지원하게 되면 상위클래스의 메소드에 접근을 할때 그 위치가 불분명하게 되는 '죽음의 다이아몬드'라는 문제가 생기게 됩니다.

= 09. 객체의 삶과 죽음:생성자와 메모리 관리  =

*269p~ 객체의 삶과 죽음* _요약_

 * 힙에서의 변수: 힙은 모든 객제가 사는곳 입니다. 인스턴스 변수는 객체안에 존재하
므로 힙에 산다고 할수 있습니다.
 * 스택에서의 변수: 메소드를 호출하면 그 메소드는 호출스택 맨위에 올라갑니다. 실제로는 스택 프레임이 올라가며 모든 지역변수를 포함한 메소드가 들어있습니다. 지역변수가 객체에대한 레퍼런스인 경우에는 레퍼런스만 스택에 들어가고 객체 자체는 힙안에 들어갑니다.
 * 생성자:생성자는 메소드와 비슷한 형태로 객체를 만드는 역할을 합니다. 생성자는 컴파일러에서 알아서 만들어 줍니다. 생성자는 new를 한후 호출해줍니다.생성자를 통해서 객체의 상태를 초기화합니다.즉 객체의 인스턴스 변수에 값을 대입하는 작업을 합니다.
 * 널 레퍼런스: 레퍼런스에 NULL을 대입하여 가리키는 레퍼런스가 없게합니다. 이때 이 레퍼런스는 점 연산자를 사용할수 없게되며 사용하려고 할시에는 에러를 출력합니다.
 
*298p 집중토론* _요약_

 * 인스턴스 변수: 객제를 지원하는 역할,객체와 함께 힙에 존재,객체의 상태를 저장
자신이 속한 객체가 가비지 컬렉터에의하여 삭제되면 같이 삭제됨, 객체를 참조하는 인스턴스가 지역변수에만 존재하면 지역변수가 끝날시에 같이 사라진다.
 * 지역 변수: 메소드에 존재,기간이 짧아서 임시 변수라고도 함, 스택 프레임에 빼곡 쌓여있음, 프레임이 맨 위로 올라갈때까지 기다리고 있음,메소드가 끝나면 스택에서 튕겨나감

*302p 5분 미스터리* _구현후 주석달기_

{{{

import java.util.*;
class V2Radiator
{
        V2Radiator(ArrayList<SimUnit> list) //ㅣist를 받아옵니다.
        {
                for(int x = 5; x < 5 ; x++) 
                {
                        list.add(new SimUnit("V2Radiator"));//받아온 List에 5번 SimUnit을 추가하고 V2Radiator를 줍니다.
                }
        }
}

class V3Radiator //extends V2Radiator 불필요한 부분입니다.
{
        V3Radiator(ArrayList<SimUnit> lglist)//lglist를 받아옵니다.
        {
                //super(lglist); 불필요한 부분입니다. 이부분에서 불필요하게 5개의 SimUnit이 생성됩니다.
                for(int g = 0; g < 10 ; g++)
                {
                        lglist.add(new SimUnit("V3Radiator"));//lglist에 10번 SimUnit을 추가하고 V3Radiator를 줍니다.
                }
        }
}

class RetentionBot
{
        RetentionBot(ArrayList<SimUnit> rlist)
        {
                rlist.add(new SimUnit("Rention"));
        }
}

public class TestLifeSupportSim 
{
        public static void main(String[] args)
        {
                ArrayList<SimUnit> aList = new ArrayList<SimUnit>();//aList의 ArrayList생성
                V2Radiator v2 = new V2Radiator(aList);//v2객체 생성
                V3Radiator v3 = new V3Radiator(aList);//v3객체 생성
                for(int z = 0 ; z < 20 ; z++)
                {
                        RetentionBot ret = new RetentionBot(aList); //20번 ret객체를 생성합니다.
                }
        }
}

class SimUnit
{
        String botType;
        SimUnit(String type)
        {
                botType = type;
        }
        int powerUse()
        {
                if("Retention".equals(botType))
                {
                        return 2;                       
                }
                else
                {
                        return 4;
                }
        }
}

}}}

= 10. 숫자는 정말 중요합니다:수학, 포매팅, 래퍼, 통계  =

*307p~ 숫자* _요약_

 * 정적 메소드:클래스의 인스턴스없이 메소드를 실행할 수 있습니다. 인스턴스 변수에 따라 행동이 달라지지 않기 때문에 인스턴스나 객체가필요하지 않습니다. 클래스만 있어도 됩니다.

 * 정적 메소드를 선언하는 방법:메소드에 static이라는 키워드를 붙여줍니다.

 * static final:static final 로 선언된 변수는 상수입니다. 초기화되고나면 절대 그 값을 바꿀 수 없습니다.static으로 선언되어 있기때문에 인스턴스를 만들지 않아도 됩니다. 보통 상수의 변수명은 모두 대문자로 씁니다.

 * 널 레퍼런스:레퍼런스에 NULL을 대입하여 아무것도 가르키지 않게합니다. NULL을 가리키는 레퍼런스는 점 연산자를 사용할수 없습니다.

 * 오토 박싱:자바 5.0이전에는 원시변수와 객체 레퍼선스가 엄격하게 구분되어 있었기에 절대로 서로 맞바꿔 사용 불가능했습니다. 사용하려면 원시값을 감싸고 포장을 풀어야했습니다. 자바 5.0부터 도입된 오토박싱을 통하여 이러한 과정을 손쉽게 할수 있게 되었습니다. 

 * 정적 임포트: 자바 5.0에서 도입된 개념으로 모든 코드를 다 쓰지 않고 짧게 쓸수 있습니다. 하지만 가독성이 떨어질수 있습니다.

*339p Calendar* _구현후 주석달기_

{{{

import java.util.*;
public class CalendarII/*클래스 이름을 Calendar라고하면 객체생성에 에러가 떠서 II
를 붙였습니다.*/
{
        public static void main(String[] args)
        {
                Calendar c = Calendar.getInstance();
                c.set(2004,0,7,15,40);//시각을 2004년 1월 7일 15:40 으로 설정
                long day1 = c.getTimeInMillis();//1970년 1월1일부터 경과한 시간을 밀리초 단위로 표현한 값을 리턴합니다.
                day1 += 1000 * 60 * 60;
                c.setTimeInMillis(day1);//한 시간에 해당하는 밀리초 만큼의 시간을 더하고 시각을 갱신합니다.
                System.out.println("new hour" + c.get(c.HOUR_OF_DAY));
                c.add(c.DATE, 35);//35일을 더합니다.
                System.out.println("add 35 days " + c.getTime());
                c.roll(c.DATE, 35);//35일 뒤로 넘깁니다. 하지만 달은 바뀌지 않습니다.
                System.out.println("roll 35 days " + c.getTime());
                c.set(c.DATE, 1);//날짜를 1로 설정합니다.
                System.out.println("set to 1 " + c.getTime());
                
        
        }
}
}}}

*342p 집중토론* _요약_

정적 변수에 대한 토론

 * 인스턴스 변수: 정적 변수는 상수에 불가, 특변한 경우에만 많이 사용, 디버깅할때에
만 특별한경우로 사용, 객체지향적이 아님, 전역변수랑 비슷함, 옛 관습에 익숙한 사람
들만 사용함, 가끔 익숙하긴 하지만 여전히 옛습관의 폐해, 프로시저 위주

 * 정적 변수: API에서 많이 사용, 상수만 사용하는 클래스도 존재 특별한 경우라도 중
요함 정적변수가 더 효율적, 전역변수가 아님, 클래스 안에서 존재,필수적인것도 있음

*344p 컴파일러가 되어봅시다* _구현후 주석달기_

{{{

class StaticSuper{

        static { 
        System.out.println("super static block");
        }

        StaticSuper() { //생성자이므로 ()를 붙입니다.
        System.out.println("super constructor");
        }
}

public class StaticTests extends StaticSuper {//StaticSuper를 상속

        static int rand; 

        static { 
        rand=(int_ (Math.random()*6);
        System.out.println("static block " + rand);
        }

        StaticTests(){ 
        System.out.println("constructor");
        {

        public static void main(String [] args) {
        System.out.println("in main");
        StaticTests st = new StaticTests ();//객체 생성
        }
}

}}}

= 11. 위험한 행동:예외처리  =

*357p try/catch* _구현후 주석달기_

{{{


public void takeRisk() throws BadException
        {
                if(abandonAllHope)//만약 모든 희망을 버리면으로 오류가 생기는 부분입니다.
                {
                        throw new BadException();//BadException이라는 오류를 throw합니다.
                }
        }
        
 public void crossFingers()
        {
                try
                {
                        anObject.takeRisk();//오류가 발생할수 있는 부분입니다.
                }
                catch(BadException ex)//BadException을 잡습니다. 오류가 뜨면 밑의 
부분이 실행됩니다.
                {
                        System.out.println("Aaargh!");
                        ex.printStackTrace();
/*예외 상황을 해결할수 없을때 모든 예외 객체에서 물려받는 printStackTrace()메소드
를 써서 스택 트레이스를 출력합니다.*/
                }
        
        
        }
}
}}}

*376p~ 첫번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

*380p~ 두번째 사운드 애플리케이션* _구현후 주석달기_

{{{

}}}

= 12. 그래픽이야기:GUI, 이벤트처리, 내부 클래스에 대한 소개  =

*389p~ 첫번째 GUI:버튼* _구현후 주석달기_

{{{

}}}

*394p~ ActionEvent* _구현후 주석달기_

{{{

}}}

*405p 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*413p 두개의 버튼과 원의색* _구현후 주석달기_

{{{

}}}

*418p 간단한 애니메이션* _구현후 주석달기_

{{{

}}}

*420p 뮤직 비디오* _구현후 주석달기_

{{{

}}}

= 13. 스윙을 알아봅시다:레이아웃 관리와 구성요소  =

*452p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}

= 14. 객체 저장:직렬화와 입출력  =

*496p 비트박스 프로그램* _구현후 주석달기_

{{{

}}}